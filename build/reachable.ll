; Generated by UnifyWeaver LLVM Target - Transitive Closure
; Predicate: reachable/2
; Algorithm: BFS worklist for graph reachability

source_filename = "reachable.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Edge representation: adjacency list (simplified as array pairs)
; Edge: [from, to] stored contiguously
@edges = internal global [100 x i64] zeroinitializer
@edge_count = internal global i64 0

; Visited set (bitmap for efficiency)
@visited = internal global [1000 x i1] zeroinitializer

; BFS queue
@queue = internal global [1000 x i64] zeroinitializer
@queue_head = internal global i64 0
@queue_tail = internal global i64 0

; Add an edge to the graph
define void @add_edge(i64 %from, i64 %to) {
entry:
  %count = load i64, i64* @edge_count
  %idx1 = mul i64 %count, 2
  %idx2 = add i64 %idx1, 1
  %ptr1 = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %idx1
  %ptr2 = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %idx2
  store i64 %from, i64* %ptr1
  store i64 %to, i64* %ptr2
  %new_count = add i64 %count, 1
  store i64 %new_count, i64* @edge_count
  ret void
}

; Enqueue a node
define void @enqueue(i64 %node) {
entry:
  %tail = load i64, i64* @queue_tail
  %ptr = getelementptr [1000 x i64], [1000 x i64]* @queue, i64 0, i64 %tail
  store i64 %node, i64* %ptr
  %new_tail = add i64 %tail, 1
  store i64 %new_tail, i64* @queue_tail
  ret void
}

; Dequeue a node
define i64 @dequeue() {
entry:
  %head = load i64, i64* @queue_head
  %ptr = getelementptr [1000 x i64], [1000 x i64]* @queue, i64 0, i64 %head
  %node = load i64, i64* %ptr
  %new_head = add i64 %head, 1
  store i64 %new_head, i64* @queue_head
  ret i64 %node
}

; Check if queue is empty
define i1 @queue_empty() {
entry:
  %head = load i64, i64* @queue_head
  %tail = load i64, i64* @queue_tail
  %empty = icmp eq i64 %head, %tail
  ret i1 %empty
}

; Check if node is visited
define i1 @is_visited(i64 %node) {
entry:
  %ptr = getelementptr [1000 x i1], [1000 x i1]* @visited, i64 0, i64 %node
  %val = load i1, i1* %ptr
  ret i1 %val
}

; Mark node as visited
define void @mark_visited(i64 %node) {
entry:
  %ptr = getelementptr [1000 x i1], [1000 x i1]* @visited, i64 0, i64 %node
  store i1 true, i1* %ptr
  ret void
}

; Transitive closure: can we reach target from source?
; reachable(Source, Target) -> bool
define i1 @reachable(i64 %source, i64 %target) {
entry:
  ; Reset visited and queue
  store i64 0, i64* @queue_head
  store i64 0, i64* @queue_tail
  
  ; Mark source visited and enqueue
  call void @mark_visited(i64 %source)
  call void @enqueue(i64 %source)
  
  br label %bfs_loop

bfs_loop:
  %empty = call i1 @queue_empty()
  br i1 %empty, label %not_found, label %process_node

process_node:
  %current = call i64 @dequeue()
  
  ; Check if we found target
  %found = icmp eq i64 %current, %target
  br i1 %found, label %found_target, label %explore_neighbors

found_target:
  ret i1 true

explore_neighbors:
  ; Iterate through edges (simplified: check all edges)
  %edge_cnt = load i64, i64* @edge_count
  br label %edge_loop

edge_loop:
  %i = phi i64 [ 0, %explore_neighbors ], [ %i_next, %edge_continue ]
  %done = icmp sge i64 %i, %edge_cnt
  br i1 %done, label %bfs_loop, label %check_edge

check_edge:
  %from_idx = mul i64 %i, 2
  %to_idx = add i64 %from_idx, 1
  %from_ptr = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %from_idx
  %to_ptr = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %to_idx
  %from = load i64, i64* %from_ptr
  %to = load i64, i64* %to_ptr
  
  ; Check if this edge starts from current node
  %is_match = icmp eq i64 %from, %current
  br i1 %is_match, label %maybe_enqueue, label %edge_continue

maybe_enqueue:
  ; Check if neighbor not visited
  %already_visited = call i1 @is_visited(i64 %to)
  br i1 %already_visited, label %edge_continue, label %do_enqueue

do_enqueue:
  call void @mark_visited(i64 %to)
  call void @enqueue(i64 %to)
  br label %edge_continue

edge_continue:
  %i_next = add i64 %i, 1
  br label %edge_loop

not_found:
  ret i1 false
}

; Main entry point for testing
define i32 @main(i32 %argc, i8** %argv) {
entry:
  ; Create test graph: 0 -> 1 -> 2 -> 3
  call void @add_edge(i64 0, i64 1)
  call void @add_edge(i64 1, i64 2)
  call void @add_edge(i64 2, i64 3)
  
  ; Test: can we reach 3 from 0?
  %result = call i1 @reachable(i64 0, i64 3)
  
  ; Return 0 if reachable (success), 1 otherwise
  %exit = select i1 %result, i32 0, i32 1
  ret i32 %exit
}
