# Prolog as Target Language - Design Document

**Date:** 2025-10-27
**Status:** ‚úÖ Phase 1 Implemented (Basic Foundation)
**Branch:** `feat/prolog-as-target`
**Implementation:** `src/unifyweaver/targets/prolog_target.pl`

---

## Implementation Status

### ‚úÖ Completed (Phase 1 - Foundation)

**Module:** `src/unifyweaver/targets/prolog_target.pl` (~400 lines)

**Features Implemented:**
- ‚úÖ `generate_prolog_script/3` - Main entry point for code generation
- ‚úÖ `analyze_dependencies/2` - Automatic dependency detection from user code
- ‚úÖ Predicate copying via clause introspection (verbatim)
- ‚úÖ Script template generation (shebang, header, imports, entry point)
- ‚úÖ Module search path setup (UNIFYWEAVER_HOME environment variable)
- ‚úÖ Dependency mapping (partitioner, parallel backend, data sources)
- ‚úÖ Plugin registration detection (strategies, backends)

**Tests:** `examples/test_prolog_target.pl` - All 4 tests passing ‚úì

**Key Capabilities:**
1. Detects when user code uses partitioning ‚Üí includes partitioner module
2. Detects specific strategies (fixed_size, hash_based, key_based) ‚Üí includes strategy module
3. Detects data sources (CSV, JSON, HTTP) ‚Üí includes source modules
4. Generates executable scripts with proper initialization
5. Handles plugin registration automatically

**Example Generated Script:**
```prolog
#!/usr/bin/env swipl
% Generated by UnifyWeaver v0.0.3
% Target: Prolog
% Set up UnifyWeaver runtime library search path
:- use_module(library(unifyweaver/partitioner)).
% User code (copied via introspection)
double(A, B) :- B is A*2.
% Entry point
main :- double(5, Result), format('Result: ~w~n', [Result]), halt(0).
:- initialization(main, main).
```

### üöß In Progress / TODO

**Configuration Substitution:**
- [ ] Template-based generation for configured predicates
- [ ] Handle configuration layers (global, predicate, call-level)
- [ ] Substitute user config into partitioner_init/backend_init calls

**Runtime Library Packaging:**
- [ ] Organize runtime modules in `runtime/` directory
- [ ] Create SWI-Prolog pack metadata
- [ ] Test pack installation: `swipl-pack install unifyweaver`

**Integration:**
- [ ] Add `--target prolog` CLI flag to main compiler
- [ ] Integration with existing compilation pipeline
- [ ] Update examples to demonstrate Prolog target

**Inline Runtime (Optional):**
- [ ] Support `inline_runtime(true)` option
- [ ] Embed runtime library code in generated script
- [ ] Make scripts fully standalone

### üìù Implementation Notes & Learnings

**Key Design Decision: General Transpiler, Not Partitioning-Specific**
- Prolog-as-target is a **general transpilation capability**
- Happens to be useful for partitioning, but not limited to it
- Any Prolog predicate that needs runtime library support can use this
- Prolog-as-service will also be general (not file/partition-specific)

**Dependency Detection Strategy:**
- Uses clause introspection (`clause/2`) to analyze predicate bodies
- Recursively searches for known goal patterns
- Maps patterns to required modules (e.g., `partitioner_init` ‚Üí `unifyweaver/core/partitioner`)
- Detects configuration (e.g., `fixed_size(...)` ‚Üí load fixed_size strategy)
- Automatically generates plugin registrations

**Code Generation Approach:**
- **Verbatim copying** for simple predicates (no configuration)
- Uses `clause/2` + `portray_clause/1` to capture predicate clauses
- Variable names may differ (A,B vs X,Y) but logic preserved
- **Template-based** generation planned for configured predicates (future)

**Format String Gotcha:**
- When building generated code strings, avoid `format(atom(...), ...)` with `~w` placeholders
- If placeholder contains `~n`, it becomes literal `\n` in generated code ‚Üí error
- Solution: Build strings with `atomic_list_concat` instead

**Search Path Strategy:**
- Check `UNIFYWEAVER_HOME` environment variable first
- Fall back to SWI-Prolog pack installation (`library(unifyweaver/...)`)
- Future: Support relative paths for development

**Testing Approach:**
- Test dependency detection separately from code generation
- Test generated scripts can be written to files
- Don't execute generated scripts in tests (would require runtime library installed)
- Focus on: correct structure, correct dependencies, valid Prolog syntax

---

## Problem Statement

UnifyWeaver currently implements partitioning and parallel execution as **runtime Prolog code** that executes within SWI-Prolog. This contradicts UnifyWeaver's core philosophy: **transpilation**.

**Current Approach (Misaligned):**
```prolog
% This runs IN Prolog at runtime
partitioner_init(fixed_size(rows(100)), [], Handle),
partitioner_partition(Handle, Data, Partitions),
backend_execute(BHandle, Partitions, 'script.sh', Results).
```

**UnifyWeaver Philosophy (Transpilation):**
```prolog
% This should COMPILE to bash/PowerShell
process_data(Data, Results) :-
    partition_data(Data, fixed_size(rows(100)), Partitions),
    parallel_execute(Partitions, process/1, Results).
```

**The Question:** Should we:
1. Keep current approach (Prolog runtime orchestration)
2. Transpile to bash (full transpilation)
3. Hybrid: Transpile to Prolog (Prolog-as-target)
4. Something else?

---

## UnifyWeaver's Core Philosophy

### What UnifyWeaver Is

**Transpiler**: Prolog ‚Üí Target Language (bash/PowerShell/...)

**Goal**: Write declarative logic, generate efficient imperative code

**Rationale**:
- Leverage Prolog's expressiveness for *specification*
- Generate efficient code in languages that *execute everywhere*
- Bridge the gap: declarative input, imperative output

### What UnifyWeaver Is NOT

‚ùå **Not a Prolog runtime** - We don't want users to install SWI-Prolog to run generated code
‚ùå **Not a Prolog library** - We're not just writing reusable Prolog modules
‚ùå **Not a Prolog application** - The end goal is standalone bash/PowerShell scripts

### Current Misalignment

The partitioning/parallel system is **pure Prolog runtime**:
- Requires SWI-Prolog to execute
- Uses Prolog data structures (lists, terms)
- Calls Prolog predicates at runtime
- No transpilation involved

This is useful for **UnifyWeaver's internals** (the compiler itself), but not aligned with **user-facing features**.

---

## Three Architectural Options

### Option A: Full Bash Transpilation

**Approach**: Transpile partitioning/parallel predicates to bash

**Example:**
```prolog
% User writes:
process_csv(File, Results) :-
    read_csv(File, Data),
    partition_by_rows(Data, 100, Partitions),
    parallel_map(double/1, Partitions, Results).

% UnifyWeaver generates:
#!/bin/bash
# Read CSV
data=$(cat input.csv)

# Partition by rows (100 per partition)
# ... bash code to split data ...

# Parallel execution using GNU Parallel
parallel --jobs 4 'bash process.sh < {}' ::: batch_*.txt

# Collect results
cat output_*.txt
```

**Advantages:**
- ‚úÖ True to UnifyWeaver philosophy
- ‚úÖ Generated code is standalone (no Prolog dependency)
- ‚úÖ Users can inspect/modify generated bash
- ‚úÖ Runs everywhere bash runs

**Challenges:**
- ‚ùå Bash is poor at data structure manipulation (lists, partitioning logic)
- ‚ùå Complex to generate correct bash for partitioning algorithms
- ‚ùå May need external tools (awk, sed) for partitioning logic
- ‚ùå Hash partitioning, key-based grouping are non-trivial in bash

**Feasibility:** Medium-Hard
- Fixed-size partitioning: Doable (split by line count)
- Hash-based partitioning: Hard (need hash function in bash)
- Key-based partitioning: Very hard (need associative grouping)

---

### Option B: Hybrid - Prolog as Target Language

**Approach**: Transpile user code to Prolog, execute Prolog script

**Example:**
```prolog
% User writes:
process_csv(File, Results) :-
    read_csv(File, Data),
    partition_by_rows(Data, 100, Partitions),
    parallel_map(double/1, Partitions, Results).

% UnifyWeaver generates: process.pl
#!/usr/bin/env swipl
:- use_module(unifyweaver_runtime).

main :-
    read_csv('input.csv', Data),
    partition_by_rows(Data, 100, Partitions),
    parallel_map(double, Partitions, Results),
    write_results(Results).

:- initialization(main, main).

% Where unifyweaver_runtime.pl is our partitioner/parallel backend
```

**Advantages:**
- ‚úÖ Prolog excels at data structure manipulation
- ‚úÖ Partitioning algorithms are natural in Prolog
- ‚úÖ Can leverage existing partitioner/parallel code
- ‚úÖ Easier to implement than bash transpilation

**Challenges:**
- ‚ùå Requires SWI-Prolog on target system
- ‚ùå Not "true" transpilation (Prolog ‚Üí Prolog)
- ‚ùå Generated code harder for non-Prolog users to understand
- ‚ùå Adds deployment dependency

**Feasibility:** Easy
- We already have partitioner/parallel code
- Just need to copy/emit it in generated scripts

---

### Option C: Dual-Mode Architecture

**Approach**: Support both bash and Prolog as target languages

**User Specifies Target:**
```prolog
% Compile to bash (no Prolog dependency, limited features)
:- compile_target(bash).
process_csv(...) :- ...

% Compile to Prolog (full features, requires Prolog runtime)
:- compile_target(prolog).
process_csv(...) :- ...
```

**How It Works:**
1. **Simple predicates** ‚Üí Transpile to bash (existing behavior)
2. **Complex data operations** (partitioning, parallel) ‚Üí Options:
   - **bash target**: Transpile to bash + external tools (awk, GNU Parallel)
   - **prolog target**: Emit Prolog code, include runtime library

**Advantages:**
- ‚úÖ Flexibility: users choose based on deployment constraints
- ‚úÖ Simple cases don't need Prolog runtime
- ‚úÖ Complex cases leverage Prolog's strengths
- ‚úÖ Incremental: start with Prolog target, add bash later

**Challenges:**
- ‚ùå More complexity in compiler (two code generation paths)
- ‚ùå Feature parity: bash target may lack some features
- ‚ùå Documentation complexity (when to use which?)

**Feasibility:** Medium
- Prolog target: Easy (as Option B)
- Bash target: Hard (as Option A)
- Integration: Medium (dispatch based on target)

---

## Detailed Analysis: Prolog as Target

### What Does This Mean?

**Prolog as Compilation Target**: Generate standalone Prolog scripts that include:
1. **User's transpiled logic** (the predicate they defined)
2. **Runtime library** (partitioner, parallel backend, data sources)
3. **Initialization code** (entry point, argument parsing)

**NOT**: Run in interactive Prolog REPL
**YES**: Generate executable `.pl` script with `#!/usr/bin/env swipl`

### Code Generation Strategy

#### Strategy 1: Copy Verbatim (Simple Cases)

For predicates that don't need modification:

```prolog
% User writes:
helper(X, Y) :- Y is X * 2.

% UnifyWeaver generates (verbatim copy):
helper(X, Y) :- Y is X * 2.
```

**Implementation:**
```prolog
% Use Prolog's introspection
clause(helper(X, Y), Body),
portray_clause(Stream, (helper(X, Y) :- Body)).
```

#### Strategy 2: Template-Based (Configured Cases)

For predicates with configuration:

```prolog
% User writes:
process(Data, Results) :-
    partition_data(Data, fixed_size(rows(100)), Partitions),
    ...

% UnifyWeaver generates:
process(Data, Results) :-
    % Initialize partitioner with user's configuration
    partitioner_init(fixed_size(rows(100)), [], Handle),
    partitioner_partition(Handle, Data, Partitions),
    partitioner_cleanup(Handle),
    ...
```

**Implementation:**
```prolog
% Template with configuration substitution
generate_partition_call(Config, Code) :-
    Code = (
        partitioner_init(Config, [], Handle),
        partitioner_partition(Handle, Data, Partitions),
        partitioner_cleanup(Handle)
    ).
```

#### Strategy 3: Include Runtime Library

Generated script must include dependencies:

```prolog
% Generated script.pl structure:

#!/usr/bin/env swipl

% Runtime library (option 1: inline)
% [Full partitioner.pl code inlined here]

% Runtime library (option 2: reference)
:- use_module('/path/to/unifyweaver/runtime/partitioner').

% User code (transpiled)
process(Data, Results) :- ...

% Entry point
main :-
    process(input, Results),
    write_output(Results).

:- initialization(main, main).
```

**Trade-offs:**

| Approach | Pros | Cons |
|----------|------|------|
| **Inline** | Standalone script, no dependencies | Large file, version management |
| **Reference** | Small script, updates easier | Requires UnifyWeaver installed |
| **Hybrid** | Core inlined, optional modules reference | Complexity |

**Recommendation:** Start with **reference**, add **inline** option later.

### Module Search Path Management

**Problem**: Generated script needs to find runtime modules.

**Solutions:**

1. **Environment Variable**
   ```bash
   export UNIFYWEAVER_HOME=/usr/local/lib/unifyweaver
   swipl script.pl
   ```

2. **Embed Search Path in Script**
   ```prolog
   :- prolog_load_context(directory, Dir),
      asserta(file_search_path(unifyweaver, '/usr/local/lib/unifyweaver')).
   :- use_module(unifyweaver(core/partitioner)).
   ```

3. **Install as SWI-Prolog Pack**
   ```bash
   swipl-pack install unifyweaver
   ```
   ```prolog
   :- use_module(library(unifyweaver/partitioner)).
   ```

**Recommendation:** Support all three, default to **Pack** for released version.

---

## Configuration Handling

### User-Specified Configuration

```prolog
% User specifies partitioning strategy
process(File, Results) :-
    partition_data(File, fixed_size(rows(100)), Partitions),
    ...
```

### Template-Based Generation

```prolog
% Compiler generates:
process(File, Results) :-
    % Extract configuration from user's call
    Config = fixed_size(rows(100)),

    % Generate initialization code
    partitioner_init(Config, [], Handle),
    partitioner_partition(Handle, FileData, Partitions),
    partitioner_cleanup(Handle),
    ...
```

### Configuration Layers (Like Firewall)

Support global, predicate-level, and call-level configuration:

```prolog
% Global default
:- set_default_partitioner(fixed_size(rows(100))).

% Predicate-level override
:- partitioner_config(process/2, hash_based(key(column(1)))).

% Call-level override (most specific)
process(File, Results) :-
    partition_data(File, fixed_size(rows(50)), Partitions),  % Explicit
    ...
```

---

## Import Management

### Minimal Imports (User Code)

Generated script should only import what's needed:

```prolog
% If user uses partitioner
:- use_module(unifyweaver(core/partitioner)).

% If user uses parallel backend
:- use_module(unifyweaver(core/parallel_backend)).

% If user uses specific backend
:- ensure_loaded(unifyweaver(core/backends/gnu_parallel)).
```

### Dependency Analysis

```prolog
% Analyze user code to determine imports
analyze_dependencies(UserPredicates, RequiredModules) :-
    findall(Module, (
        member(Pred, UserPredicates),
        uses_feature(Pred, Feature),
        feature_requires_module(Feature, Module)
    ), RequiredModules).

% Example rules:
uses_feature(Pred, partitioning) :-
    clause(Pred, Body),
    contains_goal(Body, partition_data(_, _, _)).

feature_requires_module(partitioning, 'unifyweaver(core/partitioner)').
```

---

## Example: End-to-End Flow

### User Code

```prolog
% user_pipeline.pl

process_logs(LogFile, Aggregated) :-
    read_csv(LogFile, Logs),
    partition_by_key(Logs, column(1), Partitions),
    parallel_map(count_errors/1, Partitions, Results),
    aggregate_results(Results, Aggregated).
```

### Generated Script (Prolog Target)

```prolog
#!/usr/bin/env swipl
% Generated by UnifyWeaver v0.0.2
% Target: Prolog
% Source: user_pipeline.pl

% Set up module search path
:- getenv('UNIFYWEAVER_HOME', Home),
   asserta(file_search_path(unifyweaver, Home)).

% Import runtime dependencies
:- use_module(unifyweaver(core/partitioner)).
:- use_module(unifyweaver(core/parallel_backend)).
:- use_module(unifyweaver(sources/csv)).
:- ensure_loaded(unifyweaver(core/partitioners/key_based)).
:- ensure_loaded(unifyweaver(core/backends/gnu_parallel)).

% Register plugins
:- register_partitioner(key_based, key_based_partitioner).
:- register_backend(gnu_parallel, gnu_parallel_backend).

% User code (transpiled/copied)
process_logs(LogFile, Aggregated) :-
    % Data source
    read_csv(LogFile, Logs),

    % Partitioning
    partitioner_init(key_based(key(column(1))), [], PHandle),
    partitioner_partition(PHandle, Logs, Partitions),
    partitioner_cleanup(PHandle),

    % Parallel execution
    backend_init(gnu_parallel(workers(4)), BHandle),
    backend_execute(BHandle, Partitions, count_errors_script, Results),
    backend_cleanup(BHandle),

    % Aggregation
    aggregate_results(Results, Aggregated).

% Helper predicates (user-defined, copied verbatim)
count_errors(Partition, Count) :- ...
aggregate_results(Results, Agg) :- ...

% Entry point
main :-
    current_prolog_flag(argv, Argv),
    (   Argv = [LogFile]
    ->  process_logs(LogFile, Results),
        write_results(Results)
    ;   writeln('Usage: user_pipeline.pl <log_file>'),
        halt(1)
    ).

:- initialization(main, main).
```

### Execution

```bash
$ chmod +x user_pipeline.pl
$ ./user_pipeline.pl logs.csv
# Partitioning by key...
# Executing in parallel...
# Results:
error: 42
warning: 15
info: 123
```

---

## Implementation Plan

### Phase 1: Prolog Target Foundation (4-6 hours)

**Goal**: Generate basic Prolog scripts with runtime library references

**Tasks:**
1. Create `src/unifyweaver/targets/prolog_target.pl` module
2. Implement `generate_prolog_script/3` (User code ‚Üí Script)
3. Implement module dependency analysis
4. Implement search path setup code generation
5. Test: Generate script for simple predicate

**Deliverable**: Can generate standalone Prolog script that runs

---

### Phase 2: Configuration Substitution (3-4 hours)

**Goal**: Handle user configuration options (partitioner config, backend workers, etc.)

**Tasks:**
1. Parse configuration from user predicates
2. Generate initialization code with config
3. Support configuration layers (global, predicate, call)
4. Test: Generate script with various configurations

**Deliverable**: Generated scripts respect user configuration

---

### Phase 3: Code Copying vs Templates (4-5 hours)

**Goal**: Decide when to copy verbatim vs use templates

**Tasks:**
1. Implement verbatim copying for simple predicates
2. Implement template-based generation for complex cases
3. Add clause introspection for copying predicates
4. Handle module qualifications in copied code
5. Test: Mixed user code (simple + complex)

**Deliverable**: Smart code generation (copy when possible, template when needed)

---

### Phase 4: Runtime Library Packaging (3-4 hours)

**Goal**: Make runtime library easily accessible

**Tasks:**
1. Create `runtime/` directory structure
2. Organize modules: partitioner, parallel_backend, strategies, backends
3. Create SWI-Prolog pack metadata
4. Test installation as pack: `swipl-pack install unifyweaver`
5. Document search path setup for development

**Deliverable**: Runtime library installable as SWI-Prolog pack

---

### Phase 5: Integration with Existing Compiler (4-5 hours)

**Goal**: Add Prolog target to compilation pipeline

**Tasks:**
1. Add `target(prolog)` configuration option
2. Modify compilation dispatch to call Prolog target generator
3. Integrate with existing bash target (dual-mode)
4. Add command-line flag: `--target prolog`
5. Update tests to verify Prolog target

**Deliverable**: Users can compile with `--target prolog`

---

### Phase 6: Testing & Documentation (3-4 hours)

**Tasks:**
1. Create test suite for Prolog target generation
2. Test end-to-end: user code ‚Üí generated script ‚Üí execution
3. Write documentation: "Prolog as Target Language"
4. Update examples to show both bash and Prolog targets
5. Performance comparison: bash vs Prolog target

**Deliverable**: Tested, documented Prolog target

---

**Total Estimated Effort:** 21-28 hours

---

## Decision: Recommended Approach

### Short Term (v0.0.3): Prolog as Target (Option B/C)

**Rationale:**
1. **Pragmatic**: Leverages existing partitioner/parallel code
2. **Fast**: Can implement in ~25 hours vs months for bash
3. **Powerful**: Prolog excels at data structure manipulation
4. **Incremental**: Can add bash target later if needed

**Trade-off:** Requires SWI-Prolog on target system

**Mitigation:** Document clearly, provide installation instructions

### Long Term (v0.1.0+): Bash Transpilation (Option A/C)

**Goal**: True transpilation to bash for zero-dependency scripts

**Approach:**
- Start with simple cases (fixed-size partitioning)
- Use external tools (awk for hash functions, GNU Parallel for execution)
- Gradually expand coverage

**Not a Priority**: Most users who need partitioning/parallel likely already have Prolog

---

## Open Questions

1. **Should we inline runtime library or reference it?**
   - **Recommendation**: Reference by default, add `--inline` flag for standalone scripts

2. **How to handle versioning of runtime library?**
   - **Recommendation**: Include version in generated script comments, check at runtime

3. **Should generated scripts be human-readable or optimized?**
   - **Recommendation**: Readable by default, add `--optimize` flag later

4. **How to handle errors in generated scripts?**
   - **Recommendation**: Include error handling, trace to original source line

5. **Should we support other Prolog systems (GNU Prolog, SICStus)?**
   - **Recommendation**: SWI-Prolog only for v0.0.3, consider others later

---

## Related Work

**Prolog to X Compilers:**
- **SWI-Prolog QPCompile**: Prolog ‚Üí Native code (in-memory)
- **GNU Prolog**: Prolog ‚Üí C ‚Üí Native executable
- **Mercury**: Prolog-like ‚Üí Multiple targets (C, Java, C#)

**UnifyWeaver's Niche:**
- Prolog ‚Üí Bash/PowerShell (shell scripting)
- Prolog ‚Üí Prolog (with runtime library for complex features)
- Focus on data processing pipelines, not general computation

---

## Summary

**Current Situation**: Partitioning/parallel system is Prolog runtime, not transpiled

**Recommendation**: Implement **Prolog as Target Language**

**Benefits:**
- ‚úÖ Fast to implement (~25 hours)
- ‚úÖ Leverages Prolog's strengths
- ‚úÖ Enables complex data operations
- ‚úÖ Maintains transpilation philosophy (Prolog ‚Üí executable script)

**Trade-offs:**
- ‚ùå Requires SWI-Prolog on target system
- ‚ùå Generated scripts less portable than bash

**Next Steps:**
1. Implement Prolog target generator (Phase 1-3)
2. Package runtime library as SWI-Prolog pack (Phase 4)
3. Integrate with compiler (Phase 5)
4. Test and document (Phase 6)
5. **Future**: Add bash target for simple partitioning cases

**Decision Required**: Approve Prolog as target approach?

---

**Related Documents:**
- `docs/proposals/partitioning_strategies.md` - Partitioning design
- `docs/proposals/parallel_backend_implementation_plan.md` - Backend comparison
- `education/13_partitioning_and_parallel_execution.md` - User-facing guide

**Version:** 1.0
**Last Updated:** 2025-10-27
