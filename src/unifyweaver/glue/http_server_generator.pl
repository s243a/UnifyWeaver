:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025-2026 John William Creighton (@s243a)
%
% http_server_generator.pl - Generate HTTP/HTTPS servers from declarative specs
%
% Generates complete HTTP server implementations including:
% - HTTP/HTTPS server setup
% - Endpoint routing
% - WebSocket handling
% - CORS configuration
% - Integration with auth module
%
% Usage:
%   :- use_module(http_server_generator).
%   :- use_module('../sources/service_source').
%
%   % Get predefined template or build custom spec
%   service_template(http_cli, ServiceSpec),
%
%   % Generate TypeScript server
%   generate_http_server(ServiceSpec, typescript, Code).

:- module(http_server_generator, [
    % Main generation entry points
    generate_http_server/3,             % +ServiceSpec, +Target, -Code
    generate_complete_server/4,         % +ServiceSpec, +AuthSpec, +Target, -Files

    % Section generators
    generate_server_imports/3,          % +ServiceSpec, +Target, -Code
    generate_server_config/3,           % +ServiceSpec, +Target, -Code
    generate_endpoint_handlers/3,       % +ServiceSpec, +Target, -Code
    generate_request_router/3,          % +ServiceSpec, +Target, -Code
    generate_websocket_handler/3,       % +ServiceSpec, +Target, -Code
    generate_server_setup/3,            % +ServiceSpec, +Target, -Code
    generate_cli_parser/3               % +ServiceSpec, +Target, -Code
]).

:- use_module(library(lists)).
:- use_module('../sources/service_source').

%% ============================================================================
%% MAIN GENERATION ENTRY POINTS
%% ============================================================================

%! generate_http_server(+ServiceSpec, +Target, -Code) is det
%
%  Generate complete HTTP server code for the specified target.
%
%  Targets: typescript, python, go
%
generate_http_server(ServiceSpec, typescript, Code) :-
    % Generate each section
    generate_server_imports(ServiceSpec, typescript, ImportsCode),
    generate_server_config(ServiceSpec, typescript, ConfigCode),
    generate_ts_types_section(TypesCode),
    generate_endpoint_handlers(ServiceSpec, typescript, HandlersCode),
    generate_request_router(ServiceSpec, typescript, RouterCode),
    generate_websocket_handler(ServiceSpec, typescript, WSCode),
    generate_server_setup(ServiceSpec, typescript, SetupCode),
    generate_cli_parser(ServiceSpec, typescript, CLICode),

    service_name(ServiceSpec, Name),

    % Combine all sections
    atomic_list_concat([
        '#!/usr/bin/env ts-node\n',
        '/**\n',
        ' * ', Name, ' - HTTP/HTTPS Server\n',
        ' * Generated by UnifyWeaver http_server_generator.pl\n',
        ' * DO NOT EDIT - regenerate from spec\n',
        ' */\n\n',
        ImportsCode, '\n\n',
        ConfigCode, '\n\n',
        TypesCode, '\n\n',
        HandlersCode, '\n\n',
        RouterCode, '\n\n',
        WSCode, '\n\n',
        SetupCode, '\n\n',
        CLICode, '\n\n',
        'main();\n'
    ], Code).

generate_http_server(ServiceSpec, python, Code) :-
    service_name(ServiceSpec, Name),
    format(atom(Code), '# Python HTTP server: ~w\n# Not yet implemented', [Name]).

generate_http_server(ServiceSpec, go, Code) :-
    service_name(ServiceSpec, Name),
    format(atom(Code), '// Go HTTP server: ~w\n// Not yet implemented', [Name]).

%! generate_complete_server(+ServiceSpec, +AuthSpec, +Target, -Files) is det
%
%  Generate complete server with auth module as separate files.
%
generate_complete_server(ServiceSpec, AuthSpec, Target, Files) :-
    generate_http_server(ServiceSpec, Target, ServerCode),
    % Auth generator would be called here
    % For now, just return server code
    Files = [
        file('server.ts', ServerCode)
        % file('auth.ts', AuthCode) - when auth_generator is integrated
    ].

%% ============================================================================
%% IMPORTS GENERATION
%% ============================================================================

%! generate_server_imports(+ServiceSpec, +Target, -Code) is det
generate_server_imports(ServiceSpec, typescript, Code) :-
    service_https(ServiceSpec, HTTPSConfig),
    service_websocket(ServiceSpec, WSConfig),

    % Base imports
    BaseImports = 'import * as http from \'http\';\nimport * as url from \'url\';\nimport * as path from \'path\';\nimport * as fs from \'fs\';',

    % HTTPS import if needed
    (   https_enabled(HTTPSConfig)
    ->  HTTPSImport = 'import * as https from \'https\';'
    ;   HTTPSImport = ''
    ),

    % WebSocket import if needed
    (   WSConfig \= none
    ->  WSImport = 'import WebSocket, { WebSocketServer } from \'ws\';'
    ;   WSImport = ''
    ),

    % Auth import
    AuthImport = 'import {\n  login,\n  verifyToken,\n  getUserFromToken,\n  hasRole,\n  TokenPayload\n} from \'./auth\';',

    atomic_list_concat([BaseImports, HTTPSImport, WSImport, AuthImport], '\n', Code).

%% ============================================================================
%% CONFIG GENERATION
%% ============================================================================

%! generate_server_config(+ServiceSpec, +Target, -Code) is det
generate_server_config(ServiceSpec, typescript, Code) :-
    service_port(ServiceSpec, Port),
    service_cors(ServiceSpec, CORSConfig),

    % Extract CORS origins
    (   member(origins(Origins), CORSConfig)
    ->  origins_to_ts_array(Origins, OriginsArray)
    ;   OriginsArray = '[\'*\']'
    ),

    format(atom(Code), '// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_PORT = ~w;
const MAX_BODY_SIZE = 1024 * 1024; // 1MB
const ALLOWED_ORIGINS = ~w;

// Authentication: set AUTH_REQUIRED=true to require login
const AUTH_REQUIRED = process.env.AUTH_REQUIRED === \'true\';', [Port, OriginsArray]).

origins_to_ts_array(Origins, Array) :-
    maplist(origin_to_string, Origins, Strings),
    atomic_list_concat(Strings, ', ', StringsJoined),
    format(atom(Array), '[~w]', [StringsJoined]).

origin_to_string(Origin, String) :-
    format(atom(String), '\'~w\'', [Origin]).

%% ============================================================================
%% TYPES GENERATION
%% ============================================================================

generate_ts_types_section(Code) :-
    Code = '// ============================================================================
// Types
// ============================================================================

interface APIResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

interface RequestBody {
  [key: string]: unknown;
}'.

%% ============================================================================
%% ENDPOINT HANDLERS GENERATION
%% ============================================================================

%! generate_endpoint_handlers(+ServiceSpec, +Target, -Code) is det
generate_endpoint_handlers(ServiceSpec, typescript, Code) :-
    service_endpoints(ServiceSpec, Endpoints),
    maplist(generate_ts_endpoint_handler, Endpoints, HandlerCodes),
    atomic_list_concat(HandlerCodes, '\n\n', Code).

generate_ts_endpoint_handler(Endpoint, Code) :-
    endpoint_name(Endpoint, Name),
    endpoint_method(Endpoint, Method),
    endpoint_path(Endpoint, Path),
    endpoint_roles(Endpoint, Roles),
    endpoint_public(Endpoint, IsPublic),

    % Generate role check if not public
    (   IsPublic == true
    ->  RoleCheck = '  // Public endpoint - no auth required'
    ;   Roles == []
    ->  RoleCheck = '  // Requires authentication\n  if (AUTH_REQUIRED && !user) {\n    return sendJSON(res, 401, { success: false, error: \'Authentication required\' });\n  }'
    ;   roles_to_ts_array_simple(Roles, RolesArray),
        format(atom(RoleCheck), '  // Requires roles: ~w\n  if (AUTH_REQUIRED) {\n    if (!user) return sendJSON(res, 401, { success: false, error: \'Authentication required\' });\n    const hasRequiredRole = ~w.some(r => user.roles.includes(r));\n    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: \'Insufficient permissions\' });\n  }', [Roles, RolesArray])
    ),

    upcase_atom(Method, MethodUpper),
    format(atom(Code), '/**
 * ~w ~w - ~w endpoint
 */
async function handle_~w(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
~w

  // TODO: Implement ~w logic
  sendJSON(res, 200, { success: true, data: { endpoint: \'~w\' } });
}', [MethodUpper, Path, Name, Name, RoleCheck, Name, Name]).

roles_to_ts_array_simple(Roles, Array) :-
    maplist(role_to_string, Roles, Strings),
    atomic_list_concat(Strings, ', ', StringsJoined),
    format(atom(Array), '[~w]', [StringsJoined]).

role_to_string(Role, String) :-
    format(atom(String), '\'~w\'', [Role]).

%% ============================================================================
%% REQUEST ROUTER GENERATION
%% ============================================================================

%! generate_request_router(+ServiceSpec, +Target, -Code) is det
generate_request_router(ServiceSpec, typescript, Code) :-
    service_endpoints(ServiceSpec, Endpoints),
    generate_ts_route_cases(Endpoints, RouteCases),

    format(atom(Code), '// ============================================================================
// Request Router
// ============================================================================

function sendJSON(res: http.ServerResponse, status: number, data: APIResponse): void {
  res.writeHead(status, {
    \'Content-Type\': \'application/json\',
    \'Access-Control-Allow-Origin\': \'*\',
    \'Access-Control-Allow-Methods\': \'GET, POST, PUT, DELETE, OPTIONS\',
    \'Access-Control-Allow-Headers\': \'Content-Type, Authorization\'
  });
  res.end(JSON.stringify(data));
}

async function parseBody(req: http.IncomingMessage): Promise<RequestBody> {
  return new Promise((resolve, reject) => {
    let body = \'\';
    req.on(\'data\', chunk => {
      body += chunk;
      if (body.length > MAX_BODY_SIZE) {
        reject(new Error(\'Body too large\'));
      }
    });
    req.on(\'end\', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch {
        resolve({});
      }
    });
    req.on(\'error\', reject);
  });
}

function extractToken(req: http.IncomingMessage): string | null {
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith(\'Bearer \')) {
    return authHeader.substring(7);
  }
  return null;
}

async function handleRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): Promise<void> {
  // Handle CORS preflight
  if (req.method === \'OPTIONS\') {
    res.writeHead(204, {
      \'Access-Control-Allow-Origin\': \'*\',
      \'Access-Control-Allow-Methods\': \'GET, POST, PUT, DELETE, OPTIONS\',
      \'Access-Control-Allow-Headers\': \'Content-Type, Authorization\'
    });
    res.end();
    return;
  }

  const parsedUrl = url.parse(req.url || \'\', true);
  const pathname = parsedUrl.pathname || \'/\';
  const method = req.method || \'GET\';

  // Extract and verify token
  const token = extractToken(req);
  const user = token ? verifyToken(token) : null;

  try {
    const body = await parseBody(req);

    // Route to handlers
~w

    // Not found
    sendJSON(res, 404, { success: false, error: \'Not found\' });
  } catch (err) {
    console.error(\'Request error:\', err);
    sendJSON(res, 500, { success: false, error: \'Internal server error\' });
  }
}', [RouteCases]).

generate_ts_route_cases(Endpoints, Code) :-
    maplist(generate_ts_route_case, Endpoints, Cases),
    atomic_list_concat(Cases, '\n', Code).

generate_ts_route_case(Endpoint, Code) :-
    endpoint_name(Endpoint, Name),
    endpoint_method(Endpoint, Method),
    endpoint_path(Endpoint, Path),
    upcase_atom(Method, MethodUpper),
    format(atom(Code), '    if (method === \'~w\' && pathname === \'~w\') {\n      return handle_~w(req, res, body, user);\n    }', [MethodUpper, Path, Name]).

%% ============================================================================
%% WEBSOCKET HANDLER GENERATION
%% ============================================================================

%! generate_websocket_handler(+ServiceSpec, +Target, -Code) is det
generate_websocket_handler(ServiceSpec, typescript, Code) :-
    service_websocket(ServiceSpec, WSConfig),
    (   WSConfig == none
    ->  Code = '// No WebSocket configured'
    ;   websocket_path(WSConfig, WSPath),
        websocket_roles(WSConfig, WSRoles),
        roles_to_ts_array_simple(WSRoles, RolesArray),
        format(atom(Code), '// ============================================================================
// WebSocket Handler
// ============================================================================

function setupWebSocket(server: http.Server | https.Server): void {
  const wss = new WebSocketServer({ server });

  wss.on(\'connection\', (ws: WebSocket, req: http.IncomingMessage) => {
    const parsedUrl = url.parse(req.url || \'\', true);
    const token = parsedUrl.query.token as string;

    if (!token) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Authentication required\' }));
      ws.close(1008, \'Authentication required\');
      return;
    }

    const payload = verifyToken(token);
    if (!payload) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Invalid token\' }));
      ws.close(1008, \'Invalid token\');
      return;
    }

    // Check for required roles
    const requiredRoles = ~w;
    const hasRole = requiredRoles.length === 0 || requiredRoles.some(r => payload.roles.includes(r));
    if (!hasRole) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Insufficient permissions\' }));
      ws.close(1008, \'Access denied\');
      return;
    }

    console.log(`WebSocket connection from ${payload.email}`);
    handleWebSocketConnection(ws, payload);
  });
}

function handleWebSocketConnection(ws: WebSocket, user: TokenPayload): void {
  ws.send(JSON.stringify({ type: \'connected\', user: user.email }));

  ws.on(\'message\', (data: Buffer) => {
    try {
      const msg = JSON.parse(data.toString());
      // Handle WebSocket messages
      ws.send(JSON.stringify({ type: \'echo\', data: msg }));
    } catch (err) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Invalid message format\' }));
    }
  });

  ws.on(\'close\', () => {
    console.log(`WebSocket disconnected: ${user.email}`);
  });
}', [RolesArray])
    ).

%% ============================================================================
%% SERVER SETUP GENERATION
%% ============================================================================

%! generate_server_setup(+ServiceSpec, +Target, -Code) is det
generate_server_setup(ServiceSpec, typescript, Code) :-
    service_https(ServiceSpec, HTTPSConfig),
    service_websocket(ServiceSpec, WSConfig),
    service_port(ServiceSpec, DefaultPort),

    % WebSocket setup call
    (   WSConfig \= none
    ->  WSSetup = '  setupWebSocket(server);'
    ;   WSSetup = '  // No WebSocket configured'
    ),

    format(atom(Code), '// ============================================================================
// Server Setup
// ============================================================================

interface SSLOptions {
  cert?: string;
  key?: string;
}

function startServer(port: number, ssl?: SSLOptions): void {
  let server: http.Server | https.Server;
  let protocol: string;

  if (ssl?.cert && ssl?.key) {
    // HTTPS mode
    try {
      const sslOptions = {
        cert: fs.readFileSync(ssl.cert),
        key: fs.readFileSync(ssl.key)
      };
      server = https.createServer(sslOptions, handleRequest);
      protocol = \'https\';
    } catch (err) {
      console.error(`Failed to load SSL certificates: ${err}`);
      process.exit(1);
    }
  } else {
    // HTTP mode
    server = http.createServer(handleRequest);
    protocol = \'http\';
  }

~w

  server.listen(port, () => {
    const wsProtocol = protocol === \'https\' ? \'wss\' : \'ws\';
    console.log(`Server running at ${protocol}://localhost:${port}`);
    console.log(`SSL/TLS: ${protocol === \'https\' ? \'ENABLED\' : \'disabled\'}`);
    console.log(`Auth: ${AUTH_REQUIRED ? \'ENABLED\' : \'disabled\'}`);
  });

  server.on(\'error\', (err: NodeJS.ErrnoException) => {
    if (err.code === \'EADDRINUSE\') {
      console.error(`Port ${port} is already in use`);
    } else {
      console.error(\'Server error:\', err);
    }
    process.exit(1);
  });
}', [WSSetup]).

%% ============================================================================
%% CLI PARSER GENERATION
%% ============================================================================

%! generate_cli_parser(+ServiceSpec, +Target, -Code) is det
generate_cli_parser(ServiceSpec, typescript, Code) :-
    service_port(ServiceSpec, DefaultPort),
    service_name(ServiceSpec, Name),

    format(atom(Code), '// ============================================================================
// CLI Entry
// ============================================================================

function main(): void {
  const args = process.argv.slice(2);
  let port = ~w;
  let certPath: string | undefined;
  let keyPath: string | undefined;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case \'--port\':
        port = parseInt(args[++i], 10);
        if (isNaN(port)) {
          console.error(\'Invalid port number\');
          process.exit(1);
        }
        break;
      case \'--cert\':
        certPath = args[++i];
        break;
      case \'--key\':
        keyPath = args[++i];
        break;
      case \'--help\':
      case \'-h\':
        console.log(`
~w - Generated by UnifyWeaver

Usage:
  ts-node server.ts [options]

Options:
  --port <number>   Port to listen on (default: ~w)
  --cert <path>     Path to SSL certificate (enables HTTPS)
  --key <path>      Path to SSL private key (enables HTTPS)
  --help, -h        Show this help

Environment:
  AUTH_REQUIRED     Set to \'true\' to require authentication
`);
        process.exit(0);
    }
  }

  // Validate SSL options
  if ((certPath && !keyPath) || (!certPath && keyPath)) {
    console.error(\'Both --cert and --key are required for HTTPS\');
    process.exit(1);
  }

  const ssl = certPath && keyPath ? { cert: certPath, key: keyPath } : undefined;
  startServer(port, ssl);
}', [DefaultPort, Name, DefaultPort]).

%% ============================================================================
%% HELPER PREDICATES
%% ============================================================================

%! upcase_atom(+LowerAtom, -UpperAtom) is det
%
%  Convert atom to uppercase.
%
upcase_atom(Lower, Upper) :-
    atom_codes(Lower, Codes),
    maplist(upcase_code, Codes, UpperCodes),
    atom_codes(Upper, UpperCodes).

upcase_code(C, U) :-
    (   C >= 0'a, C =< 0'z
    ->  U is C - 32
    ;   U = C
    ).
