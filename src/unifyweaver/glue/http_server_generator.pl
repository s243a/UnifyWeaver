:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025-2026 John William Creighton (@s243a)
%
% http_server_generator.pl - Generate HTTP/HTTPS servers from declarative specs
%
% Generates complete HTTP server implementations including:
% - HTTP/HTTPS server setup
% - Endpoint routing
% - WebSocket handling
% - CORS configuration
% - Integration with auth module
%
% Usage:
%   :- use_module(http_server_generator).
%   :- use_module('../sources/service_source').
%
%   % Get predefined template or build custom spec
%   service_template(http_cli, ServiceSpec),
%
%   % Generate TypeScript server
%   generate_http_server(ServiceSpec, typescript, Code).

:- module(http_server_generator, [
    % Main generation entry points
    generate_http_server/3,             % +ServiceSpec, +Target, -Code
    generate_complete_server/4,         % +ServiceSpec, +AuthSpec, +Target, -Files

    % Section generators
    generate_server_imports/3,          % +ServiceSpec, +Target, -Code
    generate_server_config/3,           % +ServiceSpec, +Target, -Code
    generate_endpoint_handlers/3,       % +ServiceSpec, +Target, -Code
    generate_request_router/3,          % +ServiceSpec, +Target, -Code
    generate_websocket_handler/3,       % +ServiceSpec, +Target, -Code
    generate_server_setup/3,            % +ServiceSpec, +Target, -Code
    generate_cli_parser/3,              % +ServiceSpec, +Target, -Code
    generate_html_interface_function/3  % +ServiceSpec, +Target, -Code
]).

:- use_module(library(lists)).
:- use_module('../sources/service_source').
% Note: server_components.pl provides reusable component generators
% but endpoint logic is implemented directly here for simplicity.

% Load UI generators (optional - for HTML interface generation)
:- catch(use_module('../ui/html_interface_generator'), _, true).
:- catch(use_module('../ui/http_cli_ui'), _, true).

%% ============================================================================
%% MAIN GENERATION ENTRY POINTS
%% ============================================================================

%! generate_http_server(+ServiceSpec, +Target, -Code) is det
%
%  Generate complete HTTP server code for the specified target.
%
%  Targets: typescript, python, go
%
generate_http_server(ServiceSpec, typescript, Code) :-
    % Generate each section
    generate_server_imports(ServiceSpec, typescript, ImportsCode),
    generate_server_config(ServiceSpec, typescript, ConfigCode),
    generate_ts_types_section(TypesCode),
    generate_endpoint_handlers(ServiceSpec, typescript, HandlersCode),
    generate_request_router(ServiceSpec, typescript, RouterCode),
    generate_websocket_handler(ServiceSpec, typescript, WSCode),
    generate_server_setup(ServiceSpec, typescript, SetupCode),
    generate_cli_parser(ServiceSpec, typescript, CLICode),

    % Generate HTML interface if serve_html(true) is set
    (   service_serve_html(ServiceSpec, true)
    ->  generate_html_interface_function(ServiceSpec, typescript, HTMLCode)
    ;   HTMLCode = ''
    ),

    service_name(ServiceSpec, Name),

    % Combine all sections
    atomic_list_concat([
        '#!/usr/bin/env ts-node\n',
        '/**\n',
        ' * ', Name, ' - HTTP/HTTPS Server\n',
        ' * Generated by UnifyWeaver http_server_generator.pl\n',
        ' * DO NOT EDIT - regenerate from spec\n',
        ' */\n\n',
        ImportsCode, '\n\n',
        ConfigCode, '\n\n',
        TypesCode, '\n\n',
        HandlersCode, '\n\n',
        HTMLCode, '\n\n',
        RouterCode, '\n\n',
        WSCode, '\n\n',
        SetupCode, '\n\n',
        CLICode, '\n\n',
        'main();\n'
    ], Code).

generate_http_server(ServiceSpec, python, Code) :-
    service_name(ServiceSpec, Name),
    format(atom(Code), '# Python HTTP server: ~w\n# Not yet implemented', [Name]).

generate_http_server(ServiceSpec, go, Code) :-
    service_name(ServiceSpec, Name),
    format(atom(Code), '// Go HTTP server: ~w\n// Not yet implemented', [Name]).

%! generate_complete_server(+ServiceSpec, +AuthSpec, +Target, -Files) is det
%
%  Generate complete server with auth module as separate files.
%
generate_complete_server(ServiceSpec, AuthSpec, Target, Files) :-
    generate_http_server(ServiceSpec, Target, ServerCode),
    % Auth generator would be called here
    % For now, just return server code
    Files = [
        file('server.ts', ServerCode)
        % file('auth.ts', AuthCode) - when auth_generator is integrated
    ].

%% ============================================================================
%% IMPORTS GENERATION
%% ============================================================================

%! generate_server_imports(+ServiceSpec, +Target, -Code) is det
generate_server_imports(ServiceSpec, typescript, Code) :-
    service_https(ServiceSpec, HTTPSConfig),
    service_websocket(ServiceSpec, WSConfig),

    % Base imports
    BaseImports = 'import * as http from \'http\';\nimport * as url from \'url\';\nimport * as path from \'path\';\nimport * as fs from \'fs\';\nimport { execSync, spawn, ChildProcessWithoutNullStreams } from \'child_process\';',

    % HTTPS import if needed
    (   https_enabled(HTTPSConfig)
    ->  HTTPSImport = 'import * as https from \'https\';'
    ;   HTTPSImport = ''
    ),

    % WebSocket import if needed
    (   WSConfig \= none
    ->  WSImport = 'import WebSocket, { WebSocketServer } from \'ws\';'
    ;   WSImport = ''
    ),

    % Auth import
    AuthImport = 'import {\n  login,\n  verifyToken,\n  getUserFromToken,\n  hasRole,\n  TokenPayload,\n  Role\n} from \'./auth\';',

    % Command proxy import
    CmdProxyImport = 'import {\n  execute,\n  validateCommand,\n  listCommands,\n  Risk,\n  SANDBOX_ROOT\n} from \'./command-proxy\';',

    atomic_list_concat([BaseImports, HTTPSImport, WSImport, AuthImport, CmdProxyImport], '\n', Code).

%% ============================================================================
%% CONFIG GENERATION
%% ============================================================================

%! generate_server_config(+ServiceSpec, +Target, -Code) is det
generate_server_config(ServiceSpec, typescript, Code) :-
    service_port(ServiceSpec, Port),
    service_cors(ServiceSpec, CORSConfig),

    % Extract CORS origins
    (   member(origins(Origins), CORSConfig)
    ->  origins_to_ts_array(Origins, OriginsArray)
    ;   OriginsArray = '[\'*\']'
    ),

    format(atom(Code), '// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_PORT = ~w;
const MAX_BODY_SIZE = 1024 * 1024; // 1MB
const ALLOWED_ORIGINS = ~w;

// Authentication: set AUTH_REQUIRED=true to require login
const AUTH_REQUIRED = process.env.AUTH_REQUIRED === \'true\';

// Commands allowed for search operations
const SEARCH_COMMANDS = [\'grep\', \'find\', \'cat\', \'head\', \'tail\', \'ls\', \'wc\', \'pwd\'];

// Feedback log file
const FEEDBACK_FILE = process.env.FEEDBACK_FILE || path.join(SANDBOX_ROOT, \'comet-feedback.log\');', [Port, OriginsArray]).

origins_to_ts_array(Origins, Array) :-
    maplist(origin_to_string, Origins, Strings),
    atomic_list_concat(Strings, ', ', StringsJoined),
    format(atom(Array), '[~w]', [StringsJoined]).

origin_to_string(Origin, String) :-
    format(atom(String), '''~w''', [Origin]).

%% ============================================================================
%% TYPES GENERATION
%% ============================================================================

generate_ts_types_section(Code) :-
    Code = '// ============================================================================
// Types
// ============================================================================

interface APIResponse {
  success: boolean;
  data?: unknown;
  error?: string;
  warning?: string;
}

interface RequestBody {
  [key: string]: unknown;
}

interface FileEntry {
  name: string;
  type: \'file\' | \'directory\';
  size?: number;
  modified?: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

function resolveWorkingDir(cwd?: string): string {
  if (!cwd || cwd === \'.\') return SANDBOX_ROOT;
  const resolved = path.resolve(SANDBOX_ROOT, cwd);
  if (!resolved.startsWith(SANDBOX_ROOT)) return SANDBOX_ROOT;
  if (!fs.existsSync(resolved) || !fs.statSync(resolved).isDirectory()) return SANDBOX_ROOT;
  return resolved;
}

function expandGlobs(args: string[], cwd: string): string[] {
  const expanded: string[] = [];
  for (const arg of args) {
    if (arg.includes(\'*\') || arg.includes(\'?\')) {
      try {
        const result = execSync(`printf \'%s\\\\n\' ${arg}`, {
          cwd,
          encoding: \'utf-8\',
          timeout: 5000,
          shell: \'/bin/sh\'
        }).trim();
        if (result && result !== arg) {
          expanded.push(...result.split(\'\\n\').filter(Boolean));
        } else {
          expanded.push(arg);
        }
      } catch {
        expanded.push(arg);
      }
    } else {
      expanded.push(arg);
    }
  }
  return expanded;
}'.

%% ============================================================================
%% ENDPOINT HANDLERS GENERATION
%% ============================================================================

%! generate_endpoint_handlers(+ServiceSpec, +Target, -Code) is det
generate_endpoint_handlers(ServiceSpec, typescript, Code) :-
    service_endpoints(ServiceSpec, Endpoints),
    maplist(generate_ts_endpoint_handler, Endpoints, HandlerCodes),
    atomic_list_concat(HandlerCodes, '\n\n', Code).

generate_ts_endpoint_handler(Endpoint, Code) :-
    endpoint_name(Endpoint, Name),
    endpoint_method(Endpoint, Method),
    endpoint_path(Endpoint, Path),
    endpoint_roles(Endpoint, Roles),
    endpoint_public(Endpoint, IsPublic),
    endpoint_handler_type(Endpoint, HandlerType),

    % Generate role check if not public
    (   IsPublic == true
    ->  RoleCheck = '  // Public endpoint - no auth required'
    ;   Roles == []
    ->  RoleCheck = '  // Requires authentication\n  if (AUTH_REQUIRED && !user) {\n    return sendJSON(res, 401, { success: false, error: \'Authentication required\' });\n  }'
    ;   roles_to_ts_array_simple(Roles, RolesArray),
        format(atom(RoleCheck), '  // Requires roles: ~w\n  if (AUTH_REQUIRED) {\n    if (!user) return sendJSON(res, 401, { success: false, error: \'Authentication required\' });\n    const hasRequiredRole = ~w.some(r => user.roles.includes(r as Role));\n    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: \'Insufficient permissions\' });\n  }', [Roles, RolesArray])
    ),

    % Generate handler body based on type
    generate_handler_body(HandlerType, Name, HandlerBody),

    upcase_atom(Method, MethodUpper),
    format(atom(Code), '/**
 * ~w ~w - ~w endpoint
 */
async function handle_~w(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
~w

~w
}', [MethodUpper, Path, Name, Name, RoleCheck, HandlerBody]).

%! endpoint_handler_type(+Endpoint, -Type) is det
%  Determine the handler type from endpoint name/path
endpoint_handler_type(Endpoint, Type) :-
    endpoint_name(Endpoint, Name),
    handler_type_from_name(Name, Type), !.
endpoint_handler_type(_, custom).

handler_type_from_name(health, health) :- !.
handler_type_from_name(auth_status, auth_status) :- !.
handler_type_from_name(auth_login, login) :- !.
handler_type_from_name(auth_me, auth_me) :- !.
handler_type_from_name(commands, commands) :- !.
handler_type_from_name(browse, browse) :- !.
handler_type_from_name(grep, grep) :- !.
handler_type_from_name(find, find) :- !.
handler_type_from_name(cat, cat) :- !.
handler_type_from_name(exec, exec) :- !.
handler_type_from_name(feedback, feedback) :- !.
handler_type_from_name(_, custom).

%! generate_handler_body(+Type, +Name, -Body) is det
%  Generate the handler implementation body
generate_handler_body(health, _, Body) :-
    Body = '  sendJSON(res, 200, {
    success: true,
    data: {
      status: \'ok\',
      sandboxRoot: SANDBOX_ROOT,
      timestamp: new Date().toISOString()
    }
  });'.

generate_handler_body(auth_status, _, Body) :-
    Body = '  sendJSON(res, 200, {
    success: true,
    data: {
      authRequired: AUTH_REQUIRED,
      authenticated: user !== null,
      user: user ? { id: user.sub, email: user.email, roles: user.roles } : null
    }
  });'.

generate_handler_body(login, _, Body) :-
    Body = '  const { email, password } = body as any;

  if (!email || !password) {
    return sendJSON(res, 400, { success: false, error: \'Email and password required\' });
  }

  const result = login(email, password);

  if (!result.success) {
    return sendJSON(res, 401, { success: false, error: result.error || \'Login failed\' });
  }

  sendJSON(res, 200, {
    success: true,
    data: { token: result.token, user: result.user }
  });'.

generate_handler_body(auth_me, _, Body) :-
    Body = '  if (!user) {
    return sendJSON(res, 401, { success: false, error: \'Not authenticated\' });
  }

  sendJSON(res, 200, {
    success: true,
    data: {
      id: user.sub,
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
  });'.

generate_handler_body(commands, _, Body) :-
    Body = '  const commands = listCommands().filter(c => SEARCH_COMMANDS.includes(c.name) || c.risk === Risk.SAFE);
  sendJSON(res, 200, {
    success: true,
    data: { commands, searchCommands: SEARCH_COMMANDS }
  });'.

generate_handler_body(browse, _, Body) :-
    Body = '  const { path: browsePath = \'.\' } = body as any;

  const targetPath = path.resolve(SANDBOX_ROOT, browsePath);
  if (!targetPath.startsWith(SANDBOX_ROOT)) {
    return sendJSON(res, 403, { success: false, error: \'Path outside sandbox\' });
  }

  if (!fs.existsSync(targetPath)) {
    return sendJSON(res, 404, { success: false, error: \'Path not found\' });
  }

  const stats = fs.statSync(targetPath);
  if (!stats.isDirectory()) {
    return sendJSON(res, 400, { success: false, error: \'Not a directory\' });
  }

  const items = fs.readdirSync(targetPath);
  const entries: FileEntry[] = [];

  for (const name of items) {
    if (name.startsWith(\'.\') && browsePath !== \'.\') continue;
    try {
      const itemPath = path.join(targetPath, name);
      const itemStats = fs.statSync(itemPath);
      entries.push({
        name,
        type: itemStats.isDirectory() ? \'directory\' : \'file\',
        size: itemStats.isFile() ? itemStats.size : undefined,
        modified: itemStats.mtime.toISOString()
      });
    } catch { continue; }
  }

  entries.sort((a, b) => {
    if (a.type !== b.type) return a.type === \'directory\' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  const relativePath = path.relative(SANDBOX_ROOT, targetPath) || \'.\';

  sendJSON(res, 200, {
    success: true,
    data: {
      path: relativePath,
      absolutePath: targetPath,
      parent: relativePath !== \'.\' ? path.dirname(relativePath) || \'.\' : null,
      entries,
      count: entries.length
    }
  });'.

generate_handler_body(grep, _, Body) :-
    Body = '  const { pattern, path: searchPath = \'.\', options = [], cwd } = body as any;

  if (!pattern) {
    return sendJSON(res, 400, { success: false, error: \'Missing pattern\' });
  }

  const workingDir = resolveWorkingDir(cwd);
  const args = [\'-r\', \'-n\', \'--color=never\', ...options, pattern, searchPath];
  const cmdString = [\'grep\', ...args].join(\' \');
  const result = await execute(cmdString, { role: \'user\', cwd: workingDir });

  sendJSON(res, 200, {
    success: true,
    data: {
      matches: result.stdout?.split(\'\\n\').filter(Boolean) || [],
      count: result.stdout?.split(\'\\n\').filter(Boolean).length || 0,
      stderr: result.stderr
    },
    warning: result.warning
  });'.

generate_handler_body(find, _, Body) :-
    Body = '  const { pattern, path: searchPath = \'.\', options = [], cwd } = body as any;

  const workingDir = resolveWorkingDir(cwd);
  const args = [searchPath];
  if (pattern) args.push(\'-name\', pattern);
  args.push(...options);

  const cmdString = [\'find\', ...args].join(\' \');
  const result = await execute(cmdString, { role: \'user\', cwd: workingDir });

  sendJSON(res, 200, {
    success: true,
    data: {
      files: result.stdout?.split(\'\\n\').filter(Boolean) || [],
      count: result.stdout?.split(\'\\n\').filter(Boolean).length || 0
    },
    warning: result.warning
  });'.

generate_handler_body(cat, _, Body) :-
    Body = '  const { path: filePath, options = [], cwd } = body as any;

  if (!filePath) {
    return sendJSON(res, 400, { success: false, error: \'Missing path\' });
  }

  const workingDir = resolveWorkingDir(cwd);
  const cmdString = [\'cat\', ...options, filePath].join(\' \');
  const result = await execute(cmdString, { role: \'user\', cwd: workingDir });

  if (!result.success) {
    return sendJSON(res, 400, { success: false, error: result.error });
  }

  sendJSON(res, 200, {
    success: true,
    data: {
      content: result.stdout,
      lines: result.stdout?.split(\'\\n\').length || 0
    }
  });'.

generate_handler_body(exec, _, Body) :-
    Body = '  const { command, args = [], cwd } = body as any;

  if (!command) {
    return sendJSON(res, 400, { success: false, error: \'Missing command\' });
  }

  if (!SEARCH_COMMANDS.includes(command)) {
    return sendJSON(res, 403, { success: false, error: `Command not allowed. Allowed: ${SEARCH_COMMANDS.join(\', \')}` });
  }

  const workingDir = resolveWorkingDir(cwd);
  const expandedArgs = expandGlobs(args, workingDir);
  const validation = validateCommand(command, expandedArgs, { role: \'user\' });

  if (!validation.ok) {
    return sendJSON(res, 403, { success: false, error: validation.reason || \'Validation failed\' });
  }

  const cmdString = [command, ...expandedArgs].join(\' \');
  const result = await execute(cmdString, { role: \'user\', cwd: workingDir });

  if (!result.success) {
    return sendJSON(res, 400, { success: false, error: result.error, warning: result.warning });
  }

  sendJSON(res, 200, {
    success: true,
    data: { stdout: result.stdout, stderr: result.stderr, code: result.code },
    warning: result.warning
  });'.

generate_handler_body(feedback, _, Body) :-
    Body = '  // Handle GET for reading feedback
  if (req.method === \'GET\') {
    if (!fs.existsSync(FEEDBACK_FILE)) {
      return sendJSON(res, 200, { success: true, data: { entries: [], count: 0 } });
    }
    const content = fs.readFileSync(FEEDBACK_FILE, \'utf-8\');
    const lines = content.trim().split(\'\\n\').filter(Boolean);
    const entries = lines.map(line => { try { return JSON.parse(line); } catch { return { raw: line }; } });
    return sendJSON(res, 200, { success: true, data: { entries, count: entries.length } });
  }

  // POST for submitting feedback
  const { message, type = \'info\', context } = body as any;

  if (!message) {
    return sendJSON(res, 400, { success: false, error: \'Missing message\' });
  }

  const timestamp = new Date().toISOString();
  const record = { timestamp, type, message, context: context || null };
  fs.appendFileSync(FEEDBACK_FILE, JSON.stringify(record) + \'\\n\', \'utf-8\');

  sendJSON(res, 200, {
    success: true,
    data: { recorded: true, timestamp, file: FEEDBACK_FILE }
  });'.

generate_handler_body(custom, Name, Body) :-
    format(atom(Body), '  // TODO: Implement ~w logic
  sendJSON(res, 200, { success: true, data: { endpoint: \'~w\' } });', [Name, Name]).

roles_to_ts_array_simple(Roles, Array) :-
    maplist(role_to_string, Roles, Strings),
    atomic_list_concat(Strings, ', ', StringsJoined),
    format(atom(Array), '[~w]', [StringsJoined]).

role_to_string(Role, String) :-
    format(atom(String), '''~w''', [Role]).

%% ============================================================================
%% REQUEST ROUTER GENERATION
%% ============================================================================

%! generate_request_router(+ServiceSpec, +Target, -Code) is det
generate_request_router(ServiceSpec, typescript, Code) :-
    service_endpoints(ServiceSpec, Endpoints),
    generate_ts_route_cases(Endpoints, RouteCases),

    format(atom(Code), '// ============================================================================
// Request Router
// ============================================================================

function sendJSON(res: http.ServerResponse, status: number, data: APIResponse): void {
  res.writeHead(status, {
    \'Content-Type\': \'application/json\',
    \'Access-Control-Allow-Origin\': \'*\',
    \'Access-Control-Allow-Methods\': \'GET, POST, PUT, DELETE, OPTIONS\',
    \'Access-Control-Allow-Headers\': \'Content-Type, Authorization\'
  });
  res.end(JSON.stringify(data));
}

async function parseBody(req: http.IncomingMessage): Promise<RequestBody> {
  return new Promise((resolve, reject) => {
    let body = \'\';
    req.on(\'data\', chunk => {
      body += chunk;
      if (body.length > MAX_BODY_SIZE) {
        reject(new Error(\'Body too large\'));
      }
    });
    req.on(\'end\', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch {
        resolve({});
      }
    });
    req.on(\'error\', reject);
  });
}

function extractToken(req: http.IncomingMessage): string | null {
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith(\'Bearer \')) {
    return authHeader.substring(7);
  }
  return null;
}

async function handleRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): Promise<void> {
  // Handle CORS preflight
  if (req.method === \'OPTIONS\') {
    res.writeHead(204, {
      \'Access-Control-Allow-Origin\': \'*\',
      \'Access-Control-Allow-Methods\': \'GET, POST, PUT, DELETE, OPTIONS\',
      \'Access-Control-Allow-Headers\': \'Content-Type, Authorization\'
    });
    res.end();
    return;
  }

  const parsedUrl = url.parse(req.url || \'\', true);
  const pathname = parsedUrl.pathname || \'/\';
  const method = req.method || \'GET\';

  // Extract and verify token
  const token = extractToken(req);
  const user = token ? verifyToken(token) : null;

  try {
    const body = await parseBody(req);

    // Route to handlers
~w

    // Not found
    sendJSON(res, 404, { success: false, error: \'Not found\' });
  } catch (err) {
    console.error(\'Request error:\', err);
    sendJSON(res, 500, { success: false, error: \'Internal server error\' });
  }
}', [RouteCases]).

generate_ts_route_cases(Endpoints, Code) :-
    maplist(generate_ts_route_case, Endpoints, Cases),
    atomic_list_concat(Cases, '\n', Code).

generate_ts_route_case(Endpoint, Code) :-
    endpoint_name(Endpoint, Name),
    endpoint_method(Endpoint, Method),
    endpoint_path(Endpoint, Path),
    upcase_atom(Method, MethodUpper),
    format(atom(Code), '    if (method === \'~w\' && pathname === \'~w\') {\n      return handle_~w(req, res, body, user);\n    }', [MethodUpper, Path, Name]).

%% ============================================================================
%% WEBSOCKET HANDLER GENERATION
%% ============================================================================

%! generate_websocket_handler(+ServiceSpec, +Target, -Code) is det
generate_websocket_handler(ServiceSpec, typescript, Code) :-
    service_websocket(ServiceSpec, WSConfig),
    (   WSConfig == none
    ->  Code = '// No WebSocket configured'
    ;   websocket_roles(WSConfig, WSRoles),
        roles_to_ts_array_simple(WSRoles, RolesArray),
        format(atom(Code), '// ============================================================================
// WebSocket Shell Session
// ============================================================================

interface ShellSession {
  ws: WebSocket;
  user: TokenPayload;
  process: ChildProcessWithoutNullStreams | null;
  currentDir: string;
  inputBuffer: string;
}

function setupWebSocket(server: http.Server | https.Server): void {
  const wss = new WebSocketServer({ server });

  wss.on(\'connection\', (ws: WebSocket, req: http.IncomingMessage) => {
    const parsedUrl = url.parse(req.url || \'\', true);
    const token = parsedUrl.query.token as string;

    if (!token) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Authentication required\' }));
      ws.close(1008, \'Authentication required\');
      return;
    }

    const payload = verifyToken(token);
    if (!payload) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Invalid token\' }));
      ws.close(1008, \'Invalid token\');
      return;
    }

    // Check for required roles
    const requiredRoles = ~w;
    const hasRequiredRole = requiredRoles.length === 0 || requiredRoles.some(r => payload.roles.includes(r as Role));
    if (!hasRequiredRole) {
      ws.send(JSON.stringify({ type: \'error\', data: \'Shell access requires role: \' + requiredRoles.join(\', \') }));
      ws.close(1008, \'Access denied\');
      return;
    }

    console.log(`Shell session started for ${payload.email}`);
    handleShellConnection(ws, payload);
  });
}

function handleShellConnection(ws: WebSocket, user: TokenPayload): void {
  const session: ShellSession = {
    ws,
    user,
    process: null,
    currentDir: SANDBOX_ROOT,
    inputBuffer: \'\'
  };

  // Send welcome message
  const welcome = `\\r\\nConnected to UnifyWeaver Shell\\r\\nUser: ${user.email} [${user.roles.join(\', \')}]\\r\\nWorking directory: ${SANDBOX_ROOT}\\r\\nType \"help\" for commands, \"exit\" to disconnect\\r\\n\\r\\n`;
  ws.send(JSON.stringify({ type: \'output\', data: welcome }));
  ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));

  ws.on(\'message\', (data: Buffer | string) => {
    try {
      const msg = JSON.parse(data.toString());
      if (msg.type === \'input\') {
        handleShellInput(session, msg.data);
      }
    } catch (err) {
      console.error(\'Shell message error:\', err);
    }
  });

  ws.on(\'close\', () => {
    if (session.process) {
      session.process.kill();
      session.process = null;
    }
    console.log(`Shell session closed for ${user.email}`);
  });
}

function handleShellInput(session: ShellSession, char: string): void {
  const { ws } = session;

  // Enter key
  if (char === \'\\r\' || char === \'\\n\') {
    ws.send(JSON.stringify({ type: \'output\', data: \'\\r\\n\' }));
    const command = session.inputBuffer.trim();
    session.inputBuffer = \'\';
    if (command) {
      executeShellCommand(session, command);
    } else {
      ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
    }
  }
  // Backspace
  else if (char === \'\\x7f\' || char === \'\\b\') {
    if (session.inputBuffer.length > 0) {
      session.inputBuffer = session.inputBuffer.slice(0, -1);
      ws.send(JSON.stringify({ type: \'output\', data: \'\\b \\b\' }));
    }
  }
  // Ctrl+C
  else if (char === \'\\x03\') {
    if (session.process) {
      session.process.kill(\'SIGINT\');
      session.process = null;
    }
    ws.send(JSON.stringify({ type: \'output\', data: \'^C\\r\\n\' }));
    session.inputBuffer = \'\';
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
  }
  // Printable characters
  else if (char >= \' \' && char <= \'~~\') {
    session.inputBuffer += char;
    ws.send(JSON.stringify({ type: \'output\', data: char }));
  }
}

function executeShellCommand(session: ShellSession, command: string): void {
  const { ws } = session;

  // Built-in: help
  if (command === \'help\') {
    const helpText = `\\r\\nUnifyWeaver Shell - Built-in Commands:\\r\\n  help    - Show this help\\r\\n  cd DIR  - Change directory\\r\\n  pwd     - Print working directory\\r\\n  exit    - Disconnect\\r\\n\\r\\nYou can run any shell command. Output is streamed in real-time.\\r\\n\\r\\n`;
    ws.send(JSON.stringify({ type: \'output\', data: helpText }));
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
    return;
  }

  // Built-in: exit
  if (command === \'exit\' || command === \'quit\') {
    ws.send(JSON.stringify({ type: \'output\', data: \'Goodbye!\\r\\n\' }));
    ws.close();
    return;
  }

  // Built-in: cd
  if (command.startsWith(\'cd \') || command === \'cd\') {
    const targetDir = command.slice(3).trim() || SANDBOX_ROOT;
    let newDir: string;

    if (path.isAbsolute(targetDir)) {
      newDir = targetDir;
    } else if (targetDir === \'~~\') {
      newDir = SANDBOX_ROOT;
    } else if (targetDir.startsWith(\'~~/\')) {
      newDir = path.join(SANDBOX_ROOT, targetDir.slice(2));
    } else {
      newDir = path.resolve(session.currentDir, targetDir);
    }

    // Security: ensure within sandbox
    if (!newDir.startsWith(SANDBOX_ROOT)) {
      ws.send(JSON.stringify({ type: \'output\', data: `\\x1b[31mcd: Access denied - outside sandbox\\x1b[0m\\r\\n` }));
      ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
      return;
    }

    if (fs.existsSync(newDir) && fs.statSync(newDir).isDirectory()) {
      session.currentDir = newDir;
    } else {
      ws.send(JSON.stringify({ type: \'output\', data: `\\x1b[31mcd: ${targetDir}: No such directory\\x1b[0m\\r\\n` }));
    }
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
    return;
  }

  // Built-in: pwd
  if (command === \'pwd\') {
    ws.send(JSON.stringify({ type: \'output\', data: session.currentDir + \'\\r\\n\' }));
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
    return;
  }

  // Execute shell command
  const proc = spawn(\'sh\', [\'-c\', command], {
    cwd: session.currentDir,
    env: { ...process.env, HOME: SANDBOX_ROOT, TERM: \'xterm-256color\' }
  });

  session.process = proc;

  proc.stdout.on(\'data\', (data: Buffer) => {
    ws.send(JSON.stringify({ type: \'output\', data: data.toString().replace(/\\n/g, \'\\r\\n\') }));
  });

  proc.stderr.on(\'data\', (data: Buffer) => {
    ws.send(JSON.stringify({ type: \'output\', data: `\\x1b[31m${data.toString().replace(/\\n/g, \'\\r\\n\')}\\x1b[0m` }));
  });

  proc.on(\'close\', (code: number) => {
    session.process = null;
    if (code !== 0) {
      ws.send(JSON.stringify({ type: \'output\', data: `\\x1b[33m[exit code: ${code}]\\x1b[0m\\r\\n` }));
    }
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
  });

  proc.on(\'error\', (err: Error) => {
    session.process = null;
    ws.send(JSON.stringify({ type: \'output\', data: `\\x1b[31mError: ${err.message}\\x1b[0m\\r\\n` }));
    ws.send(JSON.stringify({ type: \'prompt\', cwd: session.currentDir }));
  });
}', [RolesArray])
    ).

%% ============================================================================
%% SERVER SETUP GENERATION
%% ============================================================================

%! generate_server_setup(+ServiceSpec, +Target, -Code) is det
generate_server_setup(ServiceSpec, typescript, Code) :-
    service_https(ServiceSpec, HTTPSConfig),
    service_websocket(ServiceSpec, WSConfig),
    service_port(ServiceSpec, DefaultPort),

    % WebSocket setup call
    (   WSConfig \= none
    ->  WSSetup = '  setupWebSocket(server);'
    ;   WSSetup = '  // No WebSocket configured'
    ),

    format(atom(Code), '// ============================================================================
// Server Setup
// ============================================================================

interface SSLOptions {
  cert?: string;
  key?: string;
}

function startServer(port: number, ssl?: SSLOptions): void {
  let server: http.Server | https.Server;
  let protocol: string;

  if (ssl?.cert && ssl?.key) {
    // HTTPS mode
    try {
      const sslOptions = {
        cert: fs.readFileSync(ssl.cert),
        key: fs.readFileSync(ssl.key)
      };
      server = https.createServer(sslOptions, handleRequest);
      protocol = \'https\';
    } catch (err) {
      console.error(`Failed to load SSL certificates: ${err}`);
      process.exit(1);
    }
  } else {
    // HTTP mode
    server = http.createServer(handleRequest);
    protocol = \'http\';
  }

~w

  server.listen(port, () => {
    const wsProtocol = protocol === \'https\' ? \'wss\' : \'ws\';
    console.log(`Server running at ${protocol}://localhost:${port}`);
    console.log(`SSL/TLS: ${protocol === \'https\' ? \'ENABLED\' : \'disabled\'}`);
    console.log(`Auth: ${AUTH_REQUIRED ? \'ENABLED\' : \'disabled\'}`);
  });

  server.on(\'error\', (err: NodeJS.ErrnoException) => {
    if (err.code === \'EADDRINUSE\') {
      console.error(`Port ${port} is already in use`);
    } else {
      console.error(\'Server error:\', err);
    }
    process.exit(1);
  });
}', [WSSetup]).

%% ============================================================================
%% CLI PARSER GENERATION
%% ============================================================================

%! generate_cli_parser(+ServiceSpec, +Target, -Code) is det
generate_cli_parser(ServiceSpec, typescript, Code) :-
    service_port(ServiceSpec, DefaultPort),
    service_name(ServiceSpec, Name),

    format(atom(Code), '// ============================================================================
// CLI Entry
// ============================================================================

function main(): void {
  const args = process.argv.slice(2);
  let port = ~w;
  let certPath: string | undefined;
  let keyPath: string | undefined;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case \'--port\':
        port = parseInt(args[++i], 10);
        if (isNaN(port)) {
          console.error(\'Invalid port number\');
          process.exit(1);
        }
        break;
      case \'--cert\':
        certPath = args[++i];
        break;
      case \'--key\':
        keyPath = args[++i];
        break;
      case \'--help\':
      case \'-h\':
        console.log(`
~w - Generated by UnifyWeaver

Usage:
  ts-node server.ts [options]

Options:
  --port <number>   Port to listen on (default: ~w)
  --cert <path>     Path to SSL certificate (enables HTTPS)
  --key <path>      Path to SSL private key (enables HTTPS)
  --help, -h        Show this help

Environment:
  AUTH_REQUIRED     Set to \'true\' to require authentication
`);
        process.exit(0);
    }
  }

  // Validate SSL options
  if ((certPath && !keyPath) || (!certPath && keyPath)) {
    console.error(\'Both --cert and --key are required for HTTPS\');
    process.exit(1);
  }

  const ssl = certPath && keyPath ? { cert: certPath, key: keyPath } : undefined;
  startServer(port, ssl);
}', [DefaultPort, Name, DefaultPort]).

%% ============================================================================
%% HTML INTERFACE GENERATION
%% ============================================================================

%! generate_html_interface_function(+ServiceSpec, +Target, -Code) is det
%
%  Generate the getHTMLInterface() function using UI primitives.
%
generate_html_interface_function(_ServiceSpec, typescript, Code) :-
    % Try to use the declarative UI generator
    (   current_predicate(http_cli_ui:http_cli_interface/1),
        current_predicate(http_cli_ui:http_cli_theme/1),
        current_predicate(html_interface_generator:generate_html_interface/3)
    ->  http_cli_ui:http_cli_interface(UISpec),
        http_cli_ui:http_cli_theme(Theme),
        html_interface_generator:generate_html_interface(UISpec, Theme, HTMLContent),
        % Escape backticks and dollar signs for JavaScript template literal
        escape_for_js_template(HTMLContent, EscapedHTML),
        format(atom(Code), 'function getHTMLInterface(): string {
  return `~w`;
}', [EscapedHTML])
    ;   % Fallback: minimal HTML
        Code = 'function getHTMLInterface(): string {
  return `<!DOCTYPE html>
<html><head><title>UnifyWeaver CLI</title></head>
<body><h1>UnifyWeaver CLI Server</h1><p>HTML interface not available.</p></body>
</html>`;
}'
    ).

%! escape_for_js_template(+Input, -Output) is det
%  Escape content for JavaScript template literal (backticks).
escape_for_js_template(Input, Output) :-
    atom_string(Input, Str),
    % Escape backticks and ${
    string_replace(Str, "`", "\\`", Str1),
    string_replace(Str1, "${", "\\${", Str2),
    atom_string(Output, Str2).

%! string_replace(+Input, +From, +To, -Output) is det
%  Simple string replacement.
string_replace(Input, From, To, Output) :-
    (   sub_string(Input, Before, _, After, From)
    ->  sub_string(Input, 0, Before, _, Prefix),
        sub_string(Input, _, After, 0, Suffix),
        string_replace(Suffix, From, To, ReplacedSuffix),
        string_concat(Prefix, To, Temp),
        string_concat(Temp, ReplacedSuffix, Output)
    ;   Output = Input
    ).

%% ============================================================================
%% HELPER PREDICATES
%% ============================================================================

%! upcase_atom(+LowerAtom, -UpperAtom) is det
%
%  Convert atom to uppercase.
%
upcase_atom(Lower, Upper) :-
    atom_codes(Lower, Codes),
    maplist(upcase_code, Codes, UpperCodes),
    atom_codes(Upper, UpperCodes).

upcase_code(C, U) :-
    (   C >= 0'a, C =< 0'z
    ->  U is C - 32
    ;   U = C
    ).
