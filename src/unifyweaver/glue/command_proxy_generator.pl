:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025-2026 John William Creighton (@s243a)
%
% command_proxy_generator.pl - Generate command validation proxy from specs

:- module(command_proxy_generator, [
    generate_command_proxy/3,
    default_commands/1
]).

:- use_module(library(lists)).

%! generate_command_proxy(+Options, +Target, -Code) is det
generate_command_proxy(Options, typescript, Code) :-
    get_option(sandbox_root, Options, SandboxRoot, '$HOME/sandbox'),
    get_option(commands, Options, Commands, default),
    get_option(default_timeout, Options, Timeout, 30000),
    (Commands == default -> default_commands(CmdList) ; CmdList = Commands),
    generate_ts_command_proxy(SandboxRoot, CmdList, Timeout, Code).

get_option(Key, Options, Value, _) :-
    Term =.. [Key, Value],
    member(Term, Options), !.
get_option(_, _, Default, Default).

%! default_commands(-Commands) is det
default_commands([
    cmd(ls, safe, 'List directory contents', []),
    cmd(cat, moderate, 'Display file contents', [sensitive_paths]),
    cmd(head, safe, 'Display first lines', []),
    cmd(tail, safe, 'Display last lines', []),
    cmd(pwd, safe, 'Print working directory', []),
    cmd(cd, safe, 'Change directory', [builtin]),
    cmd(grep, safe, 'Search file contents', []),
    cmd(find, safe, 'Find files', [no_destructive_exec]),
    cmd(cp, moderate, 'Copy files', [sandbox_only]),
    cmd(mv, moderate, 'Move/rename files', [sandbox_only]),
    cmd(mkdir, safe, 'Create directory', [sandbox_only]),
    cmd(rm, high, 'Remove files', [sandbox_only, requires_confirmation]),
    cmd(touch, safe, 'Create empty file', []),
    cmd(echo, safe, 'Print text', []),
    cmd(wc, safe, 'Word count', []),
    cmd(sort, safe, 'Sort lines', []),
    cmd(uniq, safe, 'Filter unique lines', []),
    cmd(date, safe, 'Show date/time', []),
    cmd(whoami, safe, 'Show current user', []),
    cmd(uname, safe, 'System information', []),
    cmd(df, safe, 'Disk usage', []),
    cmd(du, safe, 'Directory size', []),
    cmd(git, moderate, 'Git version control', [no_force_push]),
    cmd(node, moderate, 'Run Node.js', [no_eval]),
    cmd(npm, moderate, 'Node package manager', [no_global]),
    cmd(python, moderate, 'Run Python', [no_eval]),
    cmd(python3, moderate, 'Run Python 3', [no_eval]),
    cmd(pip, moderate, 'Python package manager', []),
    cmd(curl, moderate, 'HTTP client', [sandbox_output]),
    cmd(wget, moderate, 'Download files', []),
    cmd(sudo, blocked, 'Superuser do', []),
    cmd(su, blocked, 'Switch user', []),
    cmd(chown, blocked, 'Change ownership', []),
    cmd(chmod, high, 'Change permissions', [requires_confirmation])
]).

generate_ts_command_proxy(SandboxRoot, Commands, Timeout, Code) :-
    generate_registry_entries(Commands, RegistryEntries),
    atomic_list_concat([
        '/**\n',
        ' * command-proxy.ts - Command Interception and Validation Proxy\n',
        ' * Generated by UnifyWeaver command_proxy_generator.pl\n',
        ' * DO NOT EDIT - regenerate from spec\n',
        ' */\n\n',
        'import { spawn, SpawnOptions } from ''child_process'';\n',
        'import * as path from ''path'';\n\n',
        '// Types\n',
        'export enum Risk {\n',
        '  SAFE = ''safe'',\n',
        '  MODERATE = ''moderate'',\n',
        '  HIGH = ''high'',\n',
        '  BLOCKED = ''blocked''\n',
        '}\n\n',
        'export interface ExecutionContext {\n',
        '  role?: string;\n',
        '  cwd?: string;\n',
        '  confirmed?: boolean;\n',
        '  timeout?: number;\n',
        '}\n\n',
        'export interface ValidationResult {\n',
        '  ok: boolean;\n',
        '  reason?: string;\n',
        '  warning?: string;\n',
        '  risk?: Risk;\n',
        '  requiresConfirmation?: boolean;\n',
        '  description?: string;\n',
        '}\n\n',
        'export interface ExecutionResult {\n',
        '  success: boolean;\n',
        '  code?: number;\n',
        '  stdout?: string;\n',
        '  stderr?: string;\n',
        '  error?: string;\n',
        '  warning?: string;\n',
        '}\n\n',
        'export interface CommandDefinition {\n',
        '  risk: Risk;\n',
        '  description: string;\n',
        '  validate: (args: string[], ctx: ExecutionContext) => ValidationResult;\n',
        '  transform: (args: string[]) => string[];\n',
        '  requiresConfirmation?: boolean;\n',
        '}\n\n',
        'export interface CommandInfo {\n',
        '  name: string;\n',
        '  risk: Risk;\n',
        '  description: string;\n',
        '  requiresConfirmation: boolean;\n',
        '}\n\n'
    ], Header),
    format(atom(Config), '// Configuration\nexport const SANDBOX_ROOT = process.env.SANDBOX_ROOT || ''~w'';\n\n', [SandboxRoot]),
    atomic_list_concat([
        '// Helpers\n',
        'const isSensitivePath = (p: string): boolean => {\n',
        '  const sensitive = [''/etc/shadow'', ''/etc/passwd'', ''/root'', ''.ssh/id_'', ''.env'', ''credentials''];\n',
        '  return sensitive.some(s => p.includes(s));\n',
        '};\n\n',
        'const isOutsideSandbox = (p: string): boolean => {\n',
        '  return p.startsWith(''/'') && !p.startsWith(SANDBOX_ROOT);\n',
        '};\n\n'
    ], Helpers),
    format(atom(Registry), '// Command Registry\nconst commandRegistry: Record<string, CommandDefinition> = {\n~w\n};\n\n', [RegistryEntries]),
    format(atom(Functions), '// Functions
export function parseCommand(cmdString: string): { cmd: string; args: string[] } {
  const parts = cmdString.trim().split(/\\s+/);
  return { cmd: parts[0], args: parts.slice(1) };
}

export function validateCommand(cmd: string, args: string[], ctx: ExecutionContext = {}): ValidationResult {
  const def = commandRegistry[cmd];
  if (!def) return { ok: false, reason: `Unknown command: ${cmd}` };
  if (def.risk === Risk.BLOCKED) return { ok: false, reason: `${cmd} is blocked` };
  const result = def.validate(args, ctx);
  return { ...result, risk: def.risk, requiresConfirmation: def.requiresConfirmation || false, description: def.description };
}

export function executeCommand(cmd: string, args: string[], options: ExecutionContext = {}): Promise<ExecutionResult> {
  return new Promise((resolve) => {
    const def = commandRegistry[cmd];
    if (!def) { resolve({ success: false, error: `Unknown command: ${cmd}` }); return; }
    const transformedArgs = def.transform(args);
    const executable = transformedArgs[0];
    const execArgs = transformedArgs.slice(1);
    const proc = spawn(executable, execArgs, {
      cwd: options.cwd || SANDBOX_ROOT,
      timeout: options.timeout || ~w
    } as SpawnOptions);
    let stdout = '''';
    let stderr = '''';
    proc.stdout?.on(''data'', (data: Buffer) => { stdout += data.toString(); });
    proc.stderr?.on(''data'', (data: Buffer) => { stderr += data.toString(); });
    proc.on(''close'', (code: number | null) => { resolve({ success: code === 0, code: code ?? undefined, stdout, stderr }); });
    proc.on(''error'', (err: Error) => { resolve({ success: false, error: err.message }); });
  });
}

export async function execute(cmdString: string, ctx: ExecutionContext = {}): Promise<ExecutionResult> {
  const { cmd, args } = parseCommand(cmdString);
  console.log(`[command-proxy] ${cmd} ${args.join('' '')}`);
  const validation = validateCommand(cmd, args, ctx);
  if (!validation.ok) return { success: false, error: validation.reason };
  if (validation.requiresConfirmation && !ctx.confirmed) return { success: false, error: ''Requires confirmation'', warning: validation.warning };
  try {
    const result = await executeCommand(cmd, args, ctx);
    return { ...result, warning: validation.warning };
  } catch (err) {
    return { success: false, error: (err as Error).message };
  }
}

export function listCommands(): CommandInfo[] {
  return Object.entries(commandRegistry).map(([name, def]) => ({
    name, risk: def.risk, description: def.description, requiresConfirmation: def.requiresConfirmation || false
  }));
}

export default { execute, validateCommand, listCommands, Risk, SANDBOX_ROOT };
', [Timeout]),
    atomic_list_concat([Header, Config, Helpers, Registry, Functions], Code).

generate_registry_entries(Commands, Entries) :-
    maplist(generate_registry_entry, Commands, EntryList),
    atomic_list_concat(EntryList, ',\n', Entries).

generate_registry_entry(cmd(Name, Risk, Desc, Flags), Entry) :-
    risk_to_ts(Risk, TsRisk),
    generate_validator(Name, Flags, Validator),
    generate_transform(Name, Transform),
    confirmation_flag(Flags, ConfirmStr),
    format(atom(Entry), '  ''~w'': {\n    risk: Risk.~w,\n    description: ''~w'',\n    validate: ~w,\n    transform: ~w~w\n  }', [Name, TsRisk, Desc, Validator, Transform, ConfirmStr]).

risk_to_ts(safe, 'SAFE').
risk_to_ts(moderate, 'MODERATE').
risk_to_ts(high, 'HIGH').
risk_to_ts(blocked, 'BLOCKED').

confirmation_flag(Flags, ',\n    requiresConfirmation: true') :-
    member(requires_confirmation, Flags), !.
confirmation_flag(_, '').

generate_validator(_, Flags, '(args) => {\n      if (args.some(a => isSensitivePath(a))) return { ok: false, reason: ''Access to sensitive paths blocked'' };\n      return { ok: true };\n    }') :-
    member(sensitive_paths, Flags), !.
generate_validator(_, Flags, '(args) => {\n      if (args.some(a => isOutsideSandbox(a))) return { ok: false, reason: ''Operation must stay within sandbox'' };\n      return { ok: true };\n    }') :-
    member(sandbox_only, Flags), !.
generate_validator(_, Flags, '(args) => {\n      const execIdx = args.indexOf(''-exec'');\n      if (execIdx !== -1 && /rm|chmod|chown/.test(args.slice(execIdx + 1).join('' ''))) return { ok: false, reason: ''Destructive -exec blocked'' };\n      return { ok: true };\n    }') :-
    member(no_destructive_exec, Flags), !.
generate_validator(_, Flags, '(args) => {\n      if (args.includes(''push'') && (args.includes(''--force'') || args.includes(''-f''))) return { ok: false, reason: ''Force push blocked'' };\n      return { ok: true };\n    }') :-
    member(no_force_push, Flags), !.
generate_validator(_, Flags, '(args) => {\n      if (args.includes(''-e'') || args.includes(''--eval'') || args.includes(''-c'')) return { ok: false, reason: ''Eval blocked'' };\n      return { ok: true };\n    }') :-
    member(no_eval, Flags), !.
generate_validator(_, Flags, '(args) => {\n      if (args.includes(''-g'') || args.includes(''--global'')) return { ok: false, reason: ''Global operations blocked'' };\n      return { ok: true };\n    }') :-
    member(no_global, Flags), !.
generate_validator(sudo, _, '() => ({ ok: false, reason: ''sudo is not available in sandbox'' })') :- !.
generate_validator(su, _, '() => ({ ok: false, reason: ''su is not available in sandbox'' })') :- !.
generate_validator(chown, _, '() => ({ ok: false, reason: ''chown not available in sandbox'' })') :- !.
generate_validator(_, _, '() => ({ ok: true })').

generate_transform(ls, '(args) => [''ls'', ''--color=auto'', ...args]') :- !.
generate_transform(grep, '(args) => [''grep'', ''--color=auto'', ...args]') :- !.
generate_transform(mkdir, '(args) => [''mkdir'', ''-p'', ...args]') :- !.
generate_transform(df, '(args) => [''df'', ''-h'', ...args]') :- !.
generate_transform(du, '(args) => [''du'', ''-h'', ...args]') :- !.
generate_transform(python, '(args) => [''python3'', ...args]') :- !.
generate_transform(Name, Transform) :-
    format(atom(Transform), '(args) => [''~w'', ...args]', [Name]).
