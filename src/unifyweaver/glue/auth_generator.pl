:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025-2026 John William Creighton (@s243a)
%
% auth_generator.pl - Generate authentication modules from declarative specs
%
% Generates TypeScript (and other language) authentication code including:
% - JWT token creation and verification
% - Password hashing (bcrypt, SHA256)
% - Role-based access control
% - User storage backends (text file, SQLite)
%
% Usage:
%   :- use_module(auth_generator).
%
%   % Define auth spec
%   AuthSpec = auth(jwt_auth, [
%       backend(text_file),
%       password_hash(bcrypt),
%       roles([admin, user, shell])
%   ]),
%
%   % Generate TypeScript
%   generate_auth_module(AuthSpec, typescript, Code).

:- module(auth_generator, [
    % Main generation entry points
    generate_auth_module/3,           % +AuthSpec, +Target, -Code
    generate_auth_types/3,            % +AuthSpec, +Target, -Code
    generate_auth_config/2,           % +AuthSpec, -JSONConfig

    % Auth spec accessors
    auth_name/2,
    auth_backend/2,
    auth_password_hash/2,
    auth_token_type/2,
    auth_token_expiry/2,
    auth_roles/2,
    auth_default_users/2,
    auth_users_file/2,

    % Code generation helpers
    generate_jwt_functions/2,         % +Target, -Code
    generate_password_functions/3,    % +HashAlgo, +Target, -Code
    generate_role_functions/3,        % +Roles, +Target, -Code
    generate_user_storage/3           % +Backend, +Target, -Code
]).

:- use_module(library(lists)).

%% ============================================================================
%% AUTH SPEC ACCESSORS
%% ============================================================================

%! auth_name(+Spec, -Name) is det
auth_name(auth(Name, _Config), Name).

%! auth_backend(+Spec, -Backend) is det
auth_backend(auth(_Name, Config), Backend) :-
    (   member(backend(Backend), Config)
    ->  true
    ;   Backend = text_file
    ).

%! auth_password_hash(+Spec, -HashAlgo) is det
auth_password_hash(auth(_Name, Config), HashAlgo) :-
    (   member(password_hash(HashAlgo), Config)
    ->  true
    ;   HashAlgo = sha256
    ).

%! auth_token_type(+Spec, -TokenType) is det
auth_token_type(auth(_Name, Config), TokenType) :-
    (   member(token_type(TokenType), Config)
    ->  true
    ;   TokenType = jwt
    ).

%! auth_token_expiry(+Spec, -Expiry) is det
auth_token_expiry(auth(_Name, Config), Expiry) :-
    (   member(token_expiry(Expiry), Config)
    ->  true
    ;   Expiry = 86400  % 24 hours default
    ).

%! auth_roles(+Spec, -Roles) is det
auth_roles(auth(_Name, Config), Roles) :-
    (   member(roles(RoleDefs), Config)
    ->  extract_role_names(RoleDefs, Roles)
    ;   Roles = [user, admin]
    ).

extract_role_names([], []).
extract_role_names([role(Name, _)|Rs], [Name|Ns]) :-
    !,
    extract_role_names(Rs, Ns).
extract_role_names([Name|Rs], [Name|Ns]) :-
    atom(Name),
    extract_role_names(Rs, Ns).

%! auth_default_users(+Spec, -Users) is det
auth_default_users(auth(_Name, Config), Users) :-
    (   member(default_users(Users), Config)
    ->  true
    ;   Users = []
    ).

%! auth_users_file(+Spec, -FilePath) is det
auth_users_file(auth(_Name, Config), FilePath) :-
    (   member(users_file(FilePath), Config)
    ->  true
    ;   FilePath = 'users.txt'
    ).

%% ============================================================================
%% MAIN GENERATION ENTRY POINTS
%% ============================================================================

%! generate_auth_module(+AuthSpec, +Target, -Code) is det
%
%  Generate complete auth module for the specified target language.
%
%  Targets: typescript, python, go
%
generate_auth_module(AuthSpec, typescript, Code) :-
    auth_backend(AuthSpec, Backend),
    auth_password_hash(AuthSpec, HashAlgo),
    auth_roles(AuthSpec, Roles),
    auth_token_expiry(AuthSpec, Expiry),
    auth_users_file(AuthSpec, UsersFile),
    auth_default_users(AuthSpec, DefaultUsers),

    % Generate each section
    generate_ts_imports(HashAlgo, ImportsCode),
    generate_ts_types(Roles, TypesCode),
    generate_ts_config(Expiry, UsersFile, ConfigCode),
    generate_password_functions(HashAlgo, typescript, PasswordCode),
    generate_jwt_functions(typescript, JWTCode),
    generate_user_storage(Backend, typescript, StorageCode),
    generate_role_functions(Roles, typescript, RoleCode),
    generate_ts_default_users(DefaultUsers, DefaultUsersCode),
    generate_ts_exports(ExportsCode),

    % Combine all sections
    atomic_list_concat([
        '// Generated by UnifyWeaver auth_generator.pl\n',
        '// DO NOT EDIT - regenerate from spec\n\n',
        ImportsCode, '\n\n',
        TypesCode, '\n\n',
        ConfigCode, '\n\n',
        PasswordCode, '\n\n',
        JWTCode, '\n\n',
        StorageCode, '\n\n',
        RoleCode, '\n\n',
        DefaultUsersCode, '\n\n',
        ExportsCode
    ], Code).

generate_auth_module(AuthSpec, python, Code) :-
    % TODO: Implement Python generation
    auth_name(AuthSpec, Name),
    format(atom(Code), '# Python auth module: ~w\n# Not yet implemented', [Name]).

generate_auth_module(AuthSpec, go, Code) :-
    % TODO: Implement Go generation
    auth_name(AuthSpec, Name),
    format(atom(Code), '// Go auth module: ~w\n// Not yet implemented', [Name]).

%! generate_auth_types(+AuthSpec, +Target, -Code) is det
%
%  Generate just the type definitions.
%
generate_auth_types(AuthSpec, typescript, Code) :-
    auth_roles(AuthSpec, Roles),
    generate_ts_types(Roles, Code).

%! generate_auth_config(+AuthSpec, -JSONConfig) is det
%
%  Generate JSON configuration file content.
%
generate_auth_config(AuthSpec, JSONConfig) :-
    auth_backend(AuthSpec, Backend),
    auth_password_hash(AuthSpec, HashAlgo),
    auth_token_type(AuthSpec, TokenType),
    auth_token_expiry(AuthSpec, Expiry),
    auth_users_file(AuthSpec, UsersFile),

    format(atom(JSONConfig), '{
  "backend": "~w",
  "passwordHash": "~w",
  "tokenType": "~w",
  "usersFile": "~w",
  "sessionDuration": ~w,
  "jwtSecret": "change-this-in-production-use-env-var"
}', [Backend, HashAlgo, TokenType, UsersFile, Expiry]).

%% ============================================================================
%% TYPESCRIPT GENERATION HELPERS
%% ============================================================================

generate_ts_imports(bcrypt, Code) :-
    Code = 'import * as crypto from \'crypto\';
import * as fs from \'fs\';
import * as path from \'path\';

// Note: For production, use actual bcrypt package
// npm install bcrypt @types/bcrypt
// import bcrypt from \'bcrypt\';'.

generate_ts_imports(sha256, Code) :-
    Code = 'import * as crypto from \'crypto\';
import * as fs from \'fs\';
import * as path from \'path\';'.

generate_ts_imports(_, Code) :-
    Code = 'import * as crypto from \'crypto\';
import * as fs from \'fs\';
import * as path from \'path\';'.

generate_ts_types(Roles, Code) :-
    roles_to_ts_union(Roles, RolesUnion),
    format(atom(Code), '// ============================================================================
// Types
// ============================================================================

export type Role = ~w;

export interface User {
  email: string;
  passwordHash: string;
  roles: Role[];
  permissions: string[];
}

export interface TokenPayload {
  sub: string;
  email: string;
  roles: Role[];
  permissions: string[];
  iat: number;
  exp: number;
}

export interface AuthResult {
  success: boolean;
  token?: string;
  user?: Omit<User, \'passwordHash\'>;
  error?: string;
}', [RolesUnion]).

roles_to_ts_union([], '\'user\'').
roles_to_ts_union([R], Union) :-
    format(atom(Union), '\'~w\'', [R]).
roles_to_ts_union([R|Rs], Union) :-
    Rs \= [],
    roles_to_ts_union(Rs, RestUnion),
    format(atom(Union), '\'~w\' | ~w', [R, RestUnion]).

generate_ts_config(Expiry, UsersFile, Code) :-
    format(atom(Code), '// ============================================================================
// Configuration
// ============================================================================

const JWT_SECRET = process.env.JWT_SECRET || \'change-this-in-production\';
const TOKEN_EXPIRY = ~w; // seconds
const USERS_FILE = process.env.USERS_FILE || \'~w\';', [Expiry, UsersFile]).

generate_ts_exports(Code) :-
    Code = '// ============================================================================
// Exports
// ============================================================================

export {
  login,
  verifyToken,
  getUserFromToken,
  hasRole,
  canAccessShell,
  canExecuteCommands,
  canBrowse,
  hashPassword,
  verifyPassword,
  createToken,
  ensureDefaultUsers
};'.

generate_ts_default_users([], Code) :-
    Code = '// No default users configured
function ensureDefaultUsers(): void {
  // Add default users here if needed
}'.

generate_ts_default_users(Users, Code) :-
    Users \= [],
    users_to_ts_array(Users, UsersArray),
    format(atom(Code), '// ============================================================================
// Default Users
// ============================================================================

const DEFAULT_USERS: { email: string; password: string; roles: Role[] }[] = ~w;

function ensureDefaultUsers(): void {
  for (const user of DEFAULT_USERS) {
    if (!userExists(user.email)) {
      const hash = hashPassword(user.password);
      saveUser(user.email, hash, user.roles, [\'read\']);
      console.log(`Created default user: ${user.email}`);
    }
  }
}', [UsersArray]).

users_to_ts_array(Users, Array) :-
    maplist(user_to_ts_object, Users, Objects),
    atomic_list_concat(Objects, ',\n  ', ObjectsStr),
    format(atom(Array), '[\n  ~w\n]', [ObjectsStr]).

user_to_ts_object(user(Email, Password, Roles), Object) :-
    roles_to_ts_array(Roles, RolesArray),
    format(atom(Object), '{ email: \'~w\', password: \'~w\', roles: ~w }', [Email, Password, RolesArray]).

roles_to_ts_array(Roles, Array) :-
    maplist(role_to_ts_string, Roles, Strings),
    atomic_list_concat(Strings, ', ', StringsJoined),
    format(atom(Array), '[~w]', [StringsJoined]).

role_to_ts_string(Role, String) :-
    format(atom(String), '\'~w\'', [Role]).

%% ============================================================================
%% PASSWORD FUNCTIONS GENERATION
%% ============================================================================

%! generate_password_functions(+HashAlgo, +Target, -Code) is det
%
%  Generate password hashing and verification functions.
%
generate_password_functions(sha256, typescript, Code) :-
    Code = '// ============================================================================
// Password Hashing (SHA256 + Salt)
// ============================================================================

function hashPassword(password: string): string {
  const salt = crypto.randomBytes(16).toString(\'hex\');
  const hash = crypto.createHash(\'sha256\').update(password + salt).digest(\'hex\');
  return `sha256:${salt}:${hash}`;
}

function verifyPassword(password: string, storedHash: string): boolean {
  if (storedHash.startsWith(\'sha256:\')) {
    const [, salt, hash] = storedHash.split(\':\');
    const testHash = crypto.createHash(\'sha256\').update(password + salt).digest(\'hex\');
    return hash === testHash;
  }
  // Fallback for plain passwords (development only)
  return password === storedHash;
}'.

generate_password_functions(bcrypt, typescript, Code) :-
    Code = '// ============================================================================
// Password Hashing (bcrypt-compatible with SHA256 fallback)
// ============================================================================

let bcryptAvailable = false;
let bcrypt: any;
try {
  bcrypt = require(\'bcrypt\');
  bcryptAvailable = true;
} catch {
  console.log(\'bcrypt not available, using SHA256 fallback\');
}

function hashPassword(password: string): string {
  if (bcryptAvailable) {
    return bcrypt.hashSync(password, 12);
  }
  // SHA256 fallback
  const salt = crypto.randomBytes(16).toString(\'hex\');
  const hash = crypto.createHash(\'sha256\').update(password + salt).digest(\'hex\');
  return `sha256:${salt}:${hash}`;
}

function verifyPassword(password: string, storedHash: string): boolean {
  if (bcryptAvailable && storedHash.startsWith(\'$2\')) {
    try {
      return bcrypt.compareSync(password, storedHash);
    } catch {
      return false;
    }
  }
  if (storedHash.startsWith(\'sha256:\')) {
    const [, salt, hash] = storedHash.split(\':\');
    const testHash = crypto.createHash(\'sha256\').update(password + salt).digest(\'hex\');
    return hash === testHash;
  }
  // Fallback for plain passwords (development only)
  return password === storedHash;
}'.

generate_password_functions(plain, typescript, Code) :-
    Code = '// ============================================================================
// Password Hashing (PLAIN - DEVELOPMENT ONLY)
// ============================================================================

function hashPassword(password: string): string {
  console.warn(\'WARNING: Using plain text passwords - for development only!\');
  return password;
}

function verifyPassword(password: string, storedHash: string): boolean {
  return password === storedHash;
}'.

%% ============================================================================
%% JWT FUNCTIONS GENERATION
%% ============================================================================

%! generate_jwt_functions(+Target, -Code) is det
%
%  Generate JWT creation and verification functions.
%
generate_jwt_functions(typescript, Code) :-
    Code = '// ============================================================================
// JWT Token Functions
// ============================================================================

function base64UrlEncode(data: object): string {
  return Buffer.from(JSON.stringify(data))
    .toString(\'base64\')
    .replace(/=/g, \'\')
    .replace(/\\+/g, \'-\')
    .replace(/\\//g, \'_\');
}

function base64UrlDecode(str: string): any {
  let s = str.replace(/-/g, \'+\').replace(/_/g, \'/\');
  while (s.length % 4) s += \'=\';
  return JSON.parse(Buffer.from(s, \'base64\').toString());
}

function createToken(payload: Omit<TokenPayload, \'iat\' | \'exp\'>): string {
  const header = { alg: \'HS256\', typ: \'JWT\' };
  const now = Math.floor(Date.now() / 1000);
  const tokenPayload: TokenPayload = {
    ...payload,
    iat: now,
    exp: now + TOKEN_EXPIRY
  };

  const headerB64 = base64UrlEncode(header);
  const payloadB64 = base64UrlEncode(tokenPayload);
  const signature = crypto
    .createHmac(\'sha256\', JWT_SECRET)
    .update(`${headerB64}.${payloadB64}`)
    .digest(\'base64\')
    .replace(/=/g, \'\')
    .replace(/\\+/g, \'-\')
    .replace(/\\//g, \'_\');

  return `${headerB64}.${payloadB64}.${signature}`;
}

function verifyToken(token: string): TokenPayload | null {
  try {
    const [headerB64, payloadB64, signature] = token.split(\'.\');

    const expectedSig = crypto
      .createHmac(\'sha256\', JWT_SECRET)
      .update(`${headerB64}.${payloadB64}`)
      .digest(\'base64\')
      .replace(/=/g, \'\')
      .replace(/\\+/g, \'-\')
      .replace(/\\//g, \'_\');

    if (signature !== expectedSig) {
      return null;
    }

    const payload = base64UrlDecode(payloadB64) as TokenPayload;

    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {
      return null; // Token expired
    }

    return payload;
  } catch {
    return null;
  }
}

function getUserFromToken(token: string): Omit<User, \'passwordHash\'> | null {
  const payload = verifyToken(token);
  if (!payload) return null;
  return {
    email: payload.email,
    roles: payload.roles,
    permissions: payload.permissions
  };
}'.

%% ============================================================================
%% ROLE FUNCTIONS GENERATION
%% ============================================================================

%! generate_role_functions(+Roles, +Target, -Code) is det
%
%  Generate role checking functions.
%
generate_role_functions(Roles, typescript, Code) :-
    (   member(shell, Roles) -> ShellCheck = 'payload.roles.includes(\'shell\')' ; ShellCheck = 'false' ),
    (   member(admin, Roles) -> AdminCheck = 'roles.includes(\'admin\')' ; AdminCheck = 'false' ),
    format(atom(Code), '// ============================================================================
// Role Checking Functions
// ============================================================================

function hasRole(payload: TokenPayload | null, role: Role): boolean {
  if (!payload) return false;
  return payload.roles.includes(role);
}

function canAccessShell(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  return ~w;
}

function canExecuteCommands(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  const roles = payload.roles;
  return ~w || ~w;
}

function canBrowse(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  return payload.roles.length > 0; // Any authenticated user
}', [ShellCheck, ShellCheck, AdminCheck]).

%% ============================================================================
%% USER STORAGE GENERATION
%% ============================================================================

%! generate_user_storage(+Backend, +Target, -Code) is det
%
%  Generate user storage functions for the specified backend.
%
generate_user_storage(text_file, typescript, Code) :-
    Code = '// ============================================================================
// User Storage (Text File Backend)
// ============================================================================

function ensureUsersFile(): void {
  const dir = path.dirname(USERS_FILE);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  if (!fs.existsSync(USERS_FILE)) {
    fs.writeFileSync(USERS_FILE, \'# Users file\\n# Format: email:passwordHash:roles:permissions\\n\');
  }
}

function loadUsers(): Map<string, User> {
  ensureUsersFile();
  const users = new Map<string, User>();
  const content = fs.readFileSync(USERS_FILE, \'utf-8\');

  for (const line of content.split(\'\\n\')) {
    if (line.startsWith(\'#\') || !line.trim()) continue;
    const parts = line.split(\':\');
    if (parts.length >= 2) {
      const [email, passwordHash, rolesStr = \'\', permsStr = \'\'] = parts;
      users.set(email.toLowerCase(), {
        email,
        passwordHash,
        roles: rolesStr ? rolesStr.split(\',\').map(r => r.trim()) as Role[] : [\'user\'],
        permissions: permsStr ? permsStr.split(\',\').map(p => p.trim()) : [\'read\']
      });
    }
  }

  return users;
}

function saveUser(email: string, passwordHash: string, roles: Role[], permissions: string[]): void {
  ensureUsersFile();
  const line = `${email}:${passwordHash}:${roles.join(\',\')}:${permissions.join(\',\')}\\n`;
  fs.appendFileSync(USERS_FILE, line);
}

function userExists(email: string): boolean {
  const users = loadUsers();
  return users.has(email.toLowerCase());
}

function login(email: string, password: string): AuthResult {
  const users = loadUsers();
  const user = users.get(email.toLowerCase());

  if (!user) {
    return { success: false, error: \'User not found\' };
  }

  if (!verifyPassword(password, user.passwordHash)) {
    return { success: false, error: \'Invalid password\' };
  }

  const token = createToken({
    sub: user.email,
    email: user.email,
    roles: user.roles,
    permissions: user.permissions
  });

  return {
    success: true,
    token,
    user: {
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
  };
}'.

generate_user_storage(memory, typescript, Code) :-
    Code = '// ============================================================================
// User Storage (In-Memory Backend - Development Only)
// ============================================================================

const memoryUsers = new Map<string, User>();

function loadUsers(): Map<string, User> {
  return memoryUsers;
}

function saveUser(email: string, passwordHash: string, roles: Role[], permissions: string[]): void {
  memoryUsers.set(email.toLowerCase(), {
    email,
    passwordHash,
    roles,
    permissions
  });
}

function userExists(email: string): boolean {
  return memoryUsers.has(email.toLowerCase());
}

function login(email: string, password: string): AuthResult {
  const user = memoryUsers.get(email.toLowerCase());

  if (!user) {
    return { success: false, error: \'User not found\' };
  }

  if (!verifyPassword(password, user.passwordHash)) {
    return { success: false, error: \'Invalid password\' };
  }

  const token = createToken({
    sub: user.email,
    email: user.email,
    roles: user.roles,
    permissions: user.permissions
  });

  return {
    success: true,
    token,
    user: {
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
  };
}'.
