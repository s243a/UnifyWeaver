% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% d3_renderer.pl - D3.js Mind Map Renderer
%
% Generates D3.js-based interactive mind map visualizations.
% Supports force simulation, drag, zoom, pan, and animations.
%
% Usage:
%   ?- render_d3(Nodes, Edges, Options, D3Code).

:- module(mindmap_render_d3, [
    type_info/1,
    validate_config/1,
    init_component/2,
    compile_component/4,
    render/3,
    render_d3/5,
    render_d3/4,
    render_d3_react/5,
    test_d3_renderer/0
]).

:- use_module('../core/component_registry').
:- use_module(library(lists)).

% ============================================================================
% COMPONENT TYPE INTERFACE
% ============================================================================

type_info(info(
    name('D3.js Mind Map Renderer'),
    version('1.0.0'),
    description('Generates interactive D3.js mind map visualizations'),
    category(mindmap_renderer)
)).

validate_config(Config) :-
    (   member(output_format(Format), Config)
    ->  member(Format, [vanilla, react, vue])
    ;   true
    ).

init_component(Name, _Config) :-
    format('Initialized D3 renderer: ~w~n', [Name]).

compile_component(Name, Config, Options, Code) :-
    render(Name, Config, Graph),
    (   member(output_format(react), Options)
    ->  render_d3_react(Graph, [], [], Options, Code)
    ;   render_d3(Graph, [], [], Options, Code)
    ).

render(_Name, Config, Graph) :-
    (   member(graph(Graph), Config)
    ->  true
    ;   Graph = graph([], [], [])
    ).

% ============================================================================
% D3.JS RENDERING
% ============================================================================

%% render_d3(+Nodes, +Edges, +Positions, +Options, -D3Code)
%
%  Generate D3.js code for mind map visualization.
%
render_d3(Nodes, Edges, Positions, Options, D3Code) :-
    option_value(Options, container_id, 'mindmap-container', ContainerId),
    option_value(Options, width, 800, Width),
    option_value(Options, height, 600, Height),
    option_value(Options, theme, light, Theme),
    option_value(Options, force_simulation, true, UseForce),
    option_value(Options, zoom_enabled, true, ZoomEnabled),
    option_value(Options, drag_enabled, true, DragEnabled),

    % Generate node/edge data
    generate_data_section(Nodes, Edges, Positions, DataSection),

    % Generate theme colors
    generate_theme_colors(Theme, ThemeColors),

    % Generate force simulation if enabled
    (   UseForce == true
    ->  generate_force_simulation(ForceSection)
    ;   ForceSection = ""
    ),

    % Generate zoom/pan handlers
    (   ZoomEnabled == true
    ->  generate_zoom_handler(ZoomSection)
    ;   ZoomSection = ""
    ),

    % Generate drag handlers
    (   DragEnabled == true
    ->  generate_drag_handlers(DragSection)
    ;   DragSection = ""
    ),

    % Generate main visualization code
    generate_main_viz(ContainerId, Width, Height, MainViz),

    % Generate tooltip
    generate_tooltip_section(TooltipSection),

    % Combine all sections
    format(string(D3Code),
"// D3.js Mind Map Visualization
// Generated by UnifyWeaver

~w

~w

(function() {
    const container = d3.select('#~w');

    // Clear previous content
    container.selectAll('*').remove();

    // Create SVG
    const svg = container.append('svg')
        .attr('width', ~w)
        .attr('height', ~w)
        .attr('viewBox', [0, 0, ~w, ~w]);

    // Create main group for transformations
    const g = svg.append('g')
        .attr('class', 'mindmap-content');

~w
~w
~w
~w
~w
})();
", [DataSection, ThemeColors, ContainerId, Width, Height, Width, Height,
    ZoomSection, ForceSection, MainViz, DragSection, TooltipSection]).

%% render_d3(+Graph, +Options, -D3Code)
render_d3(graph(Nodes, Edges, _Props), Options, D3Code) :-
    render_d3(Nodes, Edges, [], Options, D3Code).

% ============================================================================
% DATA GENERATION
% ============================================================================

generate_data_section(Nodes, Edges, Positions, DataSection) :-
    generate_nodes_json(Nodes, Positions, NodesJson),
    generate_edges_json(Edges, EdgesJson),
    format(string(DataSection),
"const nodes = ~w;

const links = ~w;
", [NodesJson, EdgesJson]).

generate_nodes_json([], _, "[]").
generate_nodes_json(Nodes, Positions, Json) :-
    maplist(node_to_json(Positions), Nodes, NodeJsons),
    atomic_list_concat(NodeJsons, ',\n    ', NodesConcat),
    format(string(Json), "[\n    ~w\n]", [NodesConcat]).

node_to_json(Positions, node(Id, Props), Json) :-
    atom_string(Id, IdStr),
    (   member(label(Label), Props)
    ->  (atom(Label) -> atom_string(Label, LabelStr) ; LabelStr = Label)
    ;   LabelStr = IdStr
    ),
    (   member(type(Type), Props)
    ->  atom_string(Type, TypeStr)
    ;   TypeStr = "default"
    ),
    (   member(link(URL), Props)
    ->  format(string(UrlPart), ", url: \"~w\"", [URL])
    ;   UrlPart = ""
    ),
    (   member((Id, X, Y), Positions)
    ->  format(string(PosPart), ", fx: ~2f, fy: ~2f", [X, Y])
    ;   PosPart = ""
    ),
    format(string(Json),
        "{ id: \"~w\", label: \"~w\", type: \"~w\"~w~w }",
        [IdStr, LabelStr, TypeStr, UrlPart, PosPart]).

generate_edges_json([], "[]").
generate_edges_json(Edges, Json) :-
    maplist(edge_to_json, Edges, EdgeJsons),
    atomic_list_concat(EdgeJsons, ',\n    ', EdgesConcat),
    format(string(Json), "[\n    ~w\n]", [EdgesConcat]).

edge_to_json(edge(From, To, Props), Json) :-
    atom_string(From, FromStr),
    atom_string(To, ToStr),
    (   member(type(Type), Props)
    ->  atom_string(Type, TypeStr)
    ;   TypeStr = "default"
    ),
    format(string(Json),
        "{ source: \"~w\", target: \"~w\", type: \"~w\" }",
        [FromStr, ToStr, TypeStr]).

% ============================================================================
% THEME COLORS
% ============================================================================

generate_theme_colors(light, Colors) :-
    Colors = "const theme = {
    background: '#ffffff',
    nodeColors: {
        default: { fill: '#e8f4fc', stroke: '#4a90d9', text: '#333333' },
        root: { fill: '#4a90d9', stroke: '#2c5a8c', text: '#ffffff' },
        hub: { fill: '#6ab04c', stroke: '#4a904c', text: '#ffffff' },
        branch: { fill: '#f0932b', stroke: '#c07020', text: '#ffffff' },
        leaf: { fill: '#eb4d4b', stroke: '#cb2d2b', text: '#ffffff' }
    },
    edgeColor: '#666666',
    tooltipBg: 'rgba(0, 0, 0, 0.85)',
    tooltipText: '#ffffff'
};".

generate_theme_colors(dark, Colors) :-
    Colors = "const theme = {
    background: '#1a1a2e',
    nodeColors: {
        default: { fill: '#2d3748', stroke: '#4a9ce9', text: '#e2e8f0' },
        root: { fill: '#5a9ce9', stroke: '#3c6a9c', text: '#ffffff' },
        hub: { fill: '#7ac05c', stroke: '#5aa05c', text: '#ffffff' },
        branch: { fill: '#ffaa4b', stroke: '#d08030', text: '#000000' },
        leaf: { fill: '#fb5d5b', stroke: '#db3d3b', text: '#ffffff' }
    },
    edgeColor: '#718096',
    tooltipBg: 'rgba(45, 55, 72, 0.95)',
    tooltipText: '#e2e8f0'
};".

generate_theme_colors(_, Colors) :-
    generate_theme_colors(light, Colors).

% ============================================================================
% FORCE SIMULATION
% ============================================================================

generate_force_simulation(ForceSection) :-
    ForceSection = "
    // Force simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(100))
        .force('charge', d3.forceManyBody().strength(-300))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force('collision', d3.forceCollide().radius(50));

    simulation.on('tick', () => {
        link
            .attr('x1', d => d.source.x)
            .attr('y1', d => d.source.y)
            .attr('x2', d => d.target.x)
            .attr('y2', d => d.target.y);

        node.attr('transform', d => `translate(${d.x},${d.y})`);
    });
".

% ============================================================================
% ZOOM HANDLER
% ============================================================================

generate_zoom_handler(ZoomSection) :-
    ZoomSection = "
    // Zoom behavior
    const zoom = d3.zoom()
        .scaleExtent([0.1, 5])
        .on('zoom', (event) => {
            g.attr('transform', event.transform);
        });

    svg.call(zoom);

    // Zoom controls
    const zoomIn = () => svg.transition().call(zoom.scaleBy, 1.3);
    const zoomOut = () => svg.transition().call(zoom.scaleBy, 0.7);
    const zoomReset = () => svg.transition().call(zoom.transform, d3.zoomIdentity);
    const zoomFit = () => {
        const bounds = g.node().getBBox();
        const scale = Math.min(width / bounds.width, height / bounds.height) * 0.9;
        const tx = (width - bounds.width * scale) / 2 - bounds.x * scale;
        const ty = (height - bounds.height * scale) / 2 - bounds.y * scale;
        svg.transition().call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
    };
".

% ============================================================================
% DRAG HANDLERS
% ============================================================================

generate_drag_handlers(DragSection) :-
    DragSection = "
    // Drag behavior
    const drag = d3.drag()
        .on('start', (event, d) => {
            if (!event.active && simulation) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        })
        .on('drag', (event, d) => {
            d.fx = event.x;
            d.fy = event.y;
        })
        .on('end', (event, d) => {
            if (!event.active && simulation) simulation.alphaTarget(0);
            // Optionally release: d.fx = null; d.fy = null;
        });

    node.call(drag);
".

% ============================================================================
% MAIN VISUALIZATION
% ============================================================================

generate_main_viz(ContainerId, Width, Height, MainViz) :-
    format(string(MainViz),
"
    const width = ~w;
    const height = ~w;

    // Draw links
    const link = g.append('g')
        .attr('class', 'links')
        .selectAll('line')
        .data(links)
        .join('line')
        .attr('stroke', d => {
            if (d.type === 'strong') return '#333333';
            if (d.type === 'weak') return '#aaaaaa';
            return theme.edgeColor;
        })
        .attr('stroke-width', d => d.type === 'strong' ? 3 : 2)
        .attr('stroke-dasharray', d => d.type === 'weak' ? '5,5' : null);

    // Draw nodes
    const node = g.append('g')
        .attr('class', 'nodes')
        .selectAll('g')
        .data(nodes)
        .join('g')
        .attr('class', 'node')
        .style('cursor', d => d.url ? 'pointer' : 'default');

    // Node shapes
    node.append('ellipse')
        .attr('rx', 40)
        .attr('ry', 25)
        .attr('fill', d => theme.nodeColors[d.type]?.fill || theme.nodeColors.default.fill)
        .attr('stroke', d => theme.nodeColors[d.type]?.stroke || theme.nodeColors.default.stroke)
        .attr('stroke-width', d => d.type === 'root' ? 3 : 2);

    // Node labels
    node.append('text')
        .attr('text-anchor', 'middle')
        .attr('dominant-baseline', 'central')
        .attr('fill', d => theme.nodeColors[d.type]?.text || theme.nodeColors.default.text)
        .attr('font-size', d => d.type === 'root' ? 14 : 12)
        .attr('font-weight', d => d.type === 'root' ? 'bold' : 'normal')
        .text(d => d.label);

    // Link icon for nodes with URLs
    node.filter(d => d.url)
        .append('text')
        .attr('x', 30)
        .attr('y', -15)
        .attr('font-size', 10)
        .attr('fill', '#666')
        .text('ðŸ”—');

    // Click handler for links
    node.on('click', (event, d) => {
        if (d.url) {
            window.open(d.url, '_blank');
        }
    });
", [Width, Height]).

% ============================================================================
% TOOLTIP
% ============================================================================

generate_tooltip_section(TooltipSection) :-
    TooltipSection = "
    // Tooltip
    const tooltip = d3.select('body').append('div')
        .attr('class', 'mindmap-tooltip')
        .style('position', 'absolute')
        .style('visibility', 'hidden')
        .style('background', theme.tooltipBg)
        .style('color', theme.tooltipText)
        .style('padding', '8px 12px')
        .style('border-radius', '4px')
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('z-index', 1000);

    node
        .on('mouseenter', (event, d) => {
            tooltip
                .style('visibility', 'visible')
                .html(`<strong>${d.label}</strong>${d.url ? '<br/>Click to open link' : ''}`);
        })
        .on('mousemove', (event) => {
            tooltip
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY + 10) + 'px');
        })
        .on('mouseleave', () => {
            tooltip.style('visibility', 'hidden');
        });
".

% ============================================================================
% REACT COMPONENT GENERATION
% ============================================================================

%% render_d3_react(+Nodes, +Edges, +Positions, +Options, -ReactCode)
%
%  Generate a React component with D3.js mind map.
%
render_d3_react(Nodes, Edges, Positions, Options, ReactCode) :-
    option_value(Options, component_name, 'MindMapD3', ComponentName),
    option_value(Options, width, 800, Width),
    option_value(Options, height, 600, Height),

    generate_nodes_json(Nodes, Positions, NodesJson),
    generate_edges_json(Edges, EdgesJson),

    format(string(ReactCode),
"import React, { useRef, useEffect, useState } from 'react';
import * as d3 from 'd3';

interface Node {
    id: string;
    label: string;
    type: string;
    url?: string;
    x?: number;
    y?: number;
    fx?: number | null;
    fy?: number | null;
}

interface Link {
    source: string | Node;
    target: string | Node;
    type: string;
}

interface ~wProps {
    width?: number;
    height?: number;
    theme?: 'light' | 'dark';
    onNodeClick?: (node: Node) => void;
}

const initialNodes: Node[] = ~w;
const initialLinks: Link[] = ~w;

export const ~w: React.FC<~wProps> = ({
    width = ~w,
    height = ~w,
    theme = 'light',
    onNodeClick
}) => {
    const svgRef = useRef<SVGSVGElement>(null);
    const [nodes] = useState<Node[]>(initialNodes);
    const [links] = useState<Link[]>(initialLinks);

    const themeColors = {
        light: {
            background: '#ffffff',
            nodeColors: {
                default: { fill: '#e8f4fc', stroke: '#4a90d9', text: '#333333' },
                root: { fill: '#4a90d9', stroke: '#2c5a8c', text: '#ffffff' },
                hub: { fill: '#6ab04c', stroke: '#4a904c', text: '#ffffff' },
                branch: { fill: '#f0932b', stroke: '#c07020', text: '#ffffff' },
                leaf: { fill: '#eb4d4b', stroke: '#cb2d2b', text: '#ffffff' }
            },
            edgeColor: '#666666'
        },
        dark: {
            background: '#1a1a2e',
            nodeColors: {
                default: { fill: '#2d3748', stroke: '#4a9ce9', text: '#e2e8f0' },
                root: { fill: '#5a9ce9', stroke: '#3c6a9c', text: '#ffffff' },
                hub: { fill: '#7ac05c', stroke: '#5aa05c', text: '#ffffff' },
                branch: { fill: '#ffaa4b', stroke: '#d08030', text: '#000000' },
                leaf: { fill: '#fb5d5b', stroke: '#db3d3b', text: '#ffffff' }
            },
            edgeColor: '#718096'
        }
    };

    useEffect(() => {
        if (!svgRef.current) return;

        const svg = d3.select(svgRef.current);
        const colors = themeColors[theme];

        // Clear previous
        svg.selectAll('*').remove();

        const g = svg.append('g');

        // Zoom
        const zoom = d3.zoom<SVGSVGElement, unknown>()
            .scaleExtent([0.1, 5])
            .on('zoom', (event) => g.attr('transform', event.transform));

        svg.call(zoom);

        // Force simulation
        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id((d: any) => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force('collision', d3.forceCollide().radius(50));

        // Links
        const link = g.append('g')
            .selectAll('line')
            .data(links)
            .join('line')
            .attr('stroke', colors.edgeColor)
            .attr('stroke-width', 2);

        // Nodes
        const node = g.append('g')
            .selectAll<SVGGElement, Node>('g')
            .data(nodes)
            .join('g')
            .style('cursor', d => d.url ? 'pointer' : 'default')
            .call(d3.drag<SVGGElement, Node>()
                .on('start', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0.3).restart();
                    d.fx = d.x;
                    d.fy = d.y;
                })
                .on('drag', (event, d) => {
                    d.fx = event.x;
                    d.fy = event.y;
                })
                .on('end', (event, d) => {
                    if (!event.active) simulation.alphaTarget(0);
                })
            );

        node.append('ellipse')
            .attr('rx', 40)
            .attr('ry', 25)
            .attr('fill', d => colors.nodeColors[d.type as keyof typeof colors.nodeColors]?.fill || colors.nodeColors.default.fill)
            .attr('stroke', d => colors.nodeColors[d.type as keyof typeof colors.nodeColors]?.stroke || colors.nodeColors.default.stroke)
            .attr('stroke-width', d => d.type === 'root' ? 3 : 2);

        node.append('text')
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'central')
            .attr('fill', d => colors.nodeColors[d.type as keyof typeof colors.nodeColors]?.text || colors.nodeColors.default.text)
            .text(d => d.label);

        node.on('click', (event, d) => {
            if (onNodeClick) onNodeClick(d);
            else if (d.url) window.open(d.url, '_blank');
        });

        simulation.on('tick', () => {
            link
                .attr('x1', (d: any) => d.source.x)
                .attr('y1', (d: any) => d.source.y)
                .attr('x2', (d: any) => d.target.x)
                .attr('y2', (d: any) => d.target.y);
            node.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        return () => { simulation.stop(); };
    }, [nodes, links, width, height, theme, onNodeClick]);

    return (
        <svg
            ref={svgRef}
            width={width}
            height={height}
            style={{ background: themeColors[theme].background }}
        />
    );
};

export default ~w;
", [ComponentName, NodesJson, EdgesJson, ComponentName, ComponentName,
    Width, Height, ComponentName]).

% ============================================================================
% UTILITIES
% ============================================================================

option_value(Options, Key, Default, Value) :-
    Opt =.. [Key, Value],
    (   member(Opt, Options)
    ->  true
    ;   Value = Default
    ).

% ============================================================================
% TESTING
% ============================================================================

test_d3_renderer :-
    format('~n=== D3.js Renderer Tests ===~n~n'),

    % Test 1: Basic rendering
    format('Test 1: Basic D3 rendering...~n'),
    TestNodes = [
        node(root, [label("Main Topic"), type(root)]),
        node(child1, [label("Child 1"), type(branch)]),
        node(child2, [label("Child 2"), type(leaf), link("https://example.com")])
    ],
    TestEdges = [
        edge(root, child1, []),
        edge(root, child2, [])
    ],
    render_d3(TestNodes, TestEdges, [], [], D3Code),
    (   sub_string(D3Code, _, _, _, "const nodes")
    ->  format('  PASS: D3 code generated~n')
    ;   format('  FAIL: D3 code missing nodes~n')
    ),

    % Test 2: Dark theme
    format('~nTest 2: Dark theme...~n'),
    render_d3(TestNodes, TestEdges, [], [theme(dark)], DarkCode),
    (   sub_string(DarkCode, _, _, _, "#1a1a2e")
    ->  format('  PASS: Dark theme colors applied~n')
    ;   format('  FAIL: Dark theme not applied~n')
    ),

    % Test 3: React component
    format('~nTest 3: React component generation...~n'),
    render_d3_react(TestNodes, TestEdges, [], [component_name('TestMindMap')], ReactCode),
    (   sub_string(ReactCode, _, _, _, "export const TestMindMap")
    ->  format('  PASS: React component generated~n')
    ;   format('  FAIL: React component incorrect~n')
    ),

    format('~n=== Tests Complete ===~n').

% ============================================================================
% REGISTRATION
% ============================================================================

:- initialization((
    register_component_type(mindmap_renderer, d3, mindmap_render_d3, [
        description("D3.js Interactive Mind Map Renderer")
    ]),
    format('D3 renderer module loaded~n', [])
), now).
