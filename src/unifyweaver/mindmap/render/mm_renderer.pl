% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% mm_renderer.pl - FreeMind/Freeplane (.mm) Renderer for Mind Maps
%
% Generates FreeMind XML format (.mm) for desktop mind mapping applications.
% Compatible with:
% - FreeMind (free, open source)
% - Freeplane (FreeMind fork with more features)
% - Mind42 (online import)
% - Various mobile apps
%
% Usage:
%   ?- render_mm(Nodes, Edges, Positions, Options, XML).

:- module(mindmap_render_mm, [
    % Component interface
    type_info/1,
    validate_config/1,
    init_component/2,
    compile_component/4,
    render/3,

    % Direct API
    render_mm/5,                    % render_mm(+Nodes, +Edges, +Positions, +Options, -XML)
    render_mm/4,                    % render_mm(+Nodes, +Edges, +Options, -XML)

    % Testing
    test_mm_renderer/0
]).

:- use_module(library(lists)).

% ============================================================================
% COMPONENT INTERFACE
% ============================================================================

type_info(info{
    name: mm,
    category: mindmap_renderer,
    description: "FreeMind/Freeplane .mm format",
    version: "1.0.0",
    file_extension: ".mm",
    mime_type: "application/x-freemind",
    parameters: [
        include_positions - "Include node positions (default false)",
        include_icons - "Include node icons based on type (default true)",
        include_urls - "Include URLs as attributes (default true)",
        fold_depth - "Auto-fold nodes deeper than this (default 0 = no folding)"
    ]
}).

validate_config(Config) :-
    is_list(Config).

init_component(_Name, _Config).

compile_component(_Name, _Config, _Options, '<!-- FreeMind template -->').

render(render_data(Nodes, Edges, Positions, _Styles), Options, Output) :-
    render_mm(Nodes, Edges, Positions, Options, Output).

% ============================================================================
% MM RENDERING
% ============================================================================

%% render_mm(+Nodes, +Edges, +Positions, +Options, -XML)
%
%  Render mind map to FreeMind .mm format.
%
render_mm(Nodes, Edges, Positions, Options, XML) :-
    % Build tree structure from flat nodes/edges
    build_tree_structure(Nodes, Edges, Tree),

    % Build position lookup
    build_position_lookup(Positions, PosLookup),

    % Get root node
    Tree = tree(RootId, RootChildren),

    % Find root node data
    (   member(node(RootId, RootProps), Nodes)
    ->  true
    ;   RootProps = []
    ),

    % Render tree recursively
    render_node_mm(RootId, RootProps, RootChildren, Nodes, PosLookup, Options, 0, RootContent),

    % Assemble XML document
    format(atom(XML),
'<?xml version="1.0" encoding="UTF-8"?>
<map version="1.0.1">
<!-- Generated by UnifyWeaver mindmap_render_mm -->
~w</map>
', [RootContent]).

%% render_mm(+Nodes, +Edges, +Options, -XML)
%
%  Render without positions.
%
render_mm(Nodes, Edges, Options, XML) :-
    render_mm(Nodes, Edges, [], Options, XML).

% ============================================================================
% TREE BUILDING
% ============================================================================

%% build_tree_structure(+Nodes, +Edges, -Tree)
%
%  Build hierarchical tree from flat node/edge lists.
%  Tree = tree(RootId, Children) where Children = [tree(Id, SubChildren), ...]
%
build_tree_structure(Nodes, Edges, Tree) :-
    % Find root (node with no incoming edges)
    find_root_node(Nodes, Edges, RootId),

    % Build children map
    build_children_map(Edges, ChildrenMap),

    % Build tree recursively
    build_subtree(RootId, ChildrenMap, Tree).

find_root_node(Nodes, Edges, RootId) :-
    % First try: node with type(root)
    (   member(node(RootId, Props), Nodes),
        member(type(root), Props)
    ->  true
    ;   % Second try: node with no incoming edges
        member(node(RootId, _), Nodes),
        \+ member(edge(_, RootId, _), Edges)
    ->  true
    ;   % Fallback: first node
        Nodes = [node(RootId, _) | _]
    ).

build_children_map(Edges, ChildrenMap) :-
    findall(Parent-Child, member(edge(Parent, Child, _), Edges), Pairs),
    group_pairs_by_key(Pairs, ChildrenMap).

group_pairs_by_key([], []).
group_pairs_by_key([K-V | Rest], Grouped) :-
    partition_key(K, Rest, Vs, OtherPairs),
    group_pairs_by_key(OtherPairs, RestGrouped),
    Grouped = [K-[V|Vs] | RestGrouped].

partition_key(_, [], [], []).
partition_key(K, [K-V | Rest], [V | Vs], Others) :-
    !,
    partition_key(K, Rest, Vs, Others).
partition_key(K, [Other | Rest], Vs, [Other | Others]) :-
    partition_key(K, Rest, Vs, Others).

build_subtree(NodeId, ChildrenMap, tree(NodeId, ChildTrees)) :-
    (   member(NodeId-Children, ChildrenMap)
    ->  maplist(build_subtree_helper(ChildrenMap), Children, ChildTrees)
    ;   ChildTrees = []
    ).

build_subtree_helper(ChildrenMap, ChildId, ChildTree) :-
    build_subtree(ChildId, ChildrenMap, ChildTree).

% ============================================================================
% NODE RENDERING
% ============================================================================

%% render_node_mm(+Id, +Props, +Children, +AllNodes, +PosLookup, +Options, +Depth, -XML)
%
%  Render a single node and its children recursively.
%
render_node_mm(Id, Props, Children, AllNodes, PosLookup, Options, Depth, XML) :-
    % Get label
    (member(label(Label), Props) -> true ; atom_string(Id, Label)),
    escape_xml_attr(Label, EscapedLabel),

    % Position attribute (for first-level children in FreeMind)
    (   Depth =:= 1
    ->  (   get_position(Id, PosLookup, X, _),
            X \== none
        ->  (   X > 500
            ->  PosAttr = ' POSITION="right"'
            ;   PosAttr = ' POSITION="left"'
            )
        ;   PosAttr = ' POSITION="right"'
        )
    ;   PosAttr = ''
    ),

    % Folded attribute
    option_or_default(fold_depth, Options, 0, FoldDepth),
    (   FoldDepth > 0, Depth >= FoldDepth
    ->  FoldAttr = ' FOLDED="true"'
    ;   FoldAttr = ''
    ),

    % Node styling based on type
    (member(type(NodeType), Props) -> true ; NodeType = default),
    node_mm_style(NodeType, StyleAttrs),

    % URL handling
    option_or_default(include_urls, Options, true, IncludeURLs),
    (   IncludeURLs == true,
        member(link(URL), Props),
        URL \== ''
    ->  escape_xml_attr(URL, EscURL),
        format(atom(URLContent), '~n  <attribute NAME="url" VALUE="~w"/>', [EscURL])
    ;   URLContent = ''
    ),

    % Icon based on type
    option_or_default(include_icons, Options, true, IncludeIcons),
    (   IncludeIcons == true
    ->  node_mm_icon(NodeType, IconContent)
    ;   IconContent = ''
    ),

    % Render children
    NextDepth is Depth + 1,
    render_children_mm(Children, AllNodes, PosLookup, Options, NextDepth, ChildrenContent),

    % Indent
    indent_string(Depth, Indent),

    % Assemble node XML
    (   Children = [], URLContent = '', IconContent = ''
    ->  % Self-closing tag
        format(atom(XML), '~w<node TEXT="~w"~w~w~w/>~n',
               [Indent, EscapedLabel, StyleAttrs, PosAttr, FoldAttr])
    ;   % Node with content
        format(atom(XML), '~w<node TEXT="~w"~w~w~w>~w~w~w~w</node>~n',
               [Indent, EscapedLabel, StyleAttrs, PosAttr, FoldAttr,
                IconContent, URLContent, ChildrenContent, Indent])
    ).

render_children_mm([], _, _, _, _, '').
render_children_mm([tree(ChildId, GrandChildren) | Rest], AllNodes, PosLookup, Options, Depth, Content) :-
    % Find child node props
    (   member(node(ChildId, ChildProps), AllNodes)
    ->  true
    ;   ChildProps = []
    ),
    render_node_mm(ChildId, ChildProps, GrandChildren, AllNodes, PosLookup, Options, Depth, ChildXML),
    render_children_mm(Rest, AllNodes, PosLookup, Options, Depth, RestXML),
    atom_concat(ChildXML, RestXML, Content).

%% node_mm_style(+Type, -StyleAttrs)
%
%  Get FreeMind style attributes for node type.
%
node_mm_style(root, ' BACKGROUND_COLOR="#4a90d9" COLOR="#ffffff"') :- !.
node_mm_style(hub, ' BACKGROUND_COLOR="#6ab04c" COLOR="#ffffff"') :- !.
node_mm_style(branch, ' BACKGROUND_COLOR="#f0932b" COLOR="#ffffff"') :- !.
node_mm_style(leaf, ' BACKGROUND_COLOR="#eb4d4b" COLOR="#ffffff"') :- !.
node_mm_style(_, '').

%% node_mm_icon(+Type, -IconXML)
%
%  Get FreeMind icon for node type.
%
node_mm_icon(root, '\n  <icon BUILTIN="bookmark"/>') :- !.
node_mm_icon(hub, '\n  <icon BUILTIN="folder"/>') :- !.
node_mm_icon(branch, '\n  <icon BUILTIN="forward"/>') :- !.
node_mm_icon(leaf, '\n  <icon BUILTIN="button_ok"/>') :- !.
node_mm_icon(_, '').

% ============================================================================
% UTILITIES
% ============================================================================

build_position_lookup(Positions, Lookup) :-
    findall(Id-pos(X, Y), member(position(Id, X, Y), Positions), Lookup).

get_position(Id, Lookup, X, Y) :-
    member(Id-pos(X, Y), Lookup),
    !.
get_position(_, _, none, none).

option_or_default(Key, Options, Default, Value) :-
    Term =.. [Key, Value],
    (   member(Term, Options)
    ->  true
    ;   Value = Default
    ).

indent_string(Depth, Indent) :-
    N is Depth * 2,
    length(Spaces, N),
    maplist(=(0' ), Spaces),
    atom_codes(Indent, Spaces).

%% escape_xml_attr(+Text, -Escaped)
escape_xml_attr(Text, Escaped) :-
    atom_string(Text, Str),
    escape_xml_chars(Str, EscStr),
    atom_string(Escaped, EscStr).

escape_xml_chars([], []).
escape_xml_chars([C | Rest], Escaped) :-
    escape_xml_char(C, EscC),
    escape_xml_chars(Rest, RestEsc),
    append(EscC, RestEsc, Escaped).

escape_xml_char(0'<, "&lt;") :- !.
escape_xml_char(0'>, "&gt;") :- !.
escape_xml_char(0'&, "&amp;") :- !.
escape_xml_char(0'", "&quot;") :- !.
escape_xml_char(0'', "&apos;") :- !.
escape_xml_char(C, [C]).

% ============================================================================
% TESTING
% ============================================================================

test_mm_renderer :-
    format('~n=== FreeMind Renderer Tests ===~n~n'),

    Nodes = [
        node(root, [label("Central Topic"), type(root)]),
        node(a, [label("Branch A"), type(branch)]),
        node(b, [label("Branch B"), type(branch), link("https://example.com")]),
        node(c, [label("Leaf C"), type(leaf)])
    ],
    Edges = [
        edge(root, a, []),
        edge(root, b, []),
        edge(a, c, [])
    ],
    Positions = [
        position(root, 500, 400),
        position(a, 350, 550),
        position(b, 650, 550),
        position(c, 300, 700)
    ],

    % Test 1: Basic rendering
    format('Test 1: Basic .mm rendering...~n'),
    render_mm(Nodes, Edges, Positions, [], XML),
    (   sub_atom(XML, _, _, _, '<map version')
    ->  format('  PASS: MM document generated~n')
    ;   format('  FAIL: Invalid MM~n')
    ),

    % Test 2: Hierarchical structure
    format('~nTest 2: Hierarchical node structure...~n'),
    (   sub_atom(XML, _, _, _, '<node TEXT="Central Topic"'),
        sub_atom(XML, _, _, _, '<node TEXT="Branch A"')
    ->  format('  PASS: Nodes nested correctly~n')
    ;   format('  FAIL: Structure incorrect~n')
    ),

    % Test 3: URL inclusion
    format('~nTest 3: URL attributes...~n'),
    (   sub_atom(XML, _, _, _, 'NAME="url"')
    ->  format('  PASS: URLs included~n')
    ;   format('  FAIL: URLs missing~n')
    ),

    % Test 4: Position-based layout direction
    format('~nTest 4: Position-based POSITION attributes...~n'),
    (   sub_atom(XML, _, _, _, 'POSITION="left"'),
        sub_atom(XML, _, _, _, 'POSITION="right"')
    ->  format('  PASS: Positions used for layout direction~n')
    ;   format('  INFO: Position attributes may vary~n')
    ),

    % Test 5: Icons
    format('~nTest 5: Node icons...~n'),
    (   sub_atom(XML, _, _, _, '<icon BUILTIN=')
    ->  format('  PASS: Icons included~n')
    ;   format('  FAIL: Icons missing~n')
    ),

    format('~n=== Tests Complete ===~n').

:- initialization((
    format('FreeMind (.mm) renderer module loaded~n', [])
), now).
