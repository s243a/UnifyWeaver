% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% mindmap_viewport.pl - Mind Map Viewport Management
%
% Handles zoom, pan, fit-to-content, and viewport state for mind maps.
% Extends existing zoom/pan patterns from interaction_generator.pl.
%
% Usage:
%   ?- mindmap_zoom_spec(my_map, ZoomSpec).
%   ?- generate_viewport_controls(my_map, Code).

:- module(mindmap_viewport, [
    % Viewport specifications
    mindmap_zoom_spec/2,
    mindmap_pan_spec/2,
    mindmap_viewport_spec/2,

    % Generation predicates
    generate_viewport_controls/2,
    generate_zoom_handler/2,
    generate_pan_handler/2,
    generate_fit_to_content/2,
    generate_viewport_state/2,

    % Management
    declare_viewport_spec/2,
    clear_viewport_specs/0,

    % Queries
    get_zoom_limits/3,
    get_viewport_bounds/2,

    % Testing
    test_mindmap_viewport/0
]).

:- use_module(library(lists)).

% ============================================================================
% DYNAMIC PREDICATES
% ============================================================================

:- dynamic mindmap_zoom_spec/2.
:- dynamic mindmap_pan_spec/2.
:- dynamic mindmap_viewport_spec/2.

% ============================================================================
% DEFAULT ZOOM SPECIFICATIONS
% ============================================================================

mindmap_zoom_spec(default, [
    enabled(true),
    min_scale(0.1),
    max_scale(5.0),
    step(0.1),
    wheel_enabled(true),
    double_click_zoom(true),
    pinch_zoom(true),
    controls([zoom_in, zoom_out, zoom_fit, zoom_reset]),
    animation_duration(300)
]).

mindmap_zoom_spec(limited, [
    enabled(true),
    min_scale(0.5),
    max_scale(2.0),
    step(0.2),
    wheel_enabled(true),
    double_click_zoom(false),
    pinch_zoom(true),
    controls([zoom_in, zoom_out]),
    animation_duration(200)
]).

mindmap_zoom_spec(fixed, [
    enabled(false)
]).

% ============================================================================
% DEFAULT PAN SPECIFICATIONS
% ============================================================================

mindmap_pan_spec(default, [
    enabled(true),
    mode(pan),
    inertia(true),
    inertia_decay(0.95),
    bounds(auto),
    constrain_to_bounds(false)
]).

mindmap_pan_spec(constrained, [
    enabled(true),
    mode(pan),
    inertia(false),
    bounds([0, 0, 1600, 1200]),
    constrain_to_bounds(true),
    padding(50)
]).

mindmap_pan_spec(infinite, [
    enabled(true),
    mode(pan),
    inertia(true),
    inertia_decay(0.9),
    bounds(none),
    constrain_to_bounds(false)
]).

% ============================================================================
% DEFAULT VIEWPORT SPECIFICATIONS
% ============================================================================

mindmap_viewport_spec(default, [
    width(800),
    height(600),
    initial_scale(1.0),
    initial_translate(0, 0),
    center_on_load(true),
    fit_on_load(false),
    preserve_aspect_ratio(true),
    background('#ffffff'),
    show_grid(false),
    grid_size(20),
    grid_color('#f0f0f0')
]).

mindmap_viewport_spec(fullscreen, [
    width('100%'),
    height('100vh'),
    initial_scale(1.0),
    center_on_load(true),
    fit_on_load(true),
    preserve_aspect_ratio(true),
    background('#1a1a2e'),
    show_grid(false)
]).

mindmap_viewport_spec(with_grid, [
    width(1200),
    height(800),
    initial_scale(1.0),
    center_on_load(true),
    fit_on_load(false),
    preserve_aspect_ratio(true),
    background('#ffffff'),
    show_grid(true),
    grid_size(25),
    grid_color('#e8e8e8'),
    snap_to_grid(true)
]).

% ============================================================================
% GENERATION PREDICATES
% ============================================================================

%% generate_viewport_controls(+MapId, -Code)
%
%  Generate complete viewport control code including zoom, pan, and controls.
%
generate_viewport_controls(MapId, Code) :-
    % Get specs
    (   mindmap_zoom_spec(MapId, ZoomOpts)
    ->  true
    ;   mindmap_zoom_spec(default, ZoomOpts)
    ),
    (   mindmap_pan_spec(MapId, PanOpts)
    ->  true
    ;   mindmap_pan_spec(default, PanOpts)
    ),
    (   mindmap_viewport_spec(MapId, ViewportOpts)
    ->  true
    ;   mindmap_viewport_spec(default, ViewportOpts)
    ),

    % Generate sections
    generate_zoom_code(ZoomOpts, ZoomCode),
    generate_pan_code(PanOpts, PanCode),
    generate_viewport_state_code(ViewportOpts, StateCode),
    generate_control_buttons(ZoomOpts, ControlsCode),
    generate_grid_code(ViewportOpts, GridCode),

    format(string(Code),
"// Viewport Controls for: ~w
// Generated by UnifyWeaver

~w

~w

~w

~w

~w
", [MapId, StateCode, ZoomCode, PanCode, GridCode, ControlsCode]).

%% generate_zoom_handler(+MapId, -Handler)
generate_zoom_handler(MapId, Handler) :-
    (   mindmap_zoom_spec(MapId, ZoomOpts)
    ->  true
    ;   mindmap_zoom_spec(default, ZoomOpts)
    ),
    generate_zoom_code(ZoomOpts, Handler).

%% generate_pan_handler(+MapId, -Handler)
generate_pan_handler(MapId, Handler) :-
    (   mindmap_pan_spec(MapId, PanOpts)
    ->  true
    ;   mindmap_pan_spec(default, PanOpts)
    ),
    generate_pan_code(PanOpts, Handler).

%% generate_fit_to_content(+MapId, -Code)
generate_fit_to_content(_MapId, Code) :-
    Code = "
const fitToContent = (padding = 50) => {
    const bounds = contentGroup.node().getBBox();
    if (bounds.width === 0 || bounds.height === 0) return;

    const containerWidth = parseFloat(svg.attr('width'));
    const containerHeight = parseFloat(svg.attr('height'));

    const scale = Math.min(
        (containerWidth - 2 * padding) / bounds.width,
        (containerHeight - 2 * padding) / bounds.height,
        maxScale
    );

    const tx = (containerWidth - bounds.width * scale) / 2 - bounds.x * scale;
    const ty = (containerHeight - bounds.height * scale) / 2 - bounds.y * scale;

    svg.transition()
        .duration(animationDuration)
        .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
};

const centerOnNode = (nodeId, scale = currentScale) => {
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;

    const containerWidth = parseFloat(svg.attr('width'));
    const containerHeight = parseFloat(svg.attr('height'));

    const tx = containerWidth / 2 - node.x * scale;
    const ty = containerHeight / 2 - node.y * scale;

    svg.transition()
        .duration(animationDuration)
        .call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale));
};
".

%% generate_viewport_state(+MapId, -State)
generate_viewport_state(MapId, State) :-
    (   mindmap_viewport_spec(MapId, ViewportOpts)
    ->  true
    ;   mindmap_viewport_spec(default, ViewportOpts)
    ),
    generate_viewport_state_code(ViewportOpts, State).

% ============================================================================
% CODE GENERATION HELPERS
% ============================================================================

generate_zoom_code(ZoomOpts, Code) :-
    (   member(enabled(false), ZoomOpts)
    ->  Code = "// Zoom disabled"
    ;   member(min_scale(MinScale), ZoomOpts),
        member(max_scale(MaxScale), ZoomOpts),
        member(animation_duration(Duration), ZoomOpts),
        (   member(wheel_enabled(true), ZoomOpts)
        ->  WheelFilter = "null"
        ;   WheelFilter = "(event) => false"
        ),
        format(string(Code),
"// Zoom Configuration
const minScale = ~w;
const maxScale = ~w;
const animationDuration = ~w;
let currentScale = 1.0;
let currentTransform = d3.zoomIdentity;

const zoom = d3.zoom()
    .scaleExtent([minScale, maxScale])
    .filter((event) => {
        // Allow wheel zoom unless disabled
        if (event.type === 'wheel') return ~w !== '(event) => false';
        // Allow drag for pan
        if (event.type === 'mousedown') return event.button === 0;
        return true;
    })
    .on('zoom', (event) => {
        currentTransform = event.transform;
        currentScale = event.transform.k;
        contentGroup.attr('transform', event.transform);
        updateZoomIndicator();
    });

svg.call(zoom);

const zoomIn = () => {
    svg.transition()
        .duration(animationDuration)
        .call(zoom.scaleBy, 1.3);
};

const zoomOut = () => {
    svg.transition()
        .duration(animationDuration)
        .call(zoom.scaleBy, 0.7);
};

const zoomReset = () => {
    svg.transition()
        .duration(animationDuration)
        .call(zoom.transform, d3.zoomIdentity);
};

const zoomTo = (scale) => {
    svg.transition()
        .duration(animationDuration)
        .call(zoom.scaleTo, Math.max(minScale, Math.min(maxScale, scale)));
};

const updateZoomIndicator = () => {
    const indicator = document.getElementById('zoom-indicator');
    if (indicator) {
        indicator.textContent = `${Math.round(currentScale * 100)}%`;
    }
};
", [MinScale, MaxScale, Duration, WheelFilter])
    ).

generate_pan_code(PanOpts, Code) :-
    (   member(enabled(false), PanOpts)
    ->  Code = "// Pan disabled"
    ;   (   member(inertia(true), PanOpts),
            member(inertia_decay(Decay), PanOpts)
        ->  InertiaCode = format(string(S),
"
// Inertia
let velocity = { x: 0, y: 0 };
const inertiaDecay = ~w;

const applyInertia = () => {
    if (Math.abs(velocity.x) < 0.1 && Math.abs(velocity.y) < 0.1) return;

    velocity.x *= inertiaDecay;
    velocity.y *= inertiaDecay;

    const newTransform = currentTransform.translate(velocity.x, velocity.y);
    svg.call(zoom.transform, newTransform);

    requestAnimationFrame(applyInertia);
};
", [Decay]), S
        ;   InertiaCode = ""
        ),
        (   member(constrain_to_bounds(true), PanOpts),
            member(bounds([X1, Y1, X2, Y2]), PanOpts)
        ->  format(string(BoundsCode),
"
const constrainPan = (transform) => {
    const bounds = { x1: ~w, y1: ~w, x2: ~w, y2: ~w };
    const width = parseFloat(svg.attr('width'));
    const height = parseFloat(svg.attr('height'));

    let tx = transform.x;
    let ty = transform.y;

    tx = Math.min(0, Math.max(tx, width - bounds.x2 * transform.k));
    ty = Math.min(0, Math.max(ty, height - bounds.y2 * transform.k));

    return d3.zoomIdentity.translate(tx, ty).scale(transform.k);
};
", [X1, Y1, X2, Y2])
        ;   BoundsCode = ""
        ),
        format(string(Code),
"// Pan Configuration
~w
~w
", [InertiaCode, BoundsCode])
    ).

generate_viewport_state_code(ViewportOpts, Code) :-
    member(width(Width), ViewportOpts),
    member(height(Height), ViewportOpts),
    member(initial_scale(InitScale), ViewportOpts),
    (   member(background(BgColor), ViewportOpts)
    ->  true
    ;   BgColor = '#ffffff'
    ),
    format(string(Code),
"// Viewport State
const viewportConfig = {
    width: ~w,
    height: ~w,
    initialScale: ~w,
    background: '~w'
};

let contentGroup;

const initViewport = (svgElement) => {
    svg = d3.select(svgElement);
    svg.style('background', viewportConfig.background);
    contentGroup = svg.append('g').attr('class', 'mindmap-content');
    return contentGroup;
};

const getViewportBounds = () => {
    const transform = currentTransform;
    const width = parseFloat(svg.attr('width'));
    const height = parseFloat(svg.attr('height'));

    return {
        x: -transform.x / transform.k,
        y: -transform.y / transform.k,
        width: width / transform.k,
        height: height / transform.k
    };
};

const isNodeVisible = (node) => {
    const bounds = getViewportBounds();
    return node.x >= bounds.x - 50 &&
           node.x <= bounds.x + bounds.width + 50 &&
           node.y >= bounds.y - 50 &&
           node.y <= bounds.y + bounds.height + 50;
};
", [Width, Height, InitScale, BgColor]).

generate_grid_code(ViewportOpts, Code) :-
    (   member(show_grid(true), ViewportOpts),
        member(grid_size(GridSize), ViewportOpts),
        member(grid_color(GridColor), ViewportOpts)
    ->  format(string(Code),
"// Grid
const gridSize = ~w;
const gridColor = '~w';

const drawGrid = () => {
    const width = parseFloat(svg.attr('width'));
    const height = parseFloat(svg.attr('height'));

    const gridGroup = svg.insert('g', ':first-child')
        .attr('class', 'grid');

    // Vertical lines
    for (let x = 0; x <= width; x += gridSize) {
        gridGroup.append('line')
            .attr('x1', x).attr('y1', 0)
            .attr('x2', x).attr('y2', height)
            .attr('stroke', gridColor)
            .attr('stroke-width', 0.5);
    }

    // Horizontal lines
    for (let y = 0; y <= height; y += gridSize) {
        gridGroup.append('line')
            .attr('x1', 0).attr('y1', y)
            .attr('x2', width).attr('y2', y)
            .attr('stroke', gridColor)
            .attr('stroke-width', 0.5);
    }
};

const snapToGrid = (value) => Math.round(value / gridSize) * gridSize;
", [GridSize, GridColor])
    ;   Code = "// Grid disabled"
    ).

generate_control_buttons(ZoomOpts, Code) :-
    (   member(controls(Controls), ZoomOpts)
    ->  generate_control_buttons_code(Controls, Code)
    ;   Code = ""
    ).

generate_control_buttons_code(Controls, Code) :-
    findall(ButtonCode, (member(Control, Controls), control_button_code(Control, ButtonCode)), Buttons),
    atomic_list_concat(Buttons, '\n', ButtonsHtml),
    format(string(Code),
"// Zoom Controls UI
const createZoomControls = (container) => {
    const controlsDiv = document.createElement('div');
    controlsDiv.className = 'mindmap-zoom-controls';
    controlsDiv.style.cssText = `
        position: absolute;
        bottom: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 100;
    `;

~w

    container.appendChild(controlsDiv);
};

const controlButtonStyle = `
    width: 36px;
    height: 36px;
    border: none;
    border-radius: 6px;
    background: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    cursor: pointer;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
`;
", [ButtonsHtml]).

control_button_code(zoom_in, Code) :-
    Code = "
    const zoomInBtn = document.createElement('button');
    zoomInBtn.innerHTML = '+';
    zoomInBtn.style.cssText = controlButtonStyle;
    zoomInBtn.onclick = zoomIn;
    zoomInBtn.title = 'Zoom In';
    controlsDiv.appendChild(zoomInBtn);".

control_button_code(zoom_out, Code) :-
    Code = "
    const zoomOutBtn = document.createElement('button');
    zoomOutBtn.innerHTML = '-';
    zoomOutBtn.style.cssText = controlButtonStyle;
    zoomOutBtn.onclick = zoomOut;
    zoomOutBtn.title = 'Zoom Out';
    controlsDiv.appendChild(zoomOutBtn);".

control_button_code(zoom_fit, Code) :-
    Code = "
    const zoomFitBtn = document.createElement('button');
    zoomFitBtn.innerHTML = '[ ]';
    zoomFitBtn.style.cssText = controlButtonStyle;
    zoomFitBtn.onclick = () => fitToContent();
    zoomFitBtn.title = 'Fit to Content';
    controlsDiv.appendChild(zoomFitBtn);".

control_button_code(zoom_reset, Code) :-
    Code = "
    const zoomResetBtn = document.createElement('button');
    zoomResetBtn.innerHTML = '1:1';
    zoomResetBtn.style.cssText = controlButtonStyle;
    zoomResetBtn.onclick = zoomReset;
    zoomResetBtn.title = 'Reset Zoom';
    controlsDiv.appendChild(zoomResetBtn);".

% ============================================================================
% MANAGEMENT PREDICATES
% ============================================================================

%% declare_viewport_spec(+MapId, +Spec)
declare_viewport_spec(MapId, viewport(ViewportOpts)) :-
    retractall(mindmap_viewport_spec(MapId, _)),
    assertz(mindmap_viewport_spec(MapId, ViewportOpts)).
declare_viewport_spec(MapId, zoom(ZoomOpts)) :-
    retractall(mindmap_zoom_spec(MapId, _)),
    assertz(mindmap_zoom_spec(MapId, ZoomOpts)).
declare_viewport_spec(MapId, pan(PanOpts)) :-
    retractall(mindmap_pan_spec(MapId, _)),
    assertz(mindmap_pan_spec(MapId, PanOpts)).

%% clear_viewport_specs
clear_viewport_specs :-
    retractall(mindmap_zoom_spec(_, _)),
    retractall(mindmap_pan_spec(_, _)),
    retractall(mindmap_viewport_spec(_, _)).

%% get_zoom_limits(+MapId, -MinScale, -MaxScale)
get_zoom_limits(MapId, MinScale, MaxScale) :-
    (   mindmap_zoom_spec(MapId, ZoomOpts)
    ->  true
    ;   mindmap_zoom_spec(default, ZoomOpts)
    ),
    member(min_scale(MinScale), ZoomOpts),
    member(max_scale(MaxScale), ZoomOpts).

%% get_viewport_bounds(+MapId, -Bounds)
get_viewport_bounds(MapId, bounds(Width, Height)) :-
    (   mindmap_viewport_spec(MapId, ViewportOpts)
    ->  true
    ;   mindmap_viewport_spec(default, ViewportOpts)
    ),
    member(width(Width), ViewportOpts),
    member(height(Height), ViewportOpts).

% ============================================================================
% TESTING
% ============================================================================

test_mindmap_viewport :-
    format('~n=== Mind Map Viewport Tests ===~n~n'),

    % Test 1: Default zoom spec
    format('Test 1: Default zoom spec...~n'),
    (   mindmap_zoom_spec(default, ZoomOpts),
        member(min_scale(0.1), ZoomOpts)
    ->  format('  PASS: Default zoom spec exists~n')
    ;   format('  FAIL: Default zoom spec missing~n')
    ),

    % Test 2: Generate viewport controls
    format('~nTest 2: Generate viewport controls...~n'),
    generate_viewport_controls(default, Code),
    (   sub_string(Code, _, _, _, "zoomIn"),
        sub_string(Code, _, _, _, "zoomOut")
    ->  format('  PASS: Viewport controls generated~n')
    ;   format('  FAIL: Controls generation failed~n')
    ),

    % Test 3: Get zoom limits
    format('~nTest 3: Get zoom limits...~n'),
    get_zoom_limits(default, Min, Max),
    (   Min == 0.1, Max == 5.0
    ->  format('  PASS: Zoom limits: ~w to ~w~n', [Min, Max])
    ;   format('  FAIL: Incorrect zoom limits~n')
    ),

    % Test 4: Fit to content code
    format('~nTest 4: Fit to content...~n'),
    generate_fit_to_content(default, FitCode),
    (   sub_string(FitCode, _, _, _, "fitToContent")
    ->  format('  PASS: Fit to content generated~n')
    ;   format('  FAIL: Fit to content failed~n')
    ),

    % Test 5: Grid viewport
    format('~nTest 5: Grid viewport...~n'),
    mindmap_viewport_spec(with_grid, GridOpts),
    (   member(show_grid(true), GridOpts),
        member(grid_size(25), GridOpts)
    ->  format('  PASS: Grid viewport configured~n')
    ;   format('  FAIL: Grid viewport incorrect~n')
    ),

    format('~n=== Tests Complete ===~n').

% ============================================================================
% INITIALIZATION
% ============================================================================

:- initialization((
    format('Mind map viewport module loaded~n', [])
), now).
