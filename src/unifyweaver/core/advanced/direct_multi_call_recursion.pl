:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% direct_multi_call_recursion.pl - Direct recursive code generation for multi-call patterns
% Generates actual recursive bash functions with memoization instead of fold-based approach
%
% Strategy: For predicates like fibonacci with 2+ independent recursive calls,
% generate bash functions that directly call themselves recursively with memoization.

:- module(direct_multi_call_recursion, [
    compile_direct_multi_call/3,    % +Pred/Arity, +Options, -BashCode
    can_compile_direct_multi_call/1 % +Pred/Arity
]).

:- use_module(library(lists)).
:- use_module('pattern_matchers').

%% can_compile_direct_multi_call(+Pred/Arity)
%  Check if predicate can be compiled as direct multi-call recursion
can_compile_direct_multi_call(Pred/Arity) :-
    % Must be linear recursive streamable (includes multi-call check)
    is_linear_recursive_streamable(Pred/Arity),
    % Must have 2+ recursive calls
    get_recursive_call_count(Pred/Arity, Count),
    Count >= 2.

%% compile_direct_multi_call(+Pred/Arity, +Options, -BashCode)
%  Compile multi-call predicate to direct recursive bash with memoization
%  Options: List of Key=Value pairs (e.g., [unique=true, ordered=false])
compile_direct_multi_call(Pred/Arity, Options, BashCode) :-
    format('  Compiling direct multi-call recursion: ~w/~w~n', [Pred, Arity]),

    % Get multi-call info
    get_multi_call_info(Pred/Arity, multi_call(Count, _IsLinear, _HasDistinct, _IsPrecomp)),
    format('  Recursive calls: ~w~n', [Count]),

    % Currently only support arity 2 (input, output)
    (   Arity =:= 2 ->
        compile_direct_binary_recursion(Pred, Options, BashCode)
    ;   format('  ERROR: Direct multi-call only supports arity 2 currently~n', []),
        fail
    ).

%% compile_direct_binary_recursion(+Pred, +Options, -BashCode)
%  Compile arity-2 predicate with direct recursion
compile_direct_binary_recursion(Pred, _Options, BashCode) :-
    atom_string(Pred, PredStr),

    % Get clauses
    functor(Head, Pred, 2),
    findall(clause(Head, Body), user:clause(Head, Body), Clauses),

    % Separate base and recursive cases
    partition(is_recursive_clause(Pred), Clauses, [RecClause|_], BaseClauses),

    % Extract base cases
    extract_base_cases(BaseClauses, PredStr, BaseCasesCode),

    % Extract recursive case structure
    extract_recursive_case(RecClause, Pred, PredStr, RecursiveCaseCode),

    % Generate bash code
    format(string(BashCode), '#!/bin/bash
# ~w - direct recursive with memoization (multi-call pattern)
# Generated by direct_multi_call_recursion compiler

declare -gA ~w_memo

~w() {
    local input="$1"
    local expected="$2"

    # Check memo
    if [[ -n "${~w_memo[$input]}" ]]; then
        local cached="${~w_memo[$input]}"
        if [[ -z "$expected" ]]; then
            echo "$input:$cached"
            return 0
        elif [[ "$cached" == "$expected" ]]; then
            echo "$input:$expected"
            return 0
        else
            return 1
        fi
    fi

~w
~w

    # Should not reach here
    return 1
}

# Stream wrapper
~w_stream() {
    ~w "$@"
}
', [PredStr, PredStr, PredStr, PredStr, PredStr, BaseCasesCode, RecursiveCaseCode, PredStr, PredStr]).

%% is_recursive_clause(+Pred, +Clause)
is_recursive_clause(Pred, clause(_Head, Body)) :-
    contains_call_to(Body, Pred).

%% extract_base_cases(+BaseClauses, +PredStr, -BashCode)
%  Extract base case conditions and values
extract_base_cases(BaseClauses, PredStr, BashCode) :-
    findall(BaseCode, (
        member(clause(Head, _Body), BaseClauses),
        Head =.. [_Pred, BaseInput, BaseOutput],
        format(string(BaseCode), '    # Base case: ~w -> ~w
    if [[ "$input" -eq ~w ]]; then
        local result="~w"
        ~w_memo["$input"]="$result"
        if [[ -z "$expected" ]]; then
            echo "$input:$result"
            return 0
        elif [[ "$result" == "$expected" ]]; then
            echo "$input:$expected"
            return 0
        else
            return 1
        fi
    fi', [BaseInput, BaseOutput, BaseInput, BaseOutput, PredStr])
    ), BaseCodes),
    atomic_list_concat(BaseCodes, '\n', BashCode).

%% extract_recursive_case(+RecClause, +Pred, +PredStr, -BashCode)
%  Extract recursive case: argument computations, recursive calls, aggregation
extract_recursive_case(clause(Head, Body), Pred, PredStr, BashCode) :-
    % Parse the body structure
    Head =.. [_Pred, _InputVar, _OutputVar],

    % Extract the body components
    extract_body_components(Body, Pred, Computations, RecCalls, Aggregation),

    % Generate bash for each part
    generate_computations_bash(Computations, ComputationsCode),
    generate_recursive_calls_bash(RecCalls, PredStr, RecCallsCode),
    generate_aggregation_bash(Aggregation, AggregationCode),

    % Combine into recursive case code
    format(string(BashCode), '    # Recursive case
~w
~w
~w

    # Memoize result
    ~w_memo["$input"]="$result"

    if [[ -z "$expected" ]]; then
        echo "$input:$result"
        return 0
    elif [[ "$result" == "$expected" ]]; then
        echo "$input:$expected"
        return 0
    else
        return 1
    fi', [ComputationsCode, RecCallsCode, AggregationCode, PredStr]).

%% extract_body_components(+Body, +Pred, -Computations, -RecCalls, -Aggregation)
%  Parse body into: argument computations, recursive calls, result aggregation
extract_body_components(Body, Pred, Computations, RecCalls, Aggregation) :-
    extract_goals_ordered(Body, Goals),
    partition(is_computation, Goals, Computations, Rest1),
    partition(is_recursive_call(Pred), Rest1, RecCalls, Rest2),
    (   Rest2 = [Aggregation|_] -> true ; Aggregation = true).

is_computation(_ is _).

is_recursive_call(Pred, Goal) :-
    compound(Goal),
    functor(Goal, Pred, _).

%% extract_goals_ordered(+Body, -Goals)
%  Extract goals in order from conjunction
extract_goals_ordered((A, B), Goals) :- !,
    extract_goals_ordered(A, GoalsA),
    extract_goals_ordered(B, GoalsB),
    append(GoalsA, GoalsB, Goals).
extract_goals_ordered(Goal, [Goal]).

%% generate_computations_bash(+Computations, -BashCode)
%  Generate bash for argument computations (e.g., N1 is N-1, N2 is N-2)
generate_computations_bash(Computations, BashCode) :-
    findall(Code, (
        member(Var is Expr, Computations),
        translate_computation(Var, Expr, Code)
    ), Codes),
    atomic_list_concat(Codes, '\n', BashCode).

translate_computation(Var, Expr, Code) :-
    translate_expr_to_bash(Expr, BashExpr),
    atom_string(Var, VarStr),
    downcase_atom(VarStr, VarLower),
    format(string(Code), '    local ~w=~w', [VarLower, BashExpr]).

translate_expr_to_bash(N - 1, '$(($input - 1))') :- var(N), !.
translate_expr_to_bash(N - 2, '$(($input - 2))') :- var(N), !.
translate_expr_to_bash(N - 3, '$(($input - 3))') :- var(N), !.
translate_expr_to_bash(N - K, BashExpr) :- var(N), integer(K), !,
    format(string(BashExpr), '$(($input - ~w))', [K]).
translate_expr_to_bash(Expr, '$(($input))') :- var(Expr), !.

%% generate_recursive_calls_bash(+RecCalls, +PredStr, -BashCode)
%  Generate bash for recursive calls with result extraction
generate_recursive_calls_bash(RecCalls, PredStr, BashCode) :-
    findall(Code, (
        member(RecCall, RecCalls),
        RecCall =.. [_Pred, ArgVar, ResultVar],
        atom_string(ArgVar, ArgStr),
        downcase_atom(ArgStr, ArgLower),
        atom_string(ResultVar, ResStr),
        downcase_atom(ResStr, ResLower),
        format(string(Code), '    local ~w=$(~w "$~w" | cut -d: -f2)', [ResLower, PredStr, ArgLower])
    ), Codes),
    atomic_list_concat(Codes, '\n', BashCode).

%% generate_aggregation_bash(+Aggregation, -BashCode)
%  Generate bash for result aggregation (e.g., F is F1 + F2)
generate_aggregation_bash(_Result is Expr, BashCode) :-
    translate_aggregation_expr(Expr, BashExpr),
    format(string(BashCode), '    local result=~w', [BashExpr]).

translate_aggregation_expr(A + B, BashExpr) :-
    atom_string(A, AStr),
    downcase_atom(AStr, ALower),
    atom_string(B, BStr),
    downcase_atom(BStr, BLower),
    format(string(BashExpr), '$(($~w + $~w))', [ALower, BLower]).

translate_aggregation_expr(A + B + C, BashExpr) :-
    atom_string(A, AStr),
    downcase_atom(AStr, ALower),
    atom_string(B, BStr),
    downcase_atom(BStr, BLower),
    atom_string(C, CStr),
    downcase_atom(CStr, CLower),
    format(string(BashExpr), '$(($~w + $~w + $~w))', [ALower, BLower, CLower]).

%% Test predicate
test_direct_multi_call :-
    format('~n=== Testing Direct Multi-Call Compilation ===~n', []),

    % Test fibonacci
    (   can_compile_direct_multi_call(fib/2) ->
        format('✓ fib/2 can use direct multi-call~n', [])
    ;   format('✗ fib/2 cannot use direct multi-call~n', [])
    ),

    format('~n=== Tests Complete ===~n', []).
