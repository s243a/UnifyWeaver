/**
 * PearltreesMindMap - React Native Mind Map Component
 * Generated by UnifyWeaver
 *
 * Uses react-native-svg for vector graphics rendering.
 * Supports pan and zoom via gesture handlers.
 *
 * Dependencies:
 *   npm install react-native-svg react-native-gesture-handler react-native-reanimated
 *
 * For Expo:
 *   expo install react-native-svg react-native-gesture-handler react-native-reanimated
 */

import React, { useState, useCallback, useMemo } from 'react';
import { View, StyleSheet, Dimensions } from 'react-native';
import Svg, { G, Circle, Ellipse, Line, Text as SvgText } from 'react-native-svg';
import { GestureDetector, Gesture, GestureHandlerRootView } from 'react-native-gesture-handler';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withSpring,
} from 'react-native-reanimated';

// Types
interface MindMapNode {
  id: string;
  label: string;
  type: 'root' | 'hub' | 'branch' | 'leaf' | 'default';
  x?: number;
  y?: number;
  url?: string;
}

interface MindMapEdge {
  source: string;
  target: string;
  type?: string;
}

interface PearltreesMindMapProps {
  nodes?: MindMapNode[];
  edges?: MindMapEdge[];
  width?: number;
  height?: number;
  theme?: 'light' | 'dark';
  onNodePress?: (node: MindMapNode) => void;
}

// Theme colors
const themes = {
  light: {
    background: '#ffffff',
    nodeColors: {
      default: { fill: '#e8f4fc', stroke: '#4a90d9', text: '#333333' },
      root: { fill: '#4a90d9', stroke: '#2c5a8c', text: '#ffffff' },
      hub: { fill: '#6ab04c', stroke: '#4a904c', text: '#ffffff' },
      branch: { fill: '#f0932b', stroke: '#c07020', text: '#ffffff' },
      leaf: { fill: '#eb4d4b', stroke: '#cb2d2b', text: '#ffffff' },
    },
    edgeColor: '#666666',
  },
  dark: {
    background: '#1a1a2e',
    nodeColors: {
      default: { fill: '#2d3748', stroke: '#4a9ce9', text: '#e2e8f0' },
      root: { fill: '#5a9ce9', stroke: '#3c6a9c', text: '#ffffff' },
      hub: { fill: '#7ac05c', stroke: '#5aa05c', text: '#ffffff' },
      branch: { fill: '#ffaa4b', stroke: '#d08030', text: '#000000' },
      leaf: { fill: '#fb5d5b', stroke: '#db3d3b', text: '#ffffff' },
    },
    edgeColor: '#718096',
  },
};

// Example Pearltrees data
const defaultNodes: MindMapNode[] = [
  { id: 'root', label: 'My Pearltrees', type: 'root' as const },
  { id: 'tech', label: 'Technology', type: 'hub' as const },
  { id: 'science', label: 'Science', type: 'hub' as const },
  { id: 'web', label: 'Web Dev', type: 'branch' as const },
  { id: 'ai', label: 'AI/ML', type: 'branch' as const },
  { id: 'physics', label: 'Physics', type: 'branch' as const },
  { id: 'react', label: 'React', type: 'leaf' as const },
  { id: 'prolog', label: 'Prolog', type: 'leaf' as const },
];

const defaultEdges: MindMapEdge[] = [
  { source: 'root', target: 'tech' },
  { source: 'root', target: 'science' },
  { source: 'tech', target: 'web' },
  { source: 'tech', target: 'ai' },
  { source: 'science', target: 'physics' },
  { source: 'web', target: 'react' },
  { source: 'ai', target: 'prolog' },
];

// Simple force layout calculation
const calculateLayout = (nodes: MindMapNode[], width: number, height: number) => {
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) / 3;

  return nodes.map((node, index) => {
    if (node.x !== undefined && node.y !== undefined) {
      return node;
    }

    if (node.type === 'root') {
      return { ...node, x: centerX, y: centerY };
    }

    const angle = (2 * Math.PI * index) / nodes.length;
    const distance = node.type === 'hub' ? radius * 0.6 : radius;

    return {
      ...node,
      x: centerX + Math.cos(angle) * distance,
      y: centerY + Math.sin(angle) * distance,
    };
  });
};

export const PearltreesMindMap: React.FC<PearltreesMindMapProps> = ({
  nodes = defaultNodes,
  edges = defaultEdges,
  width = 400,
  height = 400,
  theme = 'light',
  onNodePress,
}) => {
  // Theme
  const themeColors = themes[theme] || themes.light;

  // Gesture state
  const scale = useSharedValue(1);
  const translateX = useSharedValue(0);
  const translateY = useSharedValue(0);
  const savedScale = useSharedValue(1);
  const savedTranslateX = useSharedValue(0);
  const savedTranslateY = useSharedValue(0);

  // Calculate node positions
  const layoutNodes = useMemo(
    () => calculateLayout(nodes, width, height),
    [nodes, width, height]
  );

  // Create node position map for edge rendering
  const nodeMap = useMemo(() => {
    const map: Record<string, MindMapNode> = {};
    layoutNodes.forEach(node => {
      map[node.id] = node;
    });
    return map;
  }, [layoutNodes]);

  // Gestures
  const pinchGesture = Gesture.Pinch()
    .onUpdate((e) => {
      scale.value = savedScale.value * e.scale;
    })
    .onEnd(() => {
      savedScale.value = scale.value;
    });

  const panGesture = Gesture.Pan()
    .onUpdate((e) => {
      translateX.value = savedTranslateX.value + e.translationX;
      translateY.value = savedTranslateY.value + e.translationY;
    })
    .onEnd(() => {
      savedTranslateX.value = translateX.value;
      savedTranslateY.value = translateY.value;
    });

  const doubleTapGesture = Gesture.Tap()
    .numberOfTaps(2)
    .onEnd(() => {
      scale.value = withSpring(1);
      translateX.value = withSpring(0);
      translateY.value = withSpring(0);
      savedScale.value = 1;
      savedTranslateX.value = 0;
      savedTranslateY.value = 0;
    });

  const composedGesture = Gesture.Simultaneous(
    pinchGesture,
    panGesture,
    doubleTapGesture
  );

  // Animated style
  const animatedStyle = useAnimatedStyle(() => ({
    transform: [
      { translateX: translateX.value },
      { translateY: translateY.value },
      { scale: scale.value },
    ],
  }));

  // Node press handler
  const handleNodePress = useCallback((node: MindMapNode) => {
    if (onNodePress) {
      onNodePress(node);
    }
  }, [onNodePress]);

  // Get node style based on type
  const getNodeStyle = (type: string) => {
    return themeColors.nodeColors[type as keyof typeof themeColors.nodeColors]
      || themeColors.nodeColors.default;
  };

  return (
    <GestureHandlerRootView style={[styles.container, { backgroundColor: themeColors.background }]}>
      <GestureDetector gesture={composedGesture}>
        <Animated.View style={[styles.svgContainer, animatedStyle]}>
          <Svg width={width} height={height} viewBox={`0 0 ${width} ${height}`}>
            <G>
              {/* Render edges */}
              {edges.map((edge, index) => {
                const source = nodeMap[edge.source];
                const target = nodeMap[edge.target];
                if (!source || !target) return null;

                return (
                  <Line
                    key={`edge-${index}`}
                    x1={source.x}
                    y1={source.y}
                    x2={target.x}
                    y2={target.y}
                    stroke={themeColors.edgeColor}
                    strokeWidth={2}
                  />
                );
              })}

              {/* Render nodes */}
              {layoutNodes.map((node) => {
                const style = getNodeStyle(node.type);
                const rx = node.type === 'root' ? 50 : 40;
                const ry = node.type === 'root' ? 30 : 25;

                return (
                  <G
                    key={node.id}
                    onPress={() => handleNodePress(node)}
                  >
                    <Ellipse
                      cx={node.x}
                      cy={node.y}
                      rx={rx}
                      ry={ry}
                      fill={style.fill}
                      stroke={style.stroke}
                      strokeWidth={node.type === 'root' ? 3 : 2}
                    />
                    <SvgText
                      x={node.x}
                      y={node.y}
                      fill={style.text}
                      fontSize={node.type === 'root' ? 14 : 12}
                      fontWeight={node.type === 'root' ? 'bold' : 'normal'}
                      textAnchor="middle"
                      alignmentBaseline="middle"
                    >
                      {node.label.length > 12 ? node.label.slice(0, 10) + '...' : node.label}
                    </SvgText>
                  </G>
                );
              })}
            </G>
          </Svg>
        </Animated.View>
      </GestureDetector>
    </GestureHandlerRootView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  svgContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

export default PearltreesMindMap;
