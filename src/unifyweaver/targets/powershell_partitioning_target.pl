:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% powershell_partitioning_target.pl - Pure PowerShell Partitioning Code Generator
% Generates PowerShell scripts for partitioning data without Bash dependencies

:- module(powershell_partitioning_target, [
    generate_powershell_partitioner/3,    % +Strategy, +Options, -PowerShellCode
    write_powershell_partitioner/2        % +PowerShellCode, +FilePath
]).

:- use_module(library(lists)).

%% ============================================================================
%% PUBLIC API
%% ============================================================================

%% generate_powershell_partitioner(+Strategy, +Options, -PowerShellCode)
%  Generate PowerShell code for partitioning with given strategy
%
%  @arg Strategy Partitioning strategy: fixed_size(rows(N)|bytes(N)), hash_based(...), key_based(...)
%  @arg Options List of options
%  @arg PowerShellCode Generated PowerShell code as string
%
%  Options:
%  - function_name(Name) - Name of PowerShell function (default: Split-Data)
%  - output_dir_var(Var) - Variable name for output directory (default: PartitionDir)
%  - include_header(true|false) - Include comments (default: true)
%
generate_powershell_partitioner(Strategy, Options, PowerShellCode) :-
    option(function_name(FuncName), Options, 'Split-Data'),
    option(output_dir_var(DirVar), Options, 'PartitionDir'),
    option(include_header(IncludeHeader), Options, true),

    % Generate appropriate code based on strategy
    generate_ps_strategy_code(Strategy, FuncName, DirVar, StrategyCode),

    % Optionally add header
    (   IncludeHeader
    ->  generate_ps_header(Strategy, Header),
        format(string(PowerShellCode), "~w\n\n~w", [Header, StrategyCode])
    ;   PowerShellCode = StrategyCode
    ).

%% write_powershell_partitioner(+PowerShellCode, +FilePath)
%  Write generated PowerShell code to file
%
write_powershell_partitioner(PowerShellCode, FilePath) :-
    open(FilePath, write, Stream),
    format(Stream, '~w', [PowerShellCode]),
    close(Stream),
    format('[PowerShellPartitioner] Generated script: ~w~n', [FilePath]).

%% ============================================================================
%% HEADER GENERATION
%% ============================================================================

generate_ps_header(Strategy, Header) :-
    get_time(Timestamp),
    format_time(string(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),
    strategy_description_ps(Strategy, Description),

    format(string(Header),
"# Generated by UnifyWeaver
# Target: Pure PowerShell Partitioning
# Generated: ~w
# Strategy: ~w
", [DateStr, Description]).

strategy_description_ps(fixed_size(rows(N)), Desc) :-
    format(string(Desc), "Fixed-size partitioning (~w rows per partition)", [N]).
strategy_description_ps(fixed_size(bytes(N)), Desc) :-
    format(string(Desc), "Fixed-size partitioning (~w bytes per partition)", [N]).
strategy_description_ps(hash_based(Args), Desc) :-
    (   member(column(Col), Args) -> true ; Col = 0 ),
    (   member(num_partitions(N), Args) -> true ; N = 8 ),
    format(string(Desc), "Hash-based partitioning (column ~w, ~w partitions)", [Col, N]).
strategy_description_ps(key_based(Args), Desc) :-
    (   member(column(Col), Args) -> true ; Col = 0 ),
    format(string(Desc), "Key-based (GROUP BY) partitioning (column ~w)", [Col]).

%% ============================================================================
%% STRATEGY CODE GENERATION
%% ============================================================================

%% Fixed-Size Row Partitioning
generate_ps_strategy_code(fixed_size(rows(RowsPerPartition)), FuncName, DirVar, Code) :-
    format(string(Code),
"# Partition data by rows
function ~w {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputFile,
        
        [string]$OutputDir = $env:~w,
        
        [int]$RowsPerPartition = ~w
    )
    
    # Default output directory
    if (-not $OutputDir) {
        $OutputDir = Join-Path $env:TEMP \"partitions_$PID\"
    }
    
    # Create output directory
    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
    
    # Read all lines
    $lines = Get-Content -Path $InputFile
    $totalLines = $lines.Count
    $partitionCount = [Math]::Ceiling($totalLines / $RowsPerPartition)
    
    # Partition the lines
    for ($i = 0; $i -lt $partitionCount; $i++) {
        $start = $i * $RowsPerPartition
        $end = [Math]::Min($start + $RowsPerPartition - 1, $totalLines - 1)
        $partitionFile = Join-Path $OutputDir (\"partition_{0:D2}.txt\" -f $i)
        
        $lines[$start..$end] | Out-File -FilePath $partitionFile -Encoding UTF8
    }
    
    # Generate metadata
    $metadata = @{
        strategy = 'fixed_size'
        mode = 'rows'
        rows_per_partition = $RowsPerPartition
        partition_count = $partitionCount
        timestamp = (Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')
    }
    $metadata | ConvertTo-Json | Out-File -FilePath (Join-Path $OutputDir 'metadata.json') -Encoding UTF8
    
    # Set environment variable
    $env:PARTITION_COUNT = $partitionCount
    $env:PARTITION_DIR = $OutputDir
    
    Write-Host \"[Partitioner] Created $partitionCount partitions in $OutputDir\"
    
    return @{
        PartitionCount = $partitionCount
        OutputDir = $OutputDir
    }
}

# Helper: List all partition files
function Get-Partitions {
    param([string]$Dir = $env:PARTITION_DIR)
    Get-ChildItem -Path $Dir -Filter 'partition_*.txt' | Sort-Object Name
}

# Helper: Get partition count
function Get-PartitionCount {
    param([string]$Dir = $env:PARTITION_DIR)
    (Get-ChildItem -Path $Dir -Filter 'partition_*.txt').Count
}", [FuncName, DirVar, RowsPerPartition]).

%% Fixed-Size Byte Partitioning
generate_ps_strategy_code(fixed_size(bytes(BytesPerPartition)), FuncName, DirVar, Code) :-
    format(string(Code),
"# Partition data by bytes
function ~w {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputFile,
        
        [string]$OutputDir = $env:~w,
        
        [int]$BytesPerPartition = ~w
    )
    
    # Default output directory
    if (-not $OutputDir) {
        $OutputDir = Join-Path $env:TEMP \"partitions_$PID\"
    }
    
    # Create output directory
    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
    
    # Read file as bytes
    $bytes = [System.IO.File]::ReadAllBytes($InputFile)
    $totalBytes = $bytes.Length
    $partitionCount = [Math]::Ceiling($totalBytes / $BytesPerPartition)
    
    # Partition the bytes
    for ($i = 0; $i -lt $partitionCount; $i++) {
        $start = $i * $BytesPerPartition
        $length = [Math]::Min($BytesPerPartition, $totalBytes - $start)
        $partitionFile = Join-Path $OutputDir (\"partition_{0:D2}.bin\" -f $i)
        
        $chunk = New-Object byte[] $length
        [Array]::Copy($bytes, $start, $chunk, 0, $length)
        [System.IO.File]::WriteAllBytes($partitionFile, $chunk)
    }
    
    # Generate metadata
    $metadata = @{
        strategy = 'fixed_size'
        mode = 'bytes'
        bytes_per_partition = $BytesPerPartition
        partition_count = $partitionCount
        timestamp = (Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')
    }
    $metadata | ConvertTo-Json | Out-File -FilePath (Join-Path $OutputDir 'metadata.json') -Encoding UTF8
    
    # Set environment variable
    $env:PARTITION_COUNT = $partitionCount
    $env:PARTITION_DIR = $OutputDir
    
    Write-Host \"[Partitioner] Created $partitionCount partitions in $OutputDir\"
    
    return @{
        PartitionCount = $partitionCount
        OutputDir = $OutputDir
    }
}

# Helper: List all partition files
function Get-Partitions {
    param([string]$Dir = $env:PARTITION_DIR)
    Get-ChildItem -Path $Dir -Filter 'partition_*.bin' | Sort-Object Name
}

# Helper: Get partition count
function Get-PartitionCount {
    param([string]$Dir = $env:PARTITION_DIR)
    (Get-ChildItem -Path $Dir -Filter 'partition_*.bin').Count
}", [FuncName, DirVar, BytesPerPartition]).

%% Hash-Based Partitioning
generate_ps_strategy_code(hash_based(Args), FuncName, DirVar, Code) :-
    % Extract configuration
    (   member(column(ColNum), Args) -> true ; ColNum = 0 ),
    (   member(num_partitions(NumPartitions), Args) -> true ; NumPartitions = 8 ),
    (   member(delimiter(Delim), Args) -> true ; Delim = '\t' ),

    format(string(Code),
"# Partition data by hash of column
function ~w {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputFile,
        
        [string]$OutputDir = $env:~w,
        
        [int]$Column = ~w,
        
        [int]$NumPartitions = ~w,
        
        [string]$Delimiter = '~w'
    )
    
    # Default output directory
    if (-not $OutputDir) {
        $OutputDir = Join-Path $env:TEMP \"partitions_$PID\"
    }
    
    # Create output directory
    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
    
    # Initialize partition hashtable for file handles
    $partitionWriters = @{}
    
    # Process each line
    Get-Content -Path $InputFile | ForEach-Object {
        $line = $_
        $fields = $line -split $Delimiter
        
        if ($fields.Count -gt $Column) {
            $key = $fields[$Column]
        } else {
            $key = ''
        }
        
        # Simple hash: sum of character codes modulo NumPartitions
        $hash = 0
        foreach ($char in $key.ToCharArray()) {
            $hash += [int]$char
        }
        $partitionId = $hash % $NumPartitions
        
        # Get or create stream writer for this partition
        if (-not $partitionWriters.ContainsKey($partitionId)) {
            $partitionFile = Join-Path $OutputDir (\"partition_{0:D2}.txt\" -f $partitionId)
            $partitionWriters[$partitionId] = [System.IO.StreamWriter]::new($partitionFile, $false, [System.Text.Encoding]::UTF8)
        }
        
        $partitionWriters[$partitionId].WriteLine($line)
    }
    
    # Close all writers
    foreach ($writer in $partitionWriters.Values) {
        $writer.Close()
    }
    
    $partitionCount = $partitionWriters.Count
    
    # Generate metadata
    $metadata = @{
        strategy = 'hash_based'
        column = $Column
        num_partitions = $NumPartitions
        delimiter = $Delimiter
        partition_count = $partitionCount
        timestamp = (Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')
    }
    $metadata | ConvertTo-Json | Out-File -FilePath (Join-Path $OutputDir 'metadata.json') -Encoding UTF8
    
    # Set environment variable
    $env:PARTITION_COUNT = $partitionCount
    $env:PARTITION_DIR = $OutputDir
    
    Write-Host \"[Partitioner] Created $partitionCount partitions in $OutputDir (hash-based on column $Column)\"
    
    return @{
        PartitionCount = $partitionCount
        OutputDir = $OutputDir
    }
}

# Helper: List all partition files
function Get-Partitions {
    param([string]$Dir = $env:PARTITION_DIR)
    Get-ChildItem -Path $Dir -Filter 'partition_*.txt' | Sort-Object Name
}

# Helper: Get partition count
function Get-PartitionCount {
    param([string]$Dir = $env:PARTITION_DIR)
    (Get-ChildItem -Path $Dir -Filter 'partition_*.txt').Count
}", [FuncName, DirVar, ColNum, NumPartitions, Delim]).

%% Key-Based (GROUP BY) Partitioning
generate_ps_strategy_code(key_based(Args), FuncName, DirVar, Code) :-
    % Extract configuration
    (   member(column(ColNum), Args) -> true ; ColNum = 0 ),
    (   member(delimiter(Delim), Args) -> true ; Delim = '\t' ),

    format(string(Code),
"# Partition data by grouping on column value (GROUP BY)
function ~w {
    param(
        [Parameter(Mandatory=$true)]
        [string]$InputFile,
        
        [string]$OutputDir = $env:~w,
        
        [int]$Column = ~w,
        
        [string]$Delimiter = '~w'
    )
    
    # Default output directory
    if (-not $OutputDir) {
        $OutputDir = Join-Path $env:TEMP \"partitions_$PID\"
    }
    
    # Create output directory
    New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
    
    # Track key to partition mapping
    $keyToPartition = @{}
    $partitionWriters = @{}
    $keyFiles = @{}
    $partitionId = 0
    
    # Process each line
    Get-Content -Path $InputFile | ForEach-Object {
        $line = $_
        $fields = $line -split $Delimiter
        
        if ($fields.Count -gt $Column) {
            $key = $fields[$Column]
        } else {
            $key = ''
        }
        
        # Assign new partition ID if key not seen before
        if (-not $keyToPartition.ContainsKey($key)) {
            $keyToPartition[$key] = $partitionId
            
            # Create stream writer for this partition
            $partitionFile = Join-Path $OutputDir (\"partition_{0:D3}.txt\" -f $partitionId)
            $partitionWriters[$partitionId] = [System.IO.StreamWriter]::new($partitionFile, $false, [System.Text.Encoding]::UTF8)
            
            # Write key to key file
            $keyFile = Join-Path $OutputDir (\"key_{0:D3}.txt\" -f $partitionId)
            $key | Out-File -FilePath $keyFile -Encoding UTF8 -NoNewline
            
            $partitionId++
        }
        
        $pid = $keyToPartition[$key]
        $partitionWriters[$pid].WriteLine($line)
    }
    
    # Close all writers
    foreach ($writer in $partitionWriters.Values) {
        $writer.Close()
    }
    
    $partitionCount = $keyToPartition.Count
    
    # Write partition count
    $partitionCount | Out-File -FilePath (Join-Path $OutputDir 'partition_count.txt') -Encoding UTF8 -NoNewline
    
    # Generate metadata with key mappings
    $keyMappings = @()
    foreach ($kvp in $keyToPartition.GetEnumerator()) {
        $keyMappings += @{
            partition_id = $kvp.Value
            key = $kvp.Key
        }
    }
    
    $metadata = @{
        strategy = 'key_based'
        column = $Column
        delimiter = $Delimiter
        partition_count = $partitionCount
        timestamp = (Get-Date -Format 'yyyy-MM-ddTHH:mm:ssZ')
        key_mappings = $keyMappings
    }
    $metadata | ConvertTo-Json -Depth 3 | Out-File -FilePath (Join-Path $OutputDir 'metadata.json') -Encoding UTF8
    
    # Set environment variable
    $env:PARTITION_COUNT = $partitionCount
    $env:PARTITION_DIR = $OutputDir
    
    Write-Host \"[Partitioner] Created $partitionCount partitions in $OutputDir (grouped by column $Column)\"
    
    return @{
        PartitionCount = $partitionCount
        OutputDir = $OutputDir
        KeyMappings = $keyToPartition
    }
}

# Helper: List all partition files
function Get-Partitions {
    param([string]$Dir = $env:PARTITION_DIR)
    Get-ChildItem -Path $Dir -Filter 'partition_*.txt' | Sort-Object Name
}

# Helper: Get partition count
function Get-PartitionCount {
    param([string]$Dir = $env:PARTITION_DIR)
    [int](Get-Content -Path (Join-Path $Dir 'partition_count.txt') -ErrorAction SilentlyContinue) ?? 0
}

# Helper: Get key for partition ID
function Get-PartitionKey {
    param(
        [string]$Dir = $env:PARTITION_DIR,
        [int]$PartitionId
    )
    $keyFile = Join-Path $Dir (\"key_{0:D3}.txt\" -f $PartitionId)
    Get-Content -Path $keyFile -ErrorAction SilentlyContinue
}", [FuncName, DirVar, ColNum, Delim]).

%% Helper to get option with default
option(Option, Options, Default) :-
    (   member(Option, Options)
    ->  true
    ;   Option =.. [Key, Default],
        \+ member(Key=_, Options)
    ).
