:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
%
% csharp_query_target.pl - Query IR synthesis for the C# runtime.
% Initial milestone: supports fact-only predicates and returns a declarative
% plan structure describing the relation scan required to answer the predicate.
% Support for rule bodies and recursion will be layered on in future patches.

:- module(csharp_query_target, [
    build_query_plan/3,     % +PredIndicator, +Options, -PlanDict
    render_plan_to_csharp/2 % +PlanDict, -CSharpSource
]).

:- use_module(library(apply)).
:- use_module(library(error)).
:- use_module(library(lists)).

%% build_query_plan(+PredIndicator, +Options, -PlanDict) is semidet.
%  Produce a declarative plan describing how to evaluate the requested
%  predicate. Plans are represented as dicts containing the head descriptor,
%  root operator, materialised fact tables, and metadata.
build_query_plan(Pred/Arity, Options, Plan) :-
    must_be(atom, Pred),
    must_be(integer, Arity),
    Arity >= 0,

    functor(Head, Pred, Arity),
    findall(Body, clause(Head, Body), Bodies),
    classify_bodies(Bodies, Classification),
    build_plan_by_class(Classification, Pred, Arity, Bodies, Options, Plan).

%% classify_bodies(+Bodies, -Classification) is det.
classify_bodies([], none).
classify_bodies(Bodies, facts) :-
    Bodies \= [],
    forall(member(Body, Bodies), Body == true), !.
classify_bodies([Body], single_rule) :-
    Body \= true, !.
classify_bodies(Bodies, multiple_rules) :-
    Bodies \= [],
    Bodies \= [true],
    Bodies \= [_], !.
classify_bodies(_Bodies, unsupported).

%% build_plan_by_class(+Class, +Pred, +Arity, +Bodies, +Options, -Plan) is semidet.
build_plan_by_class(none, Pred, Arity, _Bodies, _Options, _) :-
    format(user_error, 'C# query target: no clauses found for ~w/~w.~n', [Pred, Arity]),
    fail.
build_plan_by_class(unsupported, Pred, Arity, _Bodies, _Options, _) :-
    format(user_error,
           'C# query target: predicate shape not yet supported (~w/~w).~n',
           [Pred, Arity]),
    fail.
build_plan_by_class(single_rule, Pred, Arity, _Bodies, _Options, _) :-
    format(user_error,
           'C# query target: single-rule bodies not yet implemented (~w/~w).~n',
           [Pred, Arity]),
    fail.
build_plan_by_class(multiple_rules, Pred, Arity, _Bodies, _Options, _) :-
    format(user_error,
           'C# query target: multi-clause rules not yet implemented (~w/~w).~n',
           [Pred, Arity]),
    fail.
build_plan_by_class(facts, Pred, Arity, _Bodies, Options, Plan) :-
    gather_fact_rows(Pred, Arity, Rows),
    Rows \= [],
    HeadSpec = predicate{name:Pred, arity:Arity},
    Relation = relation{
        predicate:HeadSpec,
        facts:Rows
    },
    Plan = plan{
        head:HeadSpec,
        root:relation_scan{predicate:HeadSpec},
        relations:[Relation],
        metadata:_{classification:facts, options:Options},
        is_recursive:false
    }.

%% render_plan_to_csharp(+Plan, -Code) is det.
%  Convert the declarative plan dict into a C# helper that constructs the
%  corresponding QueryRuntime objects. Currently only fact scans are supported.
render_plan_to_csharp(Plan, Code) :-
    get_dict(head, Plan, predicate{name:Pred, arity:Arity}),
    get_dict(root, Plan, relation_scan{predicate:RootPredicate}),
    RootPredicate = predicate{name:Pred, arity:Arity},
    get_dict(relations, Plan, Relations),
    relation_blocks(Relations, ProviderBody),
    (   ProviderBody == '' ->
        ProviderSection = ''
    ;   format(atom(ProviderSection), '~w~n', [ProviderBody])
    ),
    predicate_pascal(Pred, ModuleName),
    atom_string(Pred, PredStr),
    format(atom(Code),
'// Auto-generated by UnifyWeaver
using System;
using System.Linq;
using UnifyWeaver.QueryRuntime;

namespace UnifyWeaver.Generated
{
    public static class ~wQueryModule
    {
        public static (InMemoryRelationProvider Provider, QueryPlan Plan) Build()
        {
            var provider = new InMemoryRelationProvider();
~w            var plan = new QueryPlan(
                new PredicateId("~w", ~w),
                new RelationScanNode(new PredicateId("~w", ~w))
            );
            return (provider, plan);
        }
    }
}
', [ModuleName, ProviderSection, PredStr, Arity, PredStr, Arity]).

gather_fact_rows(Pred, Arity, Rows) :-
    findall(Row,
        (   functor(Head, Pred, Arity),
            clause(Head, true),
            Head =.. [_|Args],
            maplist(copy_term_value, Args, Row)
        ),
        Rows).

copy_term_value(Term, Copy) :-
    (   atomic(Term) ->
        Copy = Term
    ;   Term =.. [Functor|Args],
        maplist(copy_term_value, Args, CopyArgs),
        Copy =.. [Functor|CopyArgs]
    ).

relation_blocks(Relations, ProviderStatements) :-
    findall(Line,
        (   member(Relation, Relations),
            relation_row_line(Relation, Line)
        ),
        Lines),
    (   Lines == [] ->
        ProviderStatements = ''
    ;   atom_codes(NL, [10]),
        atomic_list_concat(Lines, NL, ProviderStatements)
    ).

relation_row_line(Relation, Line) :-
    Relation = relation{
        predicate:predicate{name:Name, arity:Arity},
        facts:Rows
    },
    member(Row, Rows),
    row_to_addfact(Name, Arity, Row, Line).

row_to_addfact(Name, Arity, Row, Line) :-
    atom_string(Name, NameStr),
    maplist(csharp_literal, Row, ArgLiterals),
    atomic_list_concat(ArgLiterals, ', ', ArgList),
    format(atom(Line),
'            provider.AddFact(new PredicateId("~w", ~w), ~w);',
        [NameStr, Arity, ArgList]).

csharp_literal(Value, Literal) :-
    (   number(Value) ->
        format(atom(Literal), '~w', [Value])
    ;   atom(Value) ->
        atom_string(Value, String),
        escape_csharp_string(String, Escaped),
        format(atom(Literal), '"~w"', [Escaped])
    ;   string(Value) ->
        escape_csharp_string(Value, Escaped),
        format(atom(Literal), '"~w"', [Escaped])
    ;   term_string(Value, String),
        escape_csharp_string(String, Escaped),
        format(atom(Literal), '"~w"', [Escaped])
    ).

escape_csharp_string(Input, Escaped) :-
    string_codes(Input, Codes),
    maplist(escape_code, Codes, Parts),
    atomic_list_concat(Parts, '', Escaped).

escape_code(0'\\, Atom) :-
    atom_codes(Atom, [0'\\, 0'\\]).
escape_code(0'", Atom) :-
    atom_codes(Atom, [0'\\, 0'"]).
escape_code(10, Atom) :- % newline
    atom_codes(Atom, [0'\\, 0'n]).
escape_code(13, Atom) :- % carriage return
    atom_codes(Atom, [0'\\, 0'r]).
escape_code(9, Atom) :- % tab
    atom_codes(Atom, [0'\\, 0't]).
escape_code(Code, Atom) :-
    atom_codes(Atom, [Code]).

predicate_pascal(Atom, Pascal) :-
    atom_string(Atom, Text),
    split_string(Text, "_", "_", Parts),
    maplist(capitalise_string, Parts, Caps),
    atomic_list_concat(Caps, '', PascalString),
    atom_string(Pascal, PascalString).

capitalise_string(Input, Output) :-
    (   Input = "" ->
        Output = ""
    ;   string_lower(Input, Lower),
        sub_string(Lower, 0, 1, _, First),
        sub_string(Lower, 1, _, 0, Rest),
        string_upper(First, UpperFirst),
        string_concat(UpperFirst, Rest, Output)
    ).
