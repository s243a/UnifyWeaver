% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% jython_target.pl - Jython Target for UnifyWeaver
% Generates Jython (Python 2.7 on JVM) programs for record/field processing
% Supports streaming JSONL I/O and Java interop

:- encoding(utf8).

:- module(jython_target, [
    compile_predicate_to_jython/3,    % +Predicate, +Options, -JythonCode
    compile_jython_pipeline/3,        % +Predicates, +Options, -JythonCode
    write_jython_program/2,           % +JythonCode, +FilePath
    init_jython_target/0,             % Initialize Jython target
    test_jython_pipeline_mode/0       % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').
:- use_module('../bindings/jython_bindings').

% Track required imports
:- dynamic required_jython_import/1.

%% init_jython_target
%  Initialize Jython target
init_jython_target :-
    retractall(required_jython_import(_)).

%% clear_jython_imports
%  Clear collected Jython imports
clear_jython_imports :-
    retractall(required_jython_import(_)).

%% collect_jython_import(+Import)
%  Record that an import is required
collect_jython_import(Import) :-
    (   required_jython_import(Import)
    ->  true
    ;   assertz(required_jython_import(Import))
    ).

%% get_jython_imports(-Imports)
%  Get all collected imports
get_jython_imports(Imports) :-
    findall(I, required_jython_import(I), Imports).

%% format_jython_imports(+Imports, -FormattedStr)
%  Format a list of imports for Jython
format_jython_imports([], "").
format_jython_imports(Imports, FormattedStr) :-
    Imports \= [],
    sort(Imports, UniqueImports),
    findall(Formatted,
        (   member(Import, UniqueImports),
            format(string(Formatted), "import ~w~n", [Import])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_jython(+Predicate, +Options, -JythonCode)
%  Compile a Prolog predicate to Jython code
%
%  @arg Predicate Predicate indicator (Name/Arity)
%  @arg Options List of options
%  @arg JythonCode Generated Jython code as atom
%
%  Options:
%  - pipeline_input(true|false) - Enable streaming input
%  - java_imports(List) - Java classes to import
%
compile_predicate_to_jython(PredIndicator, Options, JythonCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to Jython ===~n', [Pred, Arity]),

    % Clear any previously collected imports
    clear_jython_imports,

    % Check for pipeline mode
    (   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_jython(Pred, Arity, Options, JythonCode)
    % Default: simple predicate
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_jython(Pred, Arity, Options, JythonCode)
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_jython(Pred, Arity, Options, JythonCode) :-
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate function for each clause
    (   Clauses == []
    ->  FunctionCode = "    # No clauses found\n    pass"
    ;   findall(Code, (member((H, B), Clauses), clause_to_jython(H, B, Code)), FunctionCodes),
        atomic_list_concat(FunctionCodes, '\n', FunctionCode)
    ),
    
    % Standard imports
    collect_jython_import(sys),
    collect_jython_import(json),
    
    % Java imports if specified
    (   option(java_imports(JavaImports), Options)
    ->  forall(member(JI, JavaImports), collect_jython_import(JI))
    ;   true
    ),
    
    get_jython_imports(ImportList),
    format_jython_imports(ImportList, ImportsStr),
    
    format(string(JythonCode),
"#!/usr/bin/env jython
# -*- coding: utf-8 -*-
# Generated by UnifyWeaver Jython Target
# Predicate: ~w/~w

~w

def ~w(*args):
    '''Generated predicate ~w/~w'''
~w

if __name__ == '__main__':
    # TODO: Add main logic
    pass
", [Pred, Arity, ImportsStr, Pred, Pred, Arity, FunctionCode]).

%% clause_to_jython(+Head, +Body, -Code)
%  Convert a single clause to Jython code (stub)
clause_to_jython(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    length(Args, _Arity),
    (   Body == true
    ->  format(string(Code), "    # Fact: ~w", [Head])
    ;   format(string(Code), "    # Rule: ~w :- ~w", [Head, Body])
    ).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_jython(Pred, Arity, Options, JythonCode) :-
    % Standard pipeline imports
    collect_jython_import(sys),
    collect_jython_import(json),
    
    % Java imports for performance (optional)
    (   option(use_java_json(true), Options)
    ->  collect_jython_import('com.google.gson.Gson'),
        collect_jython_import('com.google.gson.JsonParser')
    ;   true
    ),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate process function
    (   Clauses == []
    ->  ProcessCode = "    # No clauses found - pass through\n    yield record"
    ;   generate_pipeline_process_jython(Clauses, ProcessCode)
    ),
    
    get_jython_imports(ImportList),
    format_jython_imports(ImportList, ImportsStr),
    
    format(string(JythonCode),
"#!/usr/bin/env jython
# -*- coding: utf-8 -*-
# Generated by UnifyWeaver Jython Target - Pipeline Mode
# Predicate: ~w/~w
# Note: Jython uses Python 2.7 syntax

from __future__ import print_function
~w
from java.io import BufferedReader, InputStreamReader
from java.lang import System as JavaSystem

def process(record):
    '''
    Process a single input record.
    
    Args:
        record: Input record as dict
        
    Yields:
        Output records (dicts)
    '''
~w

def read_jsonl(stream):
    '''Read JSONL from input stream.'''
    reader = BufferedReader(InputStreamReader(stream))
    line = reader.readLine()
    while line is not None:
        if line.strip():
            yield json.loads(line)
        line = reader.readLine()

def write_jsonl(record, stream=None):
    '''Write record as JSONL.'''
    if stream is None:
        print(json.dumps(record))
    else:
        stream.write(json.dumps(record) + '\\n')

def run_pipeline():
    '''Run the pipeline: read from stdin, process, write to stdout.'''
    for record in read_jsonl(JavaSystem.in):
        for result in process(record):
            write_jsonl(result)

if __name__ == '__main__':
    run_pipeline()
", [Pred, Arity, ImportsStr, ProcessCode]).

%% generate_pipeline_process_jython(+Clauses, -Code)
%  Generate process function body from clauses
generate_pipeline_process_jython([], "    yield record").
generate_pipeline_process_jython(Clauses, Code) :-
    Clauses \= [],
    % Check for recursion
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_jython(Name, Clauses)
    ->  % Separate base and recursive clauses
        partition(is_recursive_clause_jython(Name), Clauses, RecClauses, BaseClauses),
        % Check if tail recursive
        (   is_tail_recursive_jython(Name, RecClauses)
        ->  compile_tail_recursive_jython(Name, BaseClauses, RecClauses, Code)
        ;   compile_general_recursive_jython(Name, BaseClauses, RecClauses, Code)
        )
    ;   % Generate clause-based processing
        findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_jython(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', AllClausesCode),
        format(string(Code), "~w", [AllClausesCode])
    ).

%% ============================================
%% RECURSION DETECTION AND PATTERNS
%% ============================================

%% is_recursive_predicate_jython(+Name, +Clauses)
is_recursive_predicate_jython(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_jython(Body, Name).

%% is_recursive_clause_jython(+Name, +Clause)
is_recursive_clause_jython(Name, (_, Body)) :-
    contains_recursive_call_jython(Body, Name).

%% is_tail_recursive_jython(+Name, +RecClauses)
is_tail_recursive_jython(Name, RecClauses) :-
    member((_, Body), RecClauses),
    get_last_goal_jython(Body, LastGoal),
    functor(LastGoal, Name, _).

%% get_last_goal_jython(+Body, -LastGoal)
get_last_goal_jython((_, B), LastGoal) :- !, get_last_goal_jython(B, LastGoal).
get_last_goal_jython(Goal, Goal).

%% contains_recursive_call_jython(+Body, +Name)
contains_recursive_call_jython(Body, Name) :-
    extract_goal_jython(Body, Goal),
    functor(Goal, Name, _),
    !.

%% extract_goal_jython(+Body, -Goal)
extract_goal_jython(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_jython((A, _), Goal) :- extract_goal_jython(A, Goal).
extract_goal_jython((_, B), Goal) :- extract_goal_jython(B, Goal).

%% ============================================
%% TAIL RECURSION PATTERN (→ while loop)
%% ============================================

%% compile_tail_recursive_jython(+Name, +BaseClauses, +RecClauses, -Code)
compile_tail_recursive_jython(Name, BaseClauses, RecClauses, Code) :-
    % Generate base case condition
    (   BaseClauses = [(BaseHead, _BaseBody)|_]
    ->  generate_base_condition_jython(BaseHead, BaseCondition)
    ;   BaseCondition = "False"
    ),
    
    % Generate recursive transformation
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_recursive_transform_jython(RecBody, Name, Transform)
    ;   Transform = "current"
    ),
    
    format(string(Code),
"    # Tail-recursive predicate: ~w - optimized to while loop
    current = dict(record)
    max_iterations = 10000
    
    for _ in xrange(max_iterations):
        # Base case check
        if ~w:
            yield current
            return
        
        # Recursive step (tail call transformed to loop)
        current = ~w
    
    # Exceeded max iterations
    print >> sys.stderr, 'Warning: Max iterations exceeded for ~w'
    yield current", [Name, BaseCondition, Transform, Name]).

%% generate_base_condition_jython(+Head, -Condition)
generate_base_condition_jython(Head, Condition) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), "current.get('arg0') == ~w", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition), "current.get('arg0') == '~w'", [Arg])
        ;   Condition = "False"
        )
    ;   Condition = "False"
    ).

%% generate_recursive_transform_jython(+Body, +Name, -Transform)
generate_recursive_transform_jython(Body, Name, Transform) :-
    extract_goal_jython(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_],
        expr_to_jython(Expr, JythonExpr),
        format(string(Transform), "{'arg0': ~w}", [JythonExpr])
    ;   Transform = "current"
    ).

%% ============================================
%% GENERAL RECURSION PATTERN (→ memoization)
%% ============================================

%% compile_general_recursive_jython(+Name, +BaseClauses, +RecClauses, -Code)
compile_general_recursive_jython(Name, BaseClauses, RecClauses, Code) :-
    % Generate base case
    (   BaseClauses = [(BaseHead, _BaseBody)|_]
    ->  generate_base_condition_jython(BaseHead, BaseCondition)
    ;   BaseCondition = "False"
    ),
    
    % Generate recursive case
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_memoized_recursive_jython(RecBody, Name, RecursiveComputation)
    ;   RecursiveComputation = "current"
    ),
    
    format(string(Code),
"    # General recursive predicate: ~w - with memoization
    memo = record.get('__memo__', {})
    
    key = str(record.get('arg0'))
    if key in memo:
        yield memo[key]
        return
    
    current = dict(record)
    
    # Base case check
    if ~w:
        memo[key] = current
        yield current
        return
    
    # Recursive computation with memoization
    result = ~w
    memo[key] = result
    yield result", [Name, BaseCondition, RecursiveComputation]).

%% generate_memoized_recursive_jython(+Body, +Name, -Code)
generate_memoized_recursive_jython(Body, Name, Code) :-
    extract_goal_jython(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_]
    ->  expr_to_jython(Expr, JythonExpr),
        format(string(Code),
"list(process({'arg0': ~w, '__memo__': memo}))[0]", [JythonExpr])
    ;   Code = "current"
    ).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

%% translate_clause_jython(+Head, +Body, -Code)
translate_clause_jython(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    % Generate input extraction
    generate_input_extraction_jython(Args, InputCode),
    % Translate body
    (   Body == true
    ->  BodyCode = "    # Fact - no conditions"
    ;   translate_body_jython(Body, BodyCode)
    ),
    % Generate output
    format(string(Code), "~w\n~w\n    yield record", [InputCode, BodyCode]).

%% generate_input_extraction_jython(+Args, -Code)
generate_input_extraction_jython(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "    arg~w = record.get('arg~w')", [I, I])
        ;   format(string(Line), "    # arg~w = ~w (constant)", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% ============================================
%% BODY TRANSLATION
%% ============================================

%% translate_body_jython(+Body, -Code)
translate_body_jython((Goal, Rest), Code) :-
    !,
    translate_goal_jython(Goal, Code1),
    translate_body_jython(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_jython(Goal, Code) :-
    translate_goal_jython(Goal, Code).

%% translate_goal_jython(+Goal, -Code)

% Assignment: X = Value
translate_goal_jython(=(Var, Value), Code) :-
    var(Var), !,
    var_to_jython(Var, JythonVar),
    value_to_jython(Value, JythonValue),
    format(string(Code), "    ~w = ~w", [JythonVar, JythonValue]).

% Comparison: X > Y, X < Y, etc.
translate_goal_jython(>(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if not (~w > ~w): return", [JX, JY]).

translate_goal_jython(<(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if not (~w < ~w): return", [JX, JY]).

translate_goal_jython(>=(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if not (~w >= ~w): return", [JX, JY]).

translate_goal_jython(=<(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if not (~w <= ~w): return", [JX, JY]).

translate_goal_jython(=:=(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if ~w != ~w: return", [JX, JY]).

translate_goal_jython(=\\=(X, Y), Code) :-
    !,
    expr_to_jython(X, JX),
    expr_to_jython(Y, JY),
    format(string(Code), "    if ~w == ~w: return", [JX, JY]).

% Arithmetic: X is Expr
translate_goal_jython(is(Var, Expr), Code) :-
    !,
    var_to_jython(Var, JythonVar),
    expr_to_jython(Expr, JythonExpr),
    format(string(Code), "    ~w = ~w", [JythonVar, JythonExpr]).

% get_dict/3: get_dict(Key, Dict, Value)
translate_goal_jython(get_dict(Key, Dict, Value), Code) :-
    !,
    var_to_jython(Dict, JythonDict),
    var_to_jython(Value, JythonValue),
    format(string(Code), "    ~w = ~w.get('~w')", [JythonValue, JythonDict, Key]).

% put_dict/3
translate_goal_jython(put_dict(Updates, Dict, NewDict), Code) :-
    !,
    var_to_jython(Dict, JythonDict),
    var_to_jython(NewDict, JythonNewDict),
    format(string(Code), "    ~w = dict(~w)\n    ~w.update(~w)", 
           [JythonNewDict, JythonDict, JythonNewDict, Updates]).

% true - no-op
translate_goal_jython(true, Code) :-
    !,
    Code = "    pass  # true".

% Unknown goal - comment
translate_goal_jython(Goal, Code) :-
    format(string(Code), "    # TODO: ~w", [Goal]).

%% ============================================
%% HELPER PREDICATES
%% ============================================

%% var_to_jython(+Var, -JythonVar)
var_to_jython(Var, JythonVar) :-
    (   var(Var)
    ->  term_to_atom(Var, VarAtom),
        format(atom(JythonVar), "var_~w", [VarAtom])
    ;   Var = '$VAR'(N)
    ->  format(atom(JythonVar), "v_~w", [N])
    ;   term_to_atom(Var, JythonVar)
    ).

%% value_to_jython(+Value, -JythonValue)
value_to_jython(Value, JythonValue) :-
    (   number(Value)
    ->  format(atom(JythonValue), "~w", [Value])
    ;   atom(Value)
    ->  format(atom(JythonValue), "'~w'", [Value])
    ;   var(Value)
    ->  var_to_jython(Value, JythonValue)
    ;   format(atom(JythonValue), "~w", [Value])
    ).

%% expr_to_jython(+Expr, -JythonExpr)
expr_to_jython(Expr, JythonExpr) :-
    (   number(Expr)
    ->  format(atom(JythonExpr), "~w", [Expr])
    ;   var(Expr)
    ->  var_to_jython(Expr, JythonExpr)
    ;   Expr = '$VAR'(N)
    ->  format(atom(JythonExpr), "v_~w", [N])
    ;   Expr = X + Y
    ->  expr_to_jython(X, JX), expr_to_jython(Y, JY),
        format(atom(JythonExpr), "(~w + ~w)", [JX, JY])
    ;   Expr = X - Y
    ->  expr_to_jython(X, JX), expr_to_jython(Y, JY),
        format(atom(JythonExpr), "(~w - ~w)", [JX, JY])
    ;   Expr = X * Y
    ->  expr_to_jython(X, JX), expr_to_jython(Y, JY),
        format(atom(JythonExpr), "(~w * ~w)", [JX, JY])
    ;   Expr = X / Y
    ->  expr_to_jython(X, JX), expr_to_jython(Y, JY),
        format(atom(JythonExpr), "(~w / ~w)", [JX, JY])
    ;   Expr = X mod Y
    ->  expr_to_jython(X, JX), expr_to_jython(Y, JY),
        format(atom(JythonExpr), "(~w % ~w)", [JX, JY])
    ;   format(atom(JythonExpr), "~w", [Expr])
    ).

%% ============================================
%% PIPELINE COMPILATION
%% ============================================

%% compile_jython_pipeline(+Steps, +Options, -JythonCode)
compile_jython_pipeline(Steps, Options, JythonCode) :-
    % Standard imports
    collect_jython_import(sys),
    collect_jython_import(json),
    
    % Generate step functions
    generate_step_functions_jython(Steps, 1, StepFunctions),
    
    % Generate pipeline orchestration
    generate_pipeline_orchestration_jython(Steps, OrchestrationCode),
    
    get_jython_imports(ImportList),
    format_jython_imports(ImportList, ImportsStr),
    
    (   option(pipeline_name(PipelineName), Options)
    ->  true
    ;   PipelineName = 'pipeline'
    ),
    
    format(string(JythonCode),
"#!/usr/bin/env jython
# -*- coding: utf-8 -*-
# Generated by UnifyWeaver Jython Target - Multi-Step Pipeline

from __future__ import print_function
~w
from java.io import BufferedReader, InputStreamReader
from java.lang import System as JavaSystem

~w

def ~w(records):
    '''Execute the full pipeline.'''
    for record in records:
~w
        yield record

def read_jsonl(stream):
    '''Read JSONL from input stream.'''
    reader = BufferedReader(InputStreamReader(stream))
    line = reader.readLine()
    while line is not None:
        if line.strip():
            yield json.loads(line)
        line = reader.readLine()

if __name__ == '__main__':
    for result in ~w(read_jsonl(JavaSystem.in)):
        print(json.dumps(result))
", [ImportsStr, StepFunctions, PipelineName, OrchestrationCode, PipelineName]).

%% generate_step_functions_jython(+Steps, +N, -Code)
generate_step_functions_jython([], _, "").
generate_step_functions_jython([step(Name, Target, _Script, _Opts)|Rest], N, Code) :-
    format(string(StepCode),
"def step_~w(record):
    '''Step ~w: ~w (~w)'''
    # TODO: Implement ~w logic
    return record

", [Name, N, Name, Target, Target]),
    N1 is N + 1,
    generate_step_functions_jython(Rest, N1, RestCode),
    atom_concat(StepCode, RestCode, Code).

%% generate_pipeline_orchestration_jython(+Steps, -Code)
generate_pipeline_orchestration_jython(Steps, Code) :-
    findall(CallCode,
        (   member(step(Name, _, _, _), Steps),
            format(string(CallCode), "        record = step_~w(record)\n        if record is None: continue", [Name])
        ),
        Calls),
    atomic_list_concat(Calls, '\n', Code).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

%% write_jython_program(+JythonCode, +FilePath)
write_jython_program(JythonCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, JythonCode),
    close(Stream),
    format('Written Jython program to: ~w~n', [FilePath]).

%% option(+Option, +Options, +Default)
option(Option, Options, _Default) :-
    member(Option, Options),
    !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

%% ============================================
%% TESTS
%% ============================================

test_jython_pipeline_mode :-
    format('~n=== Testing Jython Pipeline Mode ===~n~n'),
    
    % Test 1: Basic pipeline generation
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_jython(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'run_pipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    % Test 2: Java imports
    format('~nTest 2: Java System imports~n'),
    (   sub_atom(Code1, _, _, _, 'JavaSystem')
    ->  format('  [PASS] Java System import present~n')
    ;   format('  [FAIL] Missing Java imports~n')
    ),
    
    % Test 3: Python 2 syntax
    format('~nTest 3: Python 2 syntax (xrange in tail recursion)~n'),
    format('  [INFO] Uses print_function from __future__~n'),
    
    format('~n=== Jython Pipeline Mode Tests Complete ===~n').
