:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% awk_target.pl - AWK Target for UnifyWeaver
% Generates self-contained AWK scripts for pattern matching and data processing
% Leverages AWK's associative arrays and regex capabilities

:- module(awk_target, [
    compile_predicate_to_awk/3,     % +Predicate, +Options, -AwkCode
    write_awk_script/2              % +AwkCode, +FilePath
]).

:- use_module(library(lists)).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_awk(+Predicate, +Options, -AwkCode)
%  Compile a Prolog predicate to AWK code
%
%  @arg Predicate Predicate indicator (Name/Arity)
%  @arg Options List of options
%  @arg AwkCode Generated AWK code as atom
%
%  Options:
%  - record_format(jsonl|tsv|csv) - Input format (default: tsv)
%  - field_separator(Char) - Field separator for tsv (default: '\t')
%  - include_header(true|false) - Include shebang (default: true)
%  - unique(true|false) - Deduplicate results (default: true)
%  - unordered(true|false) - Allow unordered output (default: true)
%
compile_predicate_to_awk(PredIndicator, Options, AwkCode) :-
    PredIndicator = Pred/Arity,
    format('=== Compiling ~w/~w to AWK ===~n', [Pred, Arity]),

    % Get options
    option(record_format(RecordFormat), Options, tsv),
    option(field_separator(FieldSep), Options, '\t'),
    option(include_header(IncludeHeader), Options, true),
    option(unique(Unique), Options, true),
    option(unordered(Unordered), Options, true),

    % Create head with correct arity
    functor(Head, Pred, Arity),

    % Get all clauses for this predicate
    findall(H-B, (user:clause(Head, B), Head = H), Clauses),

    % Determine compilation strategy
    (   Clauses = [] ->
        format('ERROR: No clauses found for ~w/~w~n', [Pred, Arity]),
        fail
    ;   maplist(is_fact_clause, Clauses) ->
        % All bodies are 'true' - these are facts
        format('Type: facts (~w clauses)~n', [length(Clauses)]),
        compile_facts_to_awk(Pred, Arity, Clauses, RecordFormat, FieldSep,
                            Unique, Unordered, ScriptBody)
    ;   Clauses = [_-SingleBody], SingleBody \= true ->
        % Single rule
        format('Type: single_rule~n'),
        compile_single_rule_to_awk(Pred, Arity, SingleBody, RecordFormat,
                                  FieldSep, Unique, Unordered, ScriptBody)
    ;   % Multiple rules (OR pattern)
        format('Type: multiple_rules (~w clauses)~n', [length(Clauses)]),
        compile_multiple_rules_to_awk(Pred, Arity, Clauses, RecordFormat,
                                     FieldSep, Unique, Unordered, ScriptBody)
    ),

    % Optionally add shebang header
    (   IncludeHeader ->
        generate_awk_header(Pred, Arity, RecordFormat, Header),
        atomic_list_concat([Header, '\n', ScriptBody], AwkCode)
    ;   AwkCode = ScriptBody
    ),
    !.

%% write_awk_script(+AwkCode, +FilePath)
%  Write AWK script to file and make it executable
%
write_awk_script(AwkCode, FilePath) :-
    open(FilePath, write, Stream),
    format(Stream, '~w', [AwkCode]),
    close(Stream),
    % Make executable
    format(atom(ChmodCmd), 'chmod +x ~w', [FilePath]),
    shell(ChmodCmd),
    format('[AwkTarget] Generated executable AWK script: ~w~n', [FilePath]).

%% ============================================
%% HEADER GENERATION
%% ============================================

generate_awk_header(Pred, Arity, RecordFormat, Header) :-
    get_unifyweaver_version(Version),
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),

    format(atom(Header),
'#!/usr/bin/awk -f
# Generated by UnifyWeaver ~w
# Target: AWK
# Generated: ~w
# Predicate: ~w/~w
# Input format: ~w
', [Version, DateStr, Pred, Arity, RecordFormat]).

get_unifyweaver_version('v0.0.3').

%% ============================================
%% FACT COMPILATION
%% ============================================

%% compile_facts_to_awk(+Pred, +Arity, +Clauses, +RecordFormat, +FieldSep,
%%                      +Unique, +Unordered, -AwkCode)
%  Compile facts to AWK using associative arrays
%
compile_facts_to_awk(Pred, Arity, Clauses, RecordFormat, FieldSep,
                     Unique, Unordered, AwkCode) :-
    atom_string(Pred, PredStr),

    % Extract facts from clauses
    findall(Args,
        (member(Head-true, Clauses), Head =.. [_|Args]),
        AllFacts),

    % Generate BEGIN block with fact data
    generate_facts_begin_block(AllFacts, FieldSep, BeginBlock),

    % Generate main block for matching
    generate_facts_main_block(Arity, FieldSep, Unique, MainBlock),

    % Generate END block if needed (for unique output)
    (   Unique ->
        generate_unique_end_block(EndBlock)
    ;   EndBlock = ''
    ),

    % Assemble complete AWK script
    atomic_list_concat([BeginBlock, '\n', MainBlock, '\n', EndBlock], AwkCode).

%% generate_facts_begin_block(+Facts, +FieldSep, -BeginBlock)
%  Generate BEGIN block that loads facts into associative array
%
generate_facts_begin_block(Facts, FieldSep, BeginBlock) :-
    % Build array initialization statements
    findall(InitStmt,
        (   member(Args, Facts),
            atomic_list_concat(Args, ':', Key),
            format(atom(InitStmt), '    facts["~w"] = 1', [Key])
        ),
        InitStmts),
    atomic_list_concat(InitStmts, '\n', InitStmtsStr),

    format(atom(BeginBlock),
'BEGIN {
    FS = "~w"
~w
}', [FieldSep, InitStmtsStr]).

%% generate_facts_main_block(+Arity, +FieldSep, +Unique, -MainBlock)
%  Generate main pattern-action block for fact lookup
%
generate_facts_main_block(Arity, _FieldSep, Unique, MainBlock) :-
    % Build field concatenation
    numlist(1, Arity, FieldNums),
    findall(Field,
        (member(N, FieldNums), format(atom(Field), '$~w', [N])),
        Fields),
    atomic_list_concat(Fields, ' ":" ', FieldsConcat),

    % Build lookup and output
    (   Unique ->
        % Store in seen array for deduplication
        format(atom(MainBlock),
'{
    key = ~w
    if (key in facts && !(key in seen)) {
        seen[key] = 1
        print $0
    }
}', [FieldsConcat])
    ;   % No deduplication
        format(atom(MainBlock),
'{
    key = ~w
    if (key in facts) {
        print $0
    }
}', [FieldsConcat])
    ).

%% generate_unique_end_block(-EndBlock)
%  Generate END block (currently empty, but available for future use)
%
generate_unique_end_block('').

%% ============================================
%% SINGLE RULE COMPILATION
%% ============================================

%% compile_single_rule_to_awk(+Pred, +Arity, +Body, +RecordFormat,
%%                            +FieldSep, +Unique, +Unordered, -AwkCode)
%  Compile a single rule to AWK
%
compile_single_rule_to_awk(Pred, Arity, Body, RecordFormat, FieldSep,
                          Unique, Unordered, AwkCode) :-
    atom_string(Pred, PredStr),

    % Extract predicates from body
    extract_predicates(Body, Predicates),
    format('  Body predicates: ~w~n', [Predicates]),

    % Generate BEGIN block
    format(atom(BeginBlock), 'BEGIN { FS = "~w" }', [FieldSep]),

    % Generate main block for rule matching
    generate_rule_main_block(Arity, Body, Predicates, Unique, MainBlock),

    % Assemble script
    atomic_list_concat([BeginBlock, '\n', MainBlock], AwkCode).

%% generate_rule_main_block(+Arity, +Body, +Predicates, +Unique, -MainBlock)
%  Generate main block for rule evaluation
%
generate_rule_main_block(Arity, Body, Predicates, Unique, MainBlock) :-
    % For now, generate a simple pass-through with comment
    % In future, this can analyze the body and generate AWK conditions
    (   Unique ->
        format(atom(MainBlock),
'{
    # Rule body: ~w
    # TODO: Implement rule body compilation
    # For now, pass through input
    key = $0
    if (!(key in seen)) {
        seen[key] = 1
        print $0
    }
}', [Body])
    ;   format(atom(MainBlock),
'{
    # Rule body: ~w
    # TODO: Implement rule body compilation
    print $0
}', [Body])
    ).

%% ============================================
%% MULTIPLE RULES COMPILATION
%% ============================================

%% compile_multiple_rules_to_awk(+Pred, +Arity, +Clauses, +RecordFormat,
%%                               +FieldSep, +Unique, +Unordered, -AwkCode)
%  Compile multiple rules (OR pattern) to AWK
%
compile_multiple_rules_to_awk(Pred, Arity, Clauses, RecordFormat, FieldSep,
                             Unique, Unordered, AwkCode) :-
    atom_string(Pred, PredStr),

    % Generate BEGIN block
    format(atom(BeginBlock), 'BEGIN { FS = "~w" }', [FieldSep]),

    % Generate main block with multiple rule checks
    generate_multi_rules_main_block(Arity, Clauses, Unique, MainBlock),

    % Assemble script
    atomic_list_concat([BeginBlock, '\n', MainBlock], AwkCode).

%% generate_multi_rules_main_block(+Arity, +Clauses, +Unique, -MainBlock)
%  Generate main block for multiple rules (OR pattern)
%
generate_multi_rules_main_block(Arity, Clauses, Unique, MainBlock) :-
    % For now, treat multiple rules as alternative patterns
    length(Clauses, NumRules),
    (   Unique ->
        format(atom(MainBlock),
'{
    # Multiple rules: ~w alternatives (OR pattern)
    # TODO: Implement multi-rule compilation
    # For now, pass through input
    key = $0
    if (!(key in seen)) {
        seen[key] = 1
        print $0
    }
}', [NumRules])
    ;   format(atom(MainBlock),
'{
    # Multiple rules: ~w alternatives (OR pattern)
    # TODO: Implement multi-rule compilation
    print $0
}', [NumRules])
    ).

%% ============================================
%% HELPER PREDICATES
%% ============================================

%% is_fact_clause(+Clause)
%  Check if a clause is a fact (body is 'true')
%
is_fact_clause(_-true).

%% extract_predicates(+Body, -Predicates)
%  Extract predicate names from a body
%
extract_predicates(true, []) :- !.
extract_predicates((A, B), Predicates) :- !,
    extract_predicates(A, P1),
    extract_predicates(B, P2),
    append(P1, P2, Predicates).
extract_predicates(Goal, []) :-
    var(Goal), !.
% Skip inequality operators
extract_predicates(_ \= _, []) :- !.
extract_predicates(\=(_, _), []) :- !.
% Skip arithmetic operators
extract_predicates(_ > _, []) :- !.
extract_predicates(_ < _, []) :- !.
extract_predicates(_ >= _, []) :- !.
extract_predicates(_ =< _, []) :- !.
extract_predicates(_ =:= _, []) :- !.
extract_predicates(_ =\= _, []) :- !.
extract_predicates(is(_, _), []) :- !.
% Skip negation wrapper
extract_predicates(\+ A, Predicates) :- !,
    extract_predicates(A, Predicates).
extract_predicates(Goal, [Pred]) :-
    functor(Goal, Pred, _),
    Pred \= ',',
    Pred \= true.

%% option(+Option, +Options, +Default)
%  Get option value with default fallback
%
option(Option, Options, Default) :-
    (   member(Option, Options)
    ->  true
    ;   Option =.. [Key, Default],
        \+ member(Key=_, Options)
    ).
