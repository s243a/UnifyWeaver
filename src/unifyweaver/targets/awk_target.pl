:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% awk_target.pl - AWK Target for UnifyWeaver
% Generates self-contained AWK scripts for pattern matching and data processing
% Leverages AWK's associative arrays and regex capabilities

:- module(awk_target, [
    compile_predicate_to_awk/3,     % +Predicate, +Options, -AwkCode
    write_awk_script/2              % +AwkCode, +FilePath
]).

:- use_module(library(lists)).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_awk(+Predicate, +Options, -AwkCode)
%  Compile a Prolog predicate to AWK code
%
%  @arg Predicate Predicate indicator (Name/Arity)
%  @arg Options List of options
%  @arg AwkCode Generated AWK code as atom
%
%  Options:
%  - record_format(jsonl|tsv|csv) - Input format (default: tsv)
%  - field_separator(Char) - Field separator for tsv (default: '\t')
%  - include_header(true|false) - Include shebang (default: true)
%  - unique(true|false) - Deduplicate results (default: true)
%  - unordered(true|false) - Allow unordered output (default: true)
%
compile_predicate_to_awk(PredIndicator, Options, AwkCode) :-
    PredIndicator = Pred/Arity,
    format('=== Compiling ~w/~w to AWK ===~n', [Pred, Arity]),

    % Get options
    option(record_format(RecordFormat), Options, tsv),
    option(field_separator(FieldSep), Options, '\t'),
    option(include_header(IncludeHeader), Options, true),
    option(unique(Unique), Options, true),
    option(unordered(Unordered), Options, true),

    % Create head with correct arity
    functor(Head, Pred, Arity),

    % Get all clauses for this predicate
    findall(H-B, (user:clause(Head, B), Head = H), Clauses),

    % Determine compilation strategy
    (   Clauses = [] ->
        format('ERROR: No clauses found for ~w/~w~n', [Pred, Arity]),
        fail
    ;   maplist(is_fact_clause, Clauses) ->
        % All bodies are 'true' - these are facts
        format('Type: facts (~w clauses)~n', [length(Clauses)]),
        compile_facts_to_awk(Pred, Arity, Clauses, RecordFormat, FieldSep,
                            Unique, Unordered, ScriptBody)
    ;   Clauses = [_-SingleBody], SingleBody \= true ->
        % Single rule
        format('Type: single_rule~n'),
        compile_single_rule_to_awk(Pred, Arity, SingleBody, RecordFormat,
                                  FieldSep, Unique, Unordered, ScriptBody)
    ;   % Multiple rules (OR pattern)
        format('Type: multiple_rules (~w clauses)~n', [length(Clauses)]),
        compile_multiple_rules_to_awk(Pred, Arity, Clauses, RecordFormat,
                                     FieldSep, Unique, Unordered, ScriptBody)
    ),

    % Optionally add shebang header
    (   IncludeHeader ->
        generate_awk_header(Pred, Arity, RecordFormat, Header),
        atomic_list_concat([Header, '\n', ScriptBody], AwkCode)
    ;   AwkCode = ScriptBody
    ),
    !.

%% write_awk_script(+AwkCode, +FilePath)
%  Write AWK script to file and make it executable
%
write_awk_script(AwkCode, FilePath) :-
    open(FilePath, write, Stream),
    format(Stream, '~w', [AwkCode]),
    close(Stream),
    % Make executable
    format(atom(ChmodCmd), 'chmod +x ~w', [FilePath]),
    shell(ChmodCmd),
    format('[AwkTarget] Generated executable AWK script: ~w~n', [FilePath]).

%% ============================================
%% HEADER GENERATION
%% ============================================

generate_awk_header(Pred, Arity, RecordFormat, Header) :-
    get_unifyweaver_version(Version),
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),

    format(atom(Header),
'#!/usr/bin/awk -f
# Generated by UnifyWeaver ~w
# Target: AWK
# Generated: ~w
# Predicate: ~w/~w
# Input format: ~w
', [Version, DateStr, Pred, Arity, RecordFormat]).

get_unifyweaver_version('v0.0.3').

%% ============================================
%% FACT COMPILATION
%% ============================================

%% compile_facts_to_awk(+Pred, +Arity, +Clauses, +RecordFormat, +FieldSep,
%%                      +Unique, +Unordered, -AwkCode)
%  Compile facts to AWK using associative arrays
%
compile_facts_to_awk(Pred, Arity, Clauses, _RecordFormat, FieldSep,
                     Unique, _Unordered, AwkCode) :-
    atom_string(Pred, _PredStr),

    % Extract facts from clauses
    findall(Args,
        (member(Head-true, Clauses), Head =.. [_|Args]),
        AllFacts),

    % Generate BEGIN block with fact data
    generate_facts_begin_block(AllFacts, FieldSep, BeginBlock),

    % Generate main block for matching
    generate_facts_main_block(Arity, FieldSep, Unique, MainBlock),

    % Generate END block if needed (for unique output)
    (   Unique ->
        generate_unique_end_block(EndBlock)
    ;   EndBlock = ''
    ),

    % Assemble complete AWK script
    atomic_list_concat([BeginBlock, '\n', MainBlock, '\n', EndBlock], AwkCode).

%% generate_facts_begin_block(+Facts, +FieldSep, -BeginBlock)
%  Generate BEGIN block that loads facts into associative array
%
generate_facts_begin_block(Facts, FieldSep, BeginBlock) :-
    % Build array initialization statements
    findall(InitStmt,
        (   member(Args, Facts),
            atomic_list_concat(Args, ':', Key),
            format(atom(InitStmt), '    facts["~w"] = 1', [Key])
        ),
        InitStmts),
    atomic_list_concat(InitStmts, '\n', InitStmtsStr),

    format(atom(BeginBlock),
'BEGIN {
    FS = "~w"
~w
}', [FieldSep, InitStmtsStr]).

%% generate_facts_main_block(+Arity, +FieldSep, +Unique, -MainBlock)
%  Generate main pattern-action block for fact lookup
%
generate_facts_main_block(Arity, _FieldSep, Unique, MainBlock) :-
    % Build field concatenation
    numlist(1, Arity, FieldNums),
    findall(Field,
        (member(N, FieldNums), format(atom(Field), '$~w', [N])),
        Fields),
    atomic_list_concat(Fields, ' ":" ', FieldsConcat),

    % Build lookup and output
    (   Unique ->
        % Store in seen array for deduplication
        format(atom(MainBlock),
'{
    key = ~w
    if (key in facts && !(key in seen)) {
        seen[key] = 1
        print $0
    }
}', [FieldsConcat])
    ;   % No deduplication
        format(atom(MainBlock),
'{
    key = ~w
    if (key in facts) {
        print $0
    }
}', [FieldsConcat])
    ).

%% generate_unique_end_block(-EndBlock)
%  Generate END block (currently empty, but available for future use)
%
generate_unique_end_block('').

%% ============================================
%% SINGLE RULE COMPILATION
%% ============================================

%% compile_single_rule_to_awk(+Pred, +Arity, +Body, +RecordFormat,
%%                            +FieldSep, +Unique, +Unordered, -AwkCode)
%  Compile a single rule to AWK
%
compile_single_rule_to_awk(Pred, Arity, Body, _RecordFormat, FieldSep,
                          Unique, _Unordered, AwkCode) :-
    atom_string(Pred, PredStr),

    % Extract predicates and constraints from body
    extract_predicates(Body, Predicates),
    extract_constraints(Body, Constraints),
    format('  Body predicates: ~w~n', [Predicates]),
    format('  Constraints: ~w~n', [Constraints]),

    % Determine compilation strategy
    (   Predicates = [] ->
        % No predicates - just constraints or empty body
        compile_constraint_only_rule(PredStr, Arity, Constraints, FieldSep, Unique, AwkCode)
    ;   Predicates = [SinglePred] ->
        % Single predicate - simple lookup with optional constraints
        compile_single_predicate_rule(PredStr, Arity, SinglePred, Constraints,
                                     FieldSep, Unique, AwkCode)
    ;   % Multiple predicates - hash join pipeline
        compile_multi_predicate_rule(PredStr, Arity, Predicates, Constraints,
                                    FieldSep, Unique, AwkCode)
    ).

%% compile_constraint_only_rule(+PredStr, +Arity, +Constraints, +FieldSep, +Unique, -AwkCode)
%  Compile a rule with no predicates (just constraints or empty body)
%
compile_constraint_only_rule(_PredStr, Arity, Constraints, FieldSep, Unique, AwkCode) :-
    (   Constraints = [] ->
        % No constraints - just pass through (always true)
        MainBlock = '{ print $0 }'
    ;   % Has constraints - generate AWK condition
        generate_constraint_code(Constraints, Arity, ConstraintCode),
        (   Unique ->
            format(atom(MainBlock),
'{
    if (~w) {
        key = $0
        if (!(key in seen)) {
            seen[key] = 1
            print $0
        }
    }
}', [ConstraintCode])
        ;   format(atom(MainBlock),
'{
    if (~w) {
        print $0
    }
}', [ConstraintCode])
        )
    ),
    format(atom(BeginBlock), 'BEGIN { FS = "~w" }', [FieldSep]),
    atomic_list_concat([BeginBlock, '\n', MainBlock], AwkCode).

%% compile_single_predicate_rule(+PredStr, +Arity, +Predicate, +Constraints,
%%                                +FieldSep, +Unique, -AwkCode)
%  Compile a rule with a single predicate (simple lookup)
%
compile_single_predicate_rule(_PredStr, Arity, Predicate, Constraints, FieldSep, Unique, AwkCode) :-
    % Need to load the predicate's facts
    atom_string(Predicate, PredLookupStr),

    % Get the predicate's arity by finding first clause
    current_predicate(Predicate/PredArity),
    functor(PredGoal, Predicate, PredArity),
    findall(PredGoal, user:clause(PredGoal, true), PredFacts),

    % Generate fact loading in BEGIN block
    findall(InitStmt,
        (   member(Fact, PredFacts),
            Fact =.. [_|Args],
            atomic_list_concat(Args, ':', Key),
            format(atom(InitStmt), '    ~w_data["~w"] = 1', [PredLookupStr, Key])
        ),
        InitStmts),
    atomic_list_concat(InitStmts, '\n', InitStmtsStr),

    % Generate main lookup logic
    % This depends on how the input maps to the predicate arguments
    % For now, assume direct mapping
    (   Constraints = [] ->
        ConstraintCheck = ''
    ;   generate_constraint_code(Constraints, Arity, ConstraintCode),
        format(atom(ConstraintCheck), ' && ~w', [ConstraintCode])
    ),

    % Build field concatenation based on predicate arity
    numlist(1, PredArity, FieldNums),
    findall(Field,
        (member(N, FieldNums), format(atom(Field), '$~w', [N])),
        Fields),
    atomic_list_concat(Fields, ' ":" ', FieldsConcat),

    (   Unique ->
        format(atom(MainBlock),
'{
    key = ~w
    if (key in ~w_data~w) {
        if (!(key in seen)) {
            seen[key] = 1
            print $0
        }
    }
}', [FieldsConcat, PredLookupStr, ConstraintCheck])
    ;   format(atom(MainBlock),
'{
    key = ~w
    if (key in ~w_data~w) {
        print $0
    }
}', [FieldsConcat, PredLookupStr, ConstraintCheck])
    ),

    format(atom(BeginBlock),
'BEGIN {
    FS = "~w"
~w
}', [FieldSep, InitStmtsStr]),
    atomic_list_concat([BeginBlock, '\n', MainBlock], AwkCode).

%% compile_multi_predicate_rule(+PredStr, +Arity, +Predicates, +Constraints,
%%                              +FieldSep, +Unique, -AwkCode)
%  Compile a rule with multiple predicates (hash join)
%
compile_multi_predicate_rule(_PredStr, _Arity, Predicates, Constraints, FieldSep, Unique, AwkCode) :-
    % For multiple predicates, we need to implement a hash join
    % Strategy: Load all predicate facts, then perform nested joins

    % Load all predicates' facts into arrays
    findall(LoadCode,
        (   member(Pred, Predicates),
            generate_predicate_loader(Pred, LoadCode)
        ),
        LoadCodes),
    atomic_list_concat(LoadCodes, '\n', AllLoadCode),

    % Generate join logic
    generate_join_logic(Predicates, Constraints, Unique, JoinLogic),

    format(atom(BeginBlock),
'BEGIN {
    FS = "~w"
~w
}', [FieldSep, AllLoadCode]),

    format(atom(EndBlock),
'END {
~w
}', [JoinLogic]),

    atomic_list_concat([BeginBlock, '\n# No input processing needed\n', EndBlock], AwkCode).

%% ============================================
%% HELPER FUNCTIONS FOR SINGLE RULE COMPILATION
%% ============================================

%% generate_constraint_code(+Constraints, +Arity, -AwkCode)
%  Generate AWK code for constraint checking
%
generate_constraint_code([], _, 'true') :- !.
generate_constraint_code(Constraints, Arity, AwkCode) :-
    findall(ConstraintCode,
        (   member(Constraint, Constraints),
            constraint_to_awk(Constraint, Arity, ConstraintCode)
        ),
        ConstraintCodes),
    atomic_list_concat(ConstraintCodes, ' && ', AwkCode).

%% constraint_to_awk(+Constraint, +Arity, -AwkCode)
%  Convert a single constraint to AWK code
%
constraint_to_awk(inequality(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w != ~w)', [AwkA, AwkB]).
constraint_to_awk(gt(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w > ~w)', [AwkA, AwkB]).
constraint_to_awk(lt(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w < ~w)', [AwkA, AwkB]).
constraint_to_awk(gte(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w >= ~w)', [AwkA, AwkB]).
constraint_to_awk(lte(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w <= ~w)', [AwkA, AwkB]).
constraint_to_awk(eq(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w == ~w)', [AwkA, AwkB]).
constraint_to_awk(neq(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '(~w != ~w)', [AwkA, AwkB]).
constraint_to_awk(is(A, B), Arity, AwkCode) :-
    term_to_awk_expr(A, Arity, AwkA),
    term_to_awk_expr(B, Arity, AwkB),
    format(atom(AwkCode), '((~w = ~w), 1)', [AwkA, AwkB]).

%% term_to_awk_expr(+Term, +Arity, -AwkExpr)
%  Convert a Prolog term to an AWK expression
%
term_to_awk_expr(Term, _Arity, AwkExpr) :-
    atom(Term), !,
    % Check if it's a variable (starts with uppercase)
    atom_chars(Term, [First|_]),
    char_type(First, upper), !,
    % Map variable to field number (simplified - assumes positional mapping)
    atom_codes(Term, [FirstCode|_]),
    FieldNum is FirstCode - 64,  % A=1, B=2, C=3, etc.
    format(atom(AwkExpr), '$~w', [FieldNum]).
term_to_awk_expr(Term, _Arity, Term) :-
    number(Term), !.
term_to_awk_expr(Term, Arity, AwkExpr) :-
    compound(Term), !,
    Term =.. [Op, Left, Right],
    term_to_awk_expr(Left, Arity, AwkLeft),
    term_to_awk_expr(Right, Arity, AwkRight),
    format(atom(AwkExpr), '(~w ~w ~w)', [AwkLeft, Op, AwkRight]).
term_to_awk_expr(Term, _Arity, Term).

%% generate_predicate_loader(+Predicate, -LoadCode)
%  Generate AWK code to load a predicate's facts into an array
%
generate_predicate_loader(Predicate, LoadCode) :-
    atom_string(Predicate, PredStr),
    current_predicate(Predicate/PredArity),
    functor(PredGoal, Predicate, PredArity),
    findall(PredGoal, user:clause(PredGoal, true), PredFacts),
    findall(InitStmt,
        (   member(Fact, PredFacts),
            Fact =.. [_|Args],
            atomic_list_concat(Args, ':', Key),
            format(atom(InitStmt), '    ~w_data["~w"] = 1', [PredStr, Key])
        ),
        InitStmts),
    atomic_list_concat(InitStmts, '\n', LoadCode).

%% generate_join_logic(+Predicates, +Constraints, +Unique, -JoinLogic)
%  Generate AWK code for hash join of multiple predicates
%
generate_join_logic([Pred1, Pred2|_Rest], _Constraints, Unique, JoinLogic) :-
    % Simple two-way join for now
    % More complex joins would require analyzing variable bindings
    atom_string(Pred1, Pred1Str),
    atom_string(Pred2, Pred2Str),

    % Generate nested loop join (simple but works)
    (   Unique ->
        format(atom(JoinLogic),
'    for (key1 in ~w_data) {
        split(key1, a, ":")
        for (key2 in ~w_data) {
            split(key2, b, ":")
            # Simple join condition: last field of first matches first field of second
            if (a[length(a)] == b[1]) {
                # Build result
                result = a[1]
                for (i = 2; i <= length(a); i++) result = result ":" a[i]
                for (i = 2; i <= length(b); i++) result = result ":" b[i]
                if (!(result in seen)) {
                    seen[result] = 1
                    print result
                }
            }
        }
    }', [Pred1Str, Pred2Str])
    ;   format(atom(JoinLogic),
'    for (key1 in ~w_data) {
        split(key1, a, ":")
        for (key2 in ~w_data) {
            split(key2, b, ":")
            # Simple join condition: last field of first matches first field of second
            if (a[length(a)] == b[1]) {
                # Build result
                result = a[1]
                for (i = 2; i <= length(a); i++) result = result ":" a[i]
                for (i = 2; i <= length(b); i++) result = result ":" b[i]
                print result
            }
        }
    }', [Pred1Str, Pred2Str])
    ).

%% ============================================
%% MULTIPLE RULES COMPILATION
%% ============================================

%% compile_multiple_rules_to_awk(+Pred, +Arity, +Clauses, +RecordFormat,
%%                               +FieldSep, +Unique, +Unordered, -AwkCode)
%  Compile multiple rules (OR pattern) to AWK
%
compile_multiple_rules_to_awk(Pred, Arity, Clauses, _RecordFormat, FieldSep,
                             Unique, _Unordered, AwkCode) :-
    atom_string(Pred, _PredStr),

    % Generate BEGIN block
    format(atom(BeginBlock), 'BEGIN { FS = "~w" }', [FieldSep]),

    % Generate main block with multiple rule checks
    generate_multi_rules_main_block(Arity, Clauses, Unique, MainBlock),

    % Assemble script
    atomic_list_concat([BeginBlock, '\n', MainBlock], AwkCode).

%% generate_multi_rules_main_block(+Arity, +Clauses, +Unique, -MainBlock)
%  Generate main block for multiple rules (OR pattern)
%
generate_multi_rules_main_block(_Arity, Clauses, Unique, MainBlock) :-
    % For now, treat multiple rules as alternative patterns
    length(Clauses, NumRules),
    (   Unique ->
        format(atom(MainBlock),
'{
    # Multiple rules: ~w alternatives (OR pattern)
    # TODO: Implement multi-rule compilation
    # For now, pass through input
    key = $0
    if (!(key in seen)) {
        seen[key] = 1
        print $0
    }
}', [NumRules])
    ;   format(atom(MainBlock),
'{
    # Multiple rules: ~w alternatives (OR pattern)
    # TODO: Implement multi-rule compilation
    print $0
}', [NumRules])
    ).

%% ============================================
%% HELPER PREDICATES
%% ============================================

%% is_fact_clause(+Clause)
%  Check if a clause is a fact (body is 'true')
%
is_fact_clause(_-true).

%% extract_predicates(+Body, -Predicates)
%  Extract predicate names from a body
%
extract_predicates(true, []) :- !.
extract_predicates((A, B), Predicates) :- !,
    extract_predicates(A, P1),
    extract_predicates(B, P2),
    append(P1, P2, Predicates).
extract_predicates(Goal, []) :-
    var(Goal), !.
% Skip inequality operators
extract_predicates(_ \= _, []) :- !.
extract_predicates(\=(_, _), []) :- !.
% Skip arithmetic operators
extract_predicates(_ > _, []) :- !.
extract_predicates(_ < _, []) :- !.
extract_predicates(_ >= _, []) :- !.
extract_predicates(_ =< _, []) :- !.
extract_predicates(_ =:= _, []) :- !.
extract_predicates(_ =\= _, []) :- !.
extract_predicates(is(_, _), []) :- !.
% Skip negation wrapper
extract_predicates(\+ A, Predicates) :- !,
    extract_predicates(A, Predicates).
extract_predicates(Goal, [Pred]) :-
    functor(Goal, Pred, _),
    Pred \= ',',
    Pred \= true.

%% extract_constraints(+Body, -Constraints)
%  Extract constraints (inequalities, arithmetic) from body
%
extract_constraints(true, []) :- !.
extract_constraints((A, B), Constraints) :- !,
    extract_constraints(A, C1),
    extract_constraints(B, C2),
    append(C1, C2, Constraints).
extract_constraints(Goal, []) :-
    var(Goal), !.
% Capture inequality constraints
extract_constraints(A \= B, [inequality(A, B)]) :- !.
extract_constraints(\=(A, B), [inequality(A, B)]) :- !.
% Capture arithmetic constraints
extract_constraints(A > B, [gt(A, B)]) :- !.
extract_constraints(A < B, [lt(A, B)]) :- !.
extract_constraints(A >= B, [gte(A, B)]) :- !.
extract_constraints(A =< B, [lte(A, B)]) :- !.
extract_constraints(A =:= B, [eq(A, B)]) :- !.
extract_constraints(A =\= B, [neq(A, B)]) :- !.
extract_constraints(is(A, B), [is(A, B)]) :- !.
% Skip predicates
extract_constraints(Goal, []) :-
    functor(Goal, Pred, _),
    Pred \= ',',
    Pred \= true.

%% option(+Option, +Options, +Default)
%  Get option value with default fallback
%
option(Option, Options, Default) :-
    (   member(Option, Options)
    ->  true
    ;   Option =.. [Key, Default],
        \+ member(Key=_, Options)
    ).
