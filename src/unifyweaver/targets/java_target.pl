:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% java_target.pl - Java Target for UnifyWeaver
% Generates standalone Java programs for record/field processing
% Supports streaming JSONL I/O and Gradle build integration

:- module(java_target, [
    compile_predicate_to_java/3,      % +Predicate, +Options, -JavaCode
    compile_java_pipeline/3,          % +Predicates, +Options, -JavaCode
    write_java_program/2,             % +JavaCode, +FilePath
    generate_gradle_build/2,          % +Options, -GradleCode
    init_java_target/0,               % Initialize Java target
    test_java_pipeline_mode/0         % Test pipeline mode
]).

:- use_module(library(lists)).

% Track required imports
:- dynamic required_java_import/1.

%% init_java_target
%  Initialize Java target
init_java_target :-
    retractall(required_java_import(_)).

%% clear_java_imports
%  Clear collected Java imports
clear_java_imports :-
    retractall(required_java_import(_)).

%% collect_java_import(+Import)
%  Record that an import is required
collect_java_import(Import) :-
    (   required_java_import(Import)
    ->  true
    ;   assertz(required_java_import(Import))
    ).

%% get_java_imports(-Imports)
%  Get all collected imports
get_java_imports(Imports) :-
    findall(I, required_java_import(I), Imports).

%% format_java_imports(+Imports, -FormattedStr)
%  Format a list of imports for Java
format_java_imports([], "").
format_java_imports(Imports, FormattedStr) :-
    Imports \= [],
    sort(Imports, UniqueImports),
    findall(Formatted,
        (   member(Import, UniqueImports),
            format(string(Formatted), "import ~w;~n", [Import])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_java(+Predicate, +Options, -JavaCode)
%  Compile a Prolog predicate to Java code
%
%  @arg Predicate Predicate indicator (Name/Arity)
%  @arg Options List of options
%  @arg JavaCode Generated Java code as atom
%
%  Options:
%  - package(Name) - Java package name (default: 'generated')
%  - class_name(Name) - Class name (default: predicate name capitalized)
%  - pipeline_input(true|false) - Enable streaming input
%  - json_input(true|false) - Use JSONL input format
%  - main_class(true|false) - Generate main method (default: true)
%
compile_predicate_to_java(PredIndicator, Options, JavaCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to Java ===~n', [Pred, Arity]),

    % Clear any previously collected imports
    clear_java_imports,

    % Check for pipeline mode
    (   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_java(Pred, Arity, Options, JavaCode)
    % Default: simple predicate
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_java(Pred, Arity, Options, JavaCode)
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_java(Pred, Arity, Options, JavaCode) :-
    % Get options
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, Pred),
    capitalize_atom(ClassName, CapClassName),
    option(main_class(MainClass), Options, true),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate method for each clause
    (   Clauses == []
    ->  MethodCode = "    // No clauses found"
    ;   findall(Code, (member((H, B), Clauses), clause_to_java(H, B, Code)), MethodCodes),
        atomic_list_concat(MethodCodes, '\n', MethodCode)
    ),
    
    % Generate main if requested
    (   MainClass == true
    ->  MainCode = "
    public static void main(String[] args) {
        // TODO: Add main logic
    }"
    ;   MainCode = ""
    ),
    
    % Standard imports for simple mode
    collect_java_import('java.util.*'),
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target
// Predicate: ~w/~w

package ~w;

~w
public class ~w {

~w
~w
}
", [Pred, Arity, Package, ImportsStr, CapClassName, MethodCode, MainCode]).

%% clause_to_java(+Head, +Body, -Code)
%  Convert a single clause to Java code (stub for now)
clause_to_java(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    length(Args, _Arity),
    (   Body == true
    ->  format(string(Code), "    // Fact: ~w", [Head])
    ;   format(string(Code), "    // Rule: ~w :- ~w", [Head, Body])
    ).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_java(Pred, Arity, Options, JavaCode) :-
    % Get options
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, Pred),
    capitalize_atom(ClassName, CapClassName),
    
    % Standard pipeline imports
    collect_java_import('java.io.*'),
    collect_java_import('java.util.*'),
    collect_java_import('java.util.stream.*'),
    collect_java_import('com.google.gson.*'),
    collect_java_import('com.google.gson.reflect.TypeToken'),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate process method
    (   Clauses == []
    ->  ProcessCode = "        // No clauses found - pass through
        return Optional.of(record);"
    ;   generate_pipeline_process(Clauses, ProcessCode)
    ),
    
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target - Pipeline Mode
// Predicate: ~w/~w

package ~w;

~w
/**
 * Pipeline processor for ~w predicate.
 * Reads JSONL from stdin, processes each record, writes JSONL to stdout.
 */
public class ~w {

    private static final Gson gson = new Gson();

    /**
     * Process a single input record.
     * @param record Input record as Map
     * @return Optional output record (empty to filter out)
     */
    public static Optional<Map<String, Object>> process(Map<String, Object> record) {
~w
    }

    /**
     * Run the pipeline: read from stdin, process, write to stdout.
     */
    public static void runPipeline() throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.trim().isEmpty()) continue;
            
            try {
                Map<String, Object> record = gson.fromJson(
                    line, 
                    new TypeToken<Map<String, Object>>(){}.getType()
                );
                
                Optional<Map<String, Object>> result = process(record);
                result.ifPresent(r -> writer.println(gson.toJson(r)));
                
            } catch (JsonSyntaxException e) {
                System.err.println(\"JSON parse error: \" + e.getMessage());
            }
        }
        
        writer.flush();
    }

    public static void main(String[] args) {
        try {
            runPipeline();
        } catch (IOException e) {
            System.err.println(\"I/O error: \" + e.getMessage());
            System.exit(1);
        }
    }
}
", [Pred, Arity, Package, ImportsStr, Pred, CapClassName, ProcessCode]).

%% generate_pipeline_process(+Clauses, -Code)
%  Generate process method body from clauses
generate_pipeline_process([], "        return Optional.of(record);").
generate_pipeline_process([(_Head, Body)|_Rest], Code) :-
    (   Body == true
    ->  Code = "        // Fact - always succeeds
        return Optional.of(record);"
    ;   Code = "        // Rule - implement matching logic
        // TODO: Translate body to Java
        return Optional.of(record);"
    ).

%% ============================================
%% GRADLE BUILD GENERATION
%% ============================================

%% generate_gradle_build(+Options, -GradleCode)
%  Generate a Gradle build file for the Java project
generate_gradle_build(Options, GradleCode) :-
    option(project_name(ProjectName), Options, 'unifyweaver-pipeline'),
    option(main_class(MainClass), Options, 'generated.Pipeline'),
    option(java_version(JavaVersion), Options, '25'),
    
    format(string(GradleCode),
"plugins {
    id 'java'
    id 'application'
}

group = 'com.unifyweaver'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(~w)
    }
}

application {
    mainClass = '~w'
}

tasks.named('test') {
    useJUnitPlatform()
}

// Create fat JAR for standalone execution
tasks.register('fatJar', Jar) {
    archiveBaseName = '~w'
    archiveClassifier = 'all'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
        attributes 'Main-Class': '~w'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    with jar
}
", [JavaVersion, MainClass, ProjectName, MainClass]).

%% ============================================
%% PIPELINE COMPILATION
%% ============================================

%% compile_java_pipeline(+Steps, +Options, -JavaCode)
%  Compile multiple steps into a Java pipeline
compile_java_pipeline(Steps, Options, JavaCode) :-
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, 'Pipeline'),
    
    % Standard pipeline imports
    collect_java_import('java.io.*'),
    collect_java_import('java.util.*'),
    collect_java_import('java.util.stream.*'),
    collect_java_import('com.google.gson.*'),
    
    % Generate step methods
    generate_step_methods_java(Steps, 1, StepMethods),
    
    % Generate pipeline orchestration
    generate_pipeline_orchestration(Steps, OrchestrationCode),
    
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target - Multi-Step Pipeline
package ~w;

~w
/**
 * Multi-step data processing pipeline.
 */
public class ~w {

    private static final Gson gson = new Gson();

~w

    /**
     * Execute the full pipeline.
     */
    public static void main(String[] args) {
        try {
~w
        } catch (Exception e) {
            System.err.println(\"Pipeline error: \" + e.getMessage());
            System.exit(1);
        }
    }
}
", [Package, ImportsStr, ClassName, StepMethods, OrchestrationCode]).

%% generate_step_methods_java(+Steps, +N, -Code)
generate_step_methods_java([], _, "").
generate_step_methods_java([step(Name, Target, _Script, _Opts)|Rest], N, Code) :-
    format(string(StepCode),
"    /**
     * Step ~w: ~w (~w)
     */
    public static Optional<Map<String, Object>> step_~w(Map<String, Object> record) {
        // TODO: Implement ~w logic
        return Optional.of(record);
    }

", [N, Name, Target, Name, Target]),
    N1 is N + 1,
    generate_step_methods_java(Rest, N1, RestCode),
    atom_concat(StepCode, RestCode, Code).

%% generate_pipeline_orchestration(+Steps, -Code)
generate_pipeline_orchestration(Steps, Code) :-
    findall(CallCode,
        (   member(step(Name, _, _, _), Steps),
            format(string(CallCode), "            record = step_~w(record).orElse(null);
            if (record == null) continue;", [Name])
        ),
        Calls),
    atomic_list_concat(Calls, '\n', CallsStr),
    
    format(string(Code),
"            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            String line;
            while ((line = reader.readLine()) != null) {
                Map<String, Object> record = gson.fromJson(line, Map.class);
~w
                System.out.println(gson.toJson(record));
            }", [CallsStr]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

%% write_java_program(+JavaCode, +FilePath)
%  Write generated Java code to a file
write_java_program(JavaCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, JavaCode),
    close(Stream),
    format('Written Java program to: ~w~n', [FilePath]).

%% capitalize_atom(+Atom, -Capitalized)
%  Capitalize first letter of an atom
capitalize_atom(Atom, Capitalized) :-
    atom_codes(Atom, [H|T]),
    (   H >= 97, H =< 122
    ->  H1 is H - 32,
        atom_codes(Capitalized, [H1|T])
    ;   Capitalized = Atom
    ).

%% option(+Option, +Options, +Default)
%  Get option value with default
option(Option, Options, _Default) :-
    member(Option, Options),
    !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

%% ============================================
%% TESTS
%% ============================================

test_java_pipeline_mode :-
    format('~n=== Testing Java Pipeline Mode ===~n~n'),
    
    % Test 1: Basic pipeline generation
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_java(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'runPipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    % Test 2: Gradle build generation
    format('~nTest 2: Gradle build generation~n'),
    generate_gradle_build([java_version('21')], GradleCode),
    (   sub_atom(GradleCode, _, _, _, 'fatJar')
    ->  format('  [PASS] Generated Gradle build~n')
    ;   format('  [FAIL] Missing Gradle config~n')
    ),
    
    format('~n=== Java Pipeline Mode Tests Complete ===~n').
