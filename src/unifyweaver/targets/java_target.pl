:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% java_target.pl - Java Target for UnifyWeaver
% Generates standalone Java programs for record/field processing
% Supports streaming JSONL I/O and Gradle build integration

:- module(java_target, [
    compile_predicate_to_java/3,      % +Predicate, +Options, -JavaCode
    compile_java_pipeline/3,          % +Predicates, +Options, -JavaCode
    write_java_program/2,             % +JavaCode, +FilePath
    generate_gradle_build/2,          % +Options, -GradleCode
    init_java_target/0,               % Initialize Java target
    test_java_pipeline_mode/0         % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').
:- use_module('../bindings/java_bindings').

% Track required imports
:- dynamic required_java_import/1.

%% init_java_target
%  Initialize Java target with bindings
init_java_target :-
    retractall(required_java_import(_)),
    init_java_bindings.

%% clear_java_imports
%  Clear collected Java imports
clear_java_imports :-
    retractall(required_java_import(_)).

%% collect_java_import(+Import)
%  Record that an import is required
collect_java_import(Import) :-
    (   required_java_import(Import)
    ->  true
    ;   assertz(required_java_import(Import))
    ).

%% get_java_imports(-Imports)
%  Get all collected imports
get_java_imports(Imports) :-
    findall(I, required_java_import(I), Imports).

%% format_java_imports(+Imports, -FormattedStr)
%  Format a list of imports for Java
format_java_imports([], "").
format_java_imports(Imports, FormattedStr) :-
    Imports \= [],
    sort(Imports, UniqueImports),
    findall(Formatted,
        (   member(Import, UniqueImports),
            format(string(Formatted), "import ~w;~n", [Import])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_java(+Predicate, +Options, -JavaCode)
%  Compile a Prolog predicate to Java code
%
%  @arg Predicate Predicate indicator (Name/Arity)
%  @arg Options List of options
%  @arg JavaCode Generated Java code as atom
%
%  Options:
%  - package(Name) - Java package name (default: 'generated')
%  - class_name(Name) - Class name (default: predicate name capitalized)
%  - pipeline_input(true|false) - Enable streaming input
%  - json_input(true|false) - Use JSONL input format
%  - main_class(true|false) - Generate main method (default: true)
%
compile_predicate_to_java(PredIndicator, Options, JavaCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to Java ===~n', [Pred, Arity]),

    % Clear any previously collected imports
    clear_java_imports,

    % Check for pipeline mode
    (   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_java(Pred, Arity, Options, JavaCode)
    % Default: simple predicate
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_java(Pred, Arity, Options, JavaCode)
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_java(Pred, Arity, Options, JavaCode) :-
    % Get options
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, Pred),
    capitalize_atom(ClassName, CapClassName),
    option(main_class(MainClass), Options, true),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate method for each clause
    (   Clauses == []
    ->  MethodCode = "    // No clauses found"
    ;   findall(Code, (member((H, B), Clauses), clause_to_java(H, B, Code)), MethodCodes),
        atomic_list_concat(MethodCodes, '\n', MethodCode)
    ),
    
    % Generate main if requested
    (   MainClass == true
    ->  MainCode = "
    public static void main(String[] args) {
        // TODO: Add main logic
    }"
    ;   MainCode = ""
    ),
    
    % Standard imports for simple mode
    collect_java_import('java.util.*'),
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target
// Predicate: ~w/~w

package ~w;

~w
public class ~w {

~w
~w
}
", [Pred, Arity, Package, ImportsStr, CapClassName, MethodCode, MainCode]).

%% clause_to_java(+Head, +Body, -Code)
%  Convert a single clause to Java code (stub for now)
clause_to_java(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    length(Args, _Arity),
    (   Body == true
    ->  format(string(Code), "    // Fact: ~w", [Head])
    ;   format(string(Code), "    // Rule: ~w :- ~w", [Head, Body])
    ).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_java(Pred, Arity, Options, JavaCode) :-
    % Get options
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, Pred),
    capitalize_atom(ClassName, CapClassName),
    
    % Standard pipeline imports
    collect_java_import('java.io.*'),
    collect_java_import('java.util.*'),
    collect_java_import('java.util.stream.*'),
    collect_java_import('com.google.gson.*'),
    collect_java_import('com.google.gson.reflect.TypeToken'),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate process method
    (   Clauses == []
    ->  ProcessCode = "        // No clauses found - pass through
        return Optional.of(record);"
    ;   generate_pipeline_process(Clauses, ProcessCode)
    ),
    
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target - Pipeline Mode
// Predicate: ~w/~w

package ~w;

~w
/**
 * Pipeline processor for ~w predicate.
 * Reads JSONL from stdin, processes each record, writes JSONL to stdout.
 */
public class ~w {

    private static final Gson gson = new Gson();

    /**
     * Process a single input record.
     * @param record Input record as Map
     * @return Optional output record (empty to filter out)
     */
    public static Optional<Map<String, Object>> process(Map<String, Object> record) {
~w
    }

    /**
     * Run the pipeline: read from stdin, process, write to stdout.
     */
    public static void runPipeline() throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        
        String line;
        while ((line = reader.readLine()) != null) {
            if (line.trim().isEmpty()) continue;
            
            try {
                Map<String, Object> record = gson.fromJson(
                    line, 
                    new TypeToken<Map<String, Object>>(){}.getType()
                );
                
                Optional<Map<String, Object>> result = process(record);
                result.ifPresent(r -> writer.println(gson.toJson(r)));
                
            } catch (JsonSyntaxException e) {
                System.err.println(\"JSON parse error: \" + e.getMessage());
            }
        }
        
        writer.flush();
    }

    public static void main(String[] args) {
        try {
            runPipeline();
        } catch (IOException e) {
            System.err.println(\"I/O error: \" + e.getMessage());
            System.exit(1);
        }
    }
}
", [Pred, Arity, Package, ImportsStr, Pred, CapClassName, ProcessCode]).

%% generate_pipeline_process(+Clauses, -Code)
%  Generate process method body from clauses with body translation
generate_pipeline_process([], "        return Optional.of(record);").
generate_pipeline_process(Clauses, Code) :-
    Clauses \= [],
    % Check for recursion
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_java(Name, Clauses)
    ->  % Separate base and recursive clauses
        partition(is_recursive_clause_java(Name), Clauses, RecClauses, BaseClauses),
        % Check if tail recursive
        (   is_tail_recursive_java(Name, RecClauses)
        ->  compile_tail_recursive_java(Name, BaseClauses, RecClauses, Code)
        ;   compile_general_recursive_java(Name, BaseClauses, RecClauses, Code)
        )
    ;   % Generate clause-based processing
        findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_java(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', AllClausesCode),
        format(string(Code), "~w", [AllClausesCode])
    ).

%% ============================================
%% RECURSION DETECTION AND PATTERNS
%% ============================================

%% is_recursive_predicate_java(+Name, +Clauses)
%  Check if any clause body contains a recursive call
is_recursive_predicate_java(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_java(Body, Name).

%% is_recursive_clause_java(+Name, +Clause)
is_recursive_clause_java(Name, (_, Body)) :-
    contains_recursive_call_java(Body, Name).

%% is_tail_recursive_java(+Name, +RecClauses)
%  Check if recursive call is in tail position
is_tail_recursive_java(Name, RecClauses) :-
    member((_, Body), RecClauses),
    get_last_goal_java(Body, LastGoal),
    functor(LastGoal, Name, _).

%% get_last_goal_java(+Body, -LastGoal)
get_last_goal_java((_, B), LastGoal) :- !, get_last_goal_java(B, LastGoal).
get_last_goal_java(Goal, Goal).

%% contains_recursive_call_java(+Body, +Name)
contains_recursive_call_java(Body, Name) :-
    extract_goal_java(Body, Goal),
    functor(Goal, Name, _),
    !.

%% extract_goal_java(+Body, -Goal)
extract_goal_java(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_java((A, _), Goal) :- extract_goal_java(A, Goal).
extract_goal_java((_, B), Goal) :- extract_goal_java(B, Goal).

%% ============================================
%% TAIL RECURSION PATTERN (→ while loop)
%% ============================================

%% compile_tail_recursive_java(+Name, +BaseClauses, +RecClauses, -Code)
%  Compile tail recursive predicate to iterative while loop
compile_tail_recursive_java(Name, BaseClauses, RecClauses, Code) :-
    % Generate base case condition
    (   BaseClauses = [(BaseHead, BaseBody)|_]
    ->  generate_base_condition_java(BaseHead, BaseBody, BaseCondition, _BaseReturn)
    ;   BaseCondition = "false", _BaseReturn = "record"
    ),
    
    % Generate recursive transformation
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_recursive_transform_java(RecBody, Name, Transform)
    ;   Transform = "current"
    ),
    
    format(string(Code),
"        // Tail-recursive predicate: ~w - optimized to while loop
        Map<String, Object> current = new HashMap<>(record);
        int maxIterations = 10000;
        
        for (int i = 0; i < maxIterations; i++) {
            // Base case check
            if (~w) {
                return Optional.of(current);
            }
            
            // Recursive step (tail call transformed to loop)
            current = ~w;
        }
        
        // Exceeded max iterations
        System.err.println(\"Warning: Max iterations exceeded for ~w\");
        return Optional.of(current);", [Name, BaseCondition, Transform, Name]).

%% generate_base_condition_java(+Head, +Body, -Condition, -Return)
generate_base_condition_java(Head, Body, Condition, Return) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), "toDouble(current.get(\"arg0\")) == ~w", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition), "\"~w\".equals(current.get(\"arg0\"))", [Arg])
        ;   Condition = "false"
        )
    ;   Condition = "false"
    ),
    (   Body == true
    ->  Return = "current"
    ;   Return = "current"
    ).

%% generate_recursive_transform_java(+Body, +Name, -Transform)
generate_recursive_transform_java(Body, Name, Transform) :-
    % Find recursive call and extract argument transformation
    extract_goal_java(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_],
        expr_to_java(Expr, JavaExpr),
        format(string(Transform), 
            "new HashMap<String, Object>() {{ put(\"arg0\", ~w); }}", [JavaExpr])
    ;   Transform = "current"
    ).

%% ============================================
%% GENERAL RECURSION PATTERN (→ memoization)
%% ============================================

%% compile_general_recursive_java(+Name, +BaseClauses, +RecClauses, -Code)
%  Compile general recursive predicate with memoization
compile_general_recursive_java(Name, BaseClauses, RecClauses, Code) :-
    % Generate base case
    (   BaseClauses = [(BaseHead, BaseBody)|_]
    ->  generate_base_condition_java(BaseHead, BaseBody, BaseCondition, _)
    ;   BaseCondition = "false"
    ),
    
    % Generate recursive case
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_memoized_recursive_java(RecBody, Name, RecursiveComputation)
    ;   RecursiveComputation = "current"
    ),
    
    format(string(Code),
"        // General recursive predicate: ~w - with memoization
        // Cache to avoid recomputation
        @SuppressWarnings(\"unchecked\")
        Map<String, Object> memo = (Map<String, Object>) record.getOrDefault(\"__memo__\", new HashMap<>());
        
        String key = record.get(\"arg0\").toString();
        if (memo.containsKey(key)) {
            return Optional.of((Map<String, Object>) memo.get(key));
        }
        
        Map<String, Object> current = new HashMap<>(record);
        
        // Base case check
        if (~w) {
            memo.put(key, current);
            return Optional.of(current);
        }
        
        // Recursive computation with memoization
        Map<String, Object> result = ~w;
        memo.put(key, result);
        return Optional.of(result);", [Name, BaseCondition, RecursiveComputation]).

%% generate_memoized_recursive_java(+Body, +Name, -Code)
generate_memoized_recursive_java(Body, Name, Code) :-
    % Extract recursive call
    extract_goal_java(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_]
    ->  expr_to_java(Expr, JavaExpr),
        format(string(Code),
"processWithMemo(new HashMap<String, Object>() {{ put(\"arg0\", ~w); put(\"__memo__\", memo); }}).orElse(current)", [JavaExpr])
    ;   Code = "current"
    ).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

%% translate_clause_java(+Head, +Body, -Code)
%  Translate a single clause to Java code
translate_clause_java(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    % Generate input extraction
    generate_input_extraction_java(Args, InputCode),
    % Translate body
    (   Body == true
    ->  BodyCode = "        // Fact - no conditions"
    ;   translate_body_java(Body, BodyCode)
    ),
    % Generate output construction  
    generate_output_construction_java(Args, OutputCode),
    format(string(Code), "~w\n~w\n~w", [InputCode, BodyCode, OutputCode]).

%% generate_input_extraction_java(+Args, -Code)
generate_input_extraction_java(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "        Object arg~w = record.get(\"arg~w\");", [I, I])
        ;   format(string(Line), "        // arg~w = ~w (constant)", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% generate_output_construction_java(+Args, -Code)
generate_output_construction_java(_Args, Code) :-
    Code = "        return Optional.of(record);".

%% ============================================
%% BODY TRANSLATION
%% ============================================

%% translate_body_java(+Body, -Code)
%  Translate clause body to Java code
translate_body_java((Goal, Rest), Code) :-
    !,
    translate_goal_java(Goal, Code1),
    translate_body_java(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_java(Goal, Code) :-
    translate_goal_java(Goal, Code).

%% translate_goal_java(+Goal, -Code)
%  Translate individual goals to Java

% Assignment: X = Value
translate_goal_java(=(Var, Value), Code) :-
    var(Var), !,
    var_to_java(Var, JavaVar),
    value_to_java(Value, JavaValue),
    format(string(Code), "        ~w = ~w;", [JavaVar, JavaValue]).

% Comparison: X > Y, X < Y, etc.
translate_goal_java(>(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (!(toDouble(~w) > toDouble(~w))) return Optional.empty();", [JX, JY]).

translate_goal_java(<(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (!(toDouble(~w) < toDouble(~w))) return Optional.empty();", [JX, JY]).

translate_goal_java(>=(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (!(toDouble(~w) >= toDouble(~w))) return Optional.empty();", [JX, JY]).

translate_goal_java(=<(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (!(toDouble(~w) <= toDouble(~w))) return Optional.empty();", [JX, JY]).

translate_goal_java(=:=(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (toDouble(~w) != toDouble(~w)) return Optional.empty();", [JX, JY]).

translate_goal_java(=\\=(X, Y), Code) :-
    !,
    expr_to_java(X, JX),
    expr_to_java(Y, JY),
    format(string(Code), "        if (toDouble(~w) == toDouble(~w)) return Optional.empty();", [JX, JY]).

% Arithmetic: X is Expr
translate_goal_java(is(Var, Expr), Code) :-
    !,
    var_to_java(Var, JavaVar),
    expr_to_java(Expr, JavaExpr),
    format(string(Code), "        ~w = ~w;", [JavaVar, JavaExpr]).

% get_dict/3: get_dict(Key, Dict, Value)
translate_goal_java(get_dict(Key, Dict, Value), Code) :-
    !,
    var_to_java(Dict, JavaDict),
    var_to_java(Value, JavaValue),
    format(string(Code), "        ~w = ~w.get(\"~w\");", [JavaValue, JavaDict, Key]).

% put_dict/3: put_dict(Key, Dict, Value)
translate_goal_java(put_dict(Updates, Dict, NewDict), Code) :-
    !,
    var_to_java(Dict, JavaDict),
    var_to_java(NewDict, JavaNewDict),
    format(string(Code), "        ~w = new HashMap<>(~w);\n        ~w.putAll(~w);", 
           [JavaNewDict, JavaDict, JavaNewDict, Updates]).

% true - no-op
translate_goal_java(true, Code) :-
    !,
    Code = "        // true".

% Unknown goal - comment
translate_goal_java(Goal, Code) :-
    format(string(Code), "        // TODO: ~w", [Goal]).

%% ============================================
%% HELPER PREDICATES FOR TRANSLATION
%% ============================================

%% var_to_java(+Var, -JavaVar)
var_to_java(Var, JavaVar) :-
    (   var(Var)
    ->  term_to_atom(Var, VarAtom),
        format(atom(JavaVar), "var_~w", [VarAtom])
    ;   Var = '$VAR'(N)
    ->  format(atom(JavaVar), "v_~w", [N])
    ;   term_to_atom(Var, JavaVar)
    ).

%% value_to_java(+Value, -JavaValue)
value_to_java(Value, JavaValue) :-
    (   number(Value)
    ->  format(atom(JavaValue), "~w", [Value])
    ;   atom(Value)
    ->  format(atom(JavaValue), "\"~w\"", [Value])
    ;   var(Value)
    ->  var_to_java(Value, JavaValue)
    ;   format(atom(JavaValue), "~w", [Value])
    ).

%% expr_to_java(+Expr, -JavaExpr)
%  Translate Prolog arithmetic expr to Java
expr_to_java(Expr, JavaExpr) :-
    (   number(Expr)
    ->  format(atom(JavaExpr), "~w", [Expr])
    ;   var(Expr)
    ->  var_to_java(Expr, JavaExpr)
    ;   Expr = '$VAR'(N)
    ->  format(atom(JavaExpr), "v_~w", [N])
    ;   Expr = X + Y
    ->  expr_to_java(X, JX), expr_to_java(Y, JY),
        format(atom(JavaExpr), "(~w + ~w)", [JX, JY])
    ;   Expr = X - Y
    ->  expr_to_java(X, JX), expr_to_java(Y, JY),
        format(atom(JavaExpr), "(~w - ~w)", [JX, JY])
    ;   Expr = X * Y
    ->  expr_to_java(X, JX), expr_to_java(Y, JY),
        format(atom(JavaExpr), "(~w * ~w)", [JX, JY])
    ;   Expr = X / Y
    ->  expr_to_java(X, JX), expr_to_java(Y, JY),
        format(atom(JavaExpr), "(~w / ~w)", [JX, JY])
    ;   Expr = X mod Y
    ->  expr_to_java(X, JX), expr_to_java(Y, JY),
        format(atom(JavaExpr), "(~w % ~w)", [JX, JY])
    ;   format(atom(JavaExpr), "~w", [Expr])
    ).

%% ============================================
%% GRADLE BUILD GENERATION
%% ============================================

%% generate_gradle_build(+Options, -GradleCode)
%  Generate a Gradle build file for the Java project
generate_gradle_build(Options, GradleCode) :-
    option(project_name(ProjectName), Options, 'unifyweaver-pipeline'),
    option(main_class(MainClass), Options, 'generated.Pipeline'),
    option(java_version(JavaVersion), Options, '25'),
    
    format(string(GradleCode),
"plugins {
    id 'java'
    id 'application'
}

group = 'com.unifyweaver'
version = '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'com.google.code.gson:gson:2.10.1'
    
    testImplementation 'org.junit.jupiter:junit-jupiter:5.10.0'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(~w)
    }
}

application {
    mainClass = '~w'
}

tasks.named('test') {
    useJUnitPlatform()
}

// Create fat JAR for standalone execution
tasks.register('fatJar', Jar) {
    archiveBaseName = '~w'
    archiveClassifier = 'all'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    manifest {
        attributes 'Main-Class': '~w'
    }
    from {
        configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) }
    }
    with jar
}
", [JavaVersion, MainClass, ProjectName, MainClass]).

%% ============================================
%% PIPELINE COMPILATION
%% ============================================

%% compile_java_pipeline(+Steps, +Options, -JavaCode)
%  Compile multiple steps into a Java pipeline
compile_java_pipeline(Steps, Options, JavaCode) :-
    option(package(Package), Options, generated),
    option(class_name(ClassName), Options, 'Pipeline'),
    
    % Standard pipeline imports
    collect_java_import('java.io.*'),
    collect_java_import('java.util.*'),
    collect_java_import('java.util.stream.*'),
    collect_java_import('com.google.gson.*'),
    
    % Generate step methods
    generate_step_methods_java(Steps, 1, StepMethods),
    
    % Generate pipeline orchestration
    generate_pipeline_orchestration(Steps, OrchestrationCode),
    
    get_java_imports(ImportList),
    format_java_imports(ImportList, ImportsStr),
    
    format(string(JavaCode),
"// Generated by UnifyWeaver Java Target - Multi-Step Pipeline
package ~w;

~w
/**
 * Multi-step data processing pipeline.
 */
public class ~w {

    private static final Gson gson = new Gson();

~w

    /**
     * Execute the full pipeline.
     */
    public static void main(String[] args) {
        try {
~w
        } catch (Exception e) {
            System.err.println(\"Pipeline error: \" + e.getMessage());
            System.exit(1);
        }
    }
}
", [Package, ImportsStr, ClassName, StepMethods, OrchestrationCode]).

%% generate_step_methods_java(+Steps, +N, -Code)
generate_step_methods_java([], _, "").
generate_step_methods_java([step(Name, Target, _Script, _Opts)|Rest], N, Code) :-
    format(string(StepCode),
"    /**
     * Step ~w: ~w (~w)
     */
    public static Optional<Map<String, Object>> step_~w(Map<String, Object> record) {
        // TODO: Implement ~w logic
        return Optional.of(record);
    }

", [N, Name, Target, Name, Target]),
    N1 is N + 1,
    generate_step_methods_java(Rest, N1, RestCode),
    atom_concat(StepCode, RestCode, Code).

%% generate_pipeline_orchestration(+Steps, -Code)
generate_pipeline_orchestration(Steps, Code) :-
    findall(CallCode,
        (   member(step(Name, _, _, _), Steps),
            format(string(CallCode), "            record = step_~w(record).orElse(null);
            if (record == null) continue;", [Name])
        ),
        Calls),
    atomic_list_concat(Calls, '\n', CallsStr),
    
    format(string(Code),
"            BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
            String line;
            while ((line = reader.readLine()) != null) {
                Map<String, Object> record = gson.fromJson(line, Map.class);
~w
                System.out.println(gson.toJson(record));
            }", [CallsStr]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

%% write_java_program(+JavaCode, +FilePath)
%  Write generated Java code to a file
write_java_program(JavaCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, JavaCode),
    close(Stream),
    format('Written Java program to: ~w~n', [FilePath]).

%% capitalize_atom(+Atom, -Capitalized)
%  Capitalize first letter of an atom
capitalize_atom(Atom, Capitalized) :-
    atom_codes(Atom, [H|T]),
    (   H >= 97, H =< 122
    ->  H1 is H - 32,
        atom_codes(Capitalized, [H1|T])
    ;   Capitalized = Atom
    ).

%% option(+Option, +Options, +Default)
%  Get option value with default
option(Option, Options, _Default) :-
    member(Option, Options),
    !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

%% ============================================
%% TESTS
%% ============================================

test_java_pipeline_mode :-
    format('~n=== Testing Java Pipeline Mode ===~n~n'),
    
    % Test 1: Basic pipeline generation
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_java(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'runPipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    % Test 2: Gradle build generation
    format('~nTest 2: Gradle build generation~n'),
    generate_gradle_build([java_version('21')], GradleCode),
    (   sub_atom(GradleCode, _, _, _, 'fatJar')
    ->  format('  [PASS] Generated Gradle build~n')
    ;   format('  [FAIL] Missing Gradle config~n')
    ),
    
    format('~n=== Java Pipeline Mode Tests Complete ===~n').
