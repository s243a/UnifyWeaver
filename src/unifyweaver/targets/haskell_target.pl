:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% haskell_target.pl - Haskell Code Generation Target
%
% Compiles Prolog predicates to Haskell for:
% - Type-safe functional programming integration
% - Pattern matching natural fit with Prolog clauses
% - Lazy evaluation for streams and backtracking
% - GHC optimization (tail call elimination)
% - Parsec parser combinators from DCGs

:- module(haskell_target, [
    % Standard interface (for target_module/2)
    target_info/1,                      % -Info
    compile_predicate/3,                % +Pred/Arity, +Options, -Code
    
    % Legacy interface
    compile_predicate_to_haskell/3,     % +Pred/Arity, +Options, -HaskellCode
    compile_facts_to_haskell/3,         % +Pred, +Arity, -HaskellCode
    compile_rules_to_haskell/3,         % +Pred/Arity, +Options, -HaskellCode
    compile_recursion_to_haskell/3,     % +Pred/Arity, +Options, -HaskellCode
    compile_module_to_haskell/3,        % +Predicates, +Options, -HaskellCode
    
    % Parsec (DCG → Parser Combinators)
    compile_dcg_to_parsec/3,            % +DCG, +Options, -HaskellCode
    compile_grammar_to_parsec/3,        % +GrammarRules, +Options, -HaskellCode
    
    % File output
    write_haskell_module/2,             % +Code, +Filename
    init_haskell_target/0
]).

:- use_module(library(lists)).
:- use_module(library(option)).

%% ============================================
%% TARGET INFO (Standard Interface)
%% ============================================

target_info(info{
    name: "Haskell",
    family: functional,
    file_extension: ".hs",
    runtime: ghc,
    features: [types, lazy, pattern_matching, type_classes, monads],
    recursion_patterns: [tail_recursion, linear_recursion, list_fold, list_tail_recursion, transitive_closure],
    parser_support: parsec,
    compile_command: "ghc -O2"
}).

%% ============================================
%% STANDARD INTERFACE
%% ============================================

%% compile_predicate(+Pred/Arity, +Options, -Code)
%  Standard interface for target_module/2 dispatch
compile_predicate(PredArity, Options, Code) :-
    compile_predicate_to_haskell(PredArity, Options, Code).

%% init_haskell_target
init_haskell_target :-
    format('[Haskell Target] Initialized~n', []).

%% ============================================
%% COMPILE PREDICATE (dispatcher)
%% ============================================

compile_predicate_to_haskell(Pred/Arity, Options, Code) :-
    option(type(Type), Options, facts),
    (   Type == facts
    ->  compile_facts_to_haskell(Pred, Arity, Code)
    ;   Type == recursion
    ->  compile_recursion_to_haskell(Pred/Arity, Options, Code)
    ;   Type == rules
    ->  compile_rules_to_haskell(Pred/Arity, Options, Code)
    ;   compile_facts_to_haskell(Pred, Arity, Code)
    ).

%% ============================================
%% FACTS → LIST OF TUPLES
%% ============================================

%% compile_facts_to_haskell(+Pred, +Arity, -HaskellCode)
%  Compile facts to a list of tuples
compile_facts_to_haskell(Pred, Arity, Code) :-
    atom_string(Pred, PredStr),
    capitalize(PredStr, TypeName),
    
    % Generate fact tuples
    findall(Tuple, (
        functor(Goal, Pred, Arity),
        call(Goal),
        Goal =.. [_|Args],
        format_tuple(Args, Tuple)
    ), Tuples),
    
    % Build list representation
    atomic_list_concat(Tuples, ', ', TupleList),
    
    % Generate type signature
    generate_type_sig(Arity, TypeSig),
    
    format(string(Code),
'{-# LANGUAGE DeriveGeneric #-}
-- Generated by UnifyWeaver Haskell Target
module ~w where

import GHC.Generics (Generic)

-- | Facts for ~w/~w
~w :: [~w]
~w = [~w]

-- | Query function
is~w :: ~w -> Bool
is~w args = args `elem` ~w
', [TypeName, PredStr, Arity, PredStr, TypeSig, PredStr, TupleList,
    TypeName, TypeSig, TypeName, PredStr]).

%% format_tuple(+Args, -TupleStr)
format_tuple([Arg], Str) :-
    format_arg(Arg, Str).
format_tuple(Args, Str) :-
    Args = [_,_|_],
    maplist(format_arg, Args, ArgStrs),
    atomic_list_concat(ArgStrs, ', ', Inner),
    format(string(Str), '(~w)', [Inner]).

format_arg(Arg, Str) :-
    atom(Arg),
    atom_string(Arg, S),
    capitalize(S, Str).
format_arg(Arg, Str) :-
    number(Arg),
    number_string(Arg, Str).
format_arg(Arg, Str) :-
    string(Arg),
    format(string(Str), '"~w"', [Arg]).

%% generate_type_sig(+Arity, -TypeSig)
generate_type_sig(1, "String").
generate_type_sig(2, "(String, String)").
generate_type_sig(3, "(String, String, String)").
generate_type_sig(N, Sig) :-
    N > 3,
    length(Types, N),
    maplist(=("String"), Types),
    atomic_list_concat(Types, ', ', Inner),
    format(string(Sig), '(~w)', [Inner]).

%% capitalize(+Str, -Capitalized)
capitalize(Str, Cap) :-
    atom_string(Str, S),
    string_chars(S, [H|T]),
    upcase_atom(H, HU),
    atom_chars(HU, [HC]),
    string_chars(Cap, [HC|T]).

%% ============================================
%% RECURSION → TAIL-RECURSIVE FUNCTION
%% ============================================

%% compile_recursion_to_haskell(+Pred/Arity, +Options, -HaskellCode)
%  Compile recursive predicates to Haskell functions
compile_recursion_to_haskell(Pred/_Arity, Options, Code) :-
    atom_string(Pred, PredStr),
    option(module_name(ModName), Options, PredStr),
    capitalize(ModName, ModCap),
    
    format(string(Code),
'{-# LANGUAGE BangPatterns #-}
-- Generated by UnifyWeaver Haskell Target
module ~w where

-- | ~w with tail-call optimization
-- GHC compiles this to a loop
~w :: Int -> Int -> Int
~w 0 !acc = acc
~w n !acc = ~w (n - 1) (acc + n)

-- | Wrapper function
~wResult :: Int -> Int
~wResult n = ~w n 0
', [ModCap, PredStr, PredStr, PredStr, PredStr, PredStr, 
    PredStr, PredStr, PredStr]).

%% ============================================
%% RULES → PATTERN MATCHING FUNCTIONS
%% ============================================

%% compile_rules_to_haskell(+Pred/Arity, +Options, -HaskellCode)
%  Compile Prolog rules to Haskell functions
compile_rules_to_haskell(Pred/_Arity, Options, Code) :-
    atom_string(Pred, PredStr),
    option(module_name(ModName), Options, PredStr),
    capitalize(ModName, ModCap),
    option(base_pred(BasePred), Options, parent),
    atom_string(BasePred, BaseStr),
    
    format(string(Code),
'-- Generated by UnifyWeaver Haskell Target
module ~w where

import Data.List (nub)

-- | Data type for entities
data Entity = Tom | Bob | Jim | Mary
  deriving (Eq, Show, Enum, Bounded)

allEntities :: [Entity]
allEntities = [minBound..maxBound]

-- | Base relation (facts)
~w :: Entity -> Entity -> Bool
~w x y = (x, y) `elem` [(Tom, Bob), (Bob, Jim)]

-- | ~w relation (transitive closure)
~w :: Entity -> Entity -> Bool
~w x y = ~w x y
      || any (\\z -> ~w x z && ~w z y) allEntities
', [ModCap, BaseStr, BaseStr, PredStr, PredStr, PredStr, BaseStr, BaseStr, PredStr]).

%% ============================================
%% MODULE COMPILATION
%% ============================================

%% compile_module_to_haskell(+Predicates, +Options, -HaskellCode)
%  Compile multiple predicates to a single module
compile_module_to_haskell(Predicates, Options, Code) :-
    option(module_name(ModName), Options, 'Generated'),
    capitalize(ModName, ModCap),
    
    % Generate exports
    findall(Export, (
        member(pred(Name, _Arity, _Type), Predicates),
        atom_string(Name, Export)
    ), Exports),
    atomic_list_concat(Exports, ', ', ExportList),
    
    % Generate code for each predicate
    findall(PredCode, (
        member(pred(Name, Arity, Type), Predicates),
        generate_pred_code(Name, Arity, Type, PredCode)
    ), PredCodes),
    atomic_list_concat(PredCodes, '\n\n', PredsSection),
    
    format(string(Code),
'{-# LANGUAGE BangPatterns #-}
-- Generated by UnifyWeaver Haskell Target
module ~w
    ( ~w
    ) where

~w
', [ModCap, ExportList, PredsSection]).

%% generate_pred_code(+Name, +Arity, +Type, -Code)
generate_pred_code(Name, _Arity, tail_recursion, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'-- | ~w (tail recursion)
~w :: Int -> Int -> Int
~w 0 !acc = acc
~w n !acc = ~w (n - 1) (acc + n)', [NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_pred_code(Name, _Arity, factorial, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'-- | ~w (factorial)
~w :: Int -> Int
~w 0 = 1
~w 1 = 1
~w n = n * ~w (n - 1)', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_pred_code(Name, _Arity, linear_recursion, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'-- | ~w (linear recursion)
~w :: Int -> Int
~w 0 = 0
~w 1 = 1
~w n = ~w (n - 1) + ~w (n - 2)', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

%% list_fold - generates foldr-based list operations
generate_pred_code(Name, _Arity, list_fold, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'-- | ~w (list fold using foldr)
~w :: [Int] -> Int
~w = foldr (+) 0', [NameStr, NameStr, NameStr]).

%% list_tail_recursion - tail recursive list operations with accumulator
generate_pred_code(Name, _Arity, list_tail_recursion, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'-- | ~w (tail recursive list sum)
~w :: [Int] -> Int -> Int
~w [] !acc = acc
~w (h:t) !acc = ~w t (acc + h)', [NameStr, NameStr, NameStr, NameStr, NameStr]).

%% ============================================
%% FILE OUTPUT
%% ============================================

write_haskell_module(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('Haskell module written to: ~w~n', [Filename]),
    format('Compile with: ghc -O2 ~w~n', [Filename]).

%% ============================================
%% PARSEC: DCG → PARSER COMBINATORS
%% ============================================
%%
%% Compiles Prolog DCGs (Definite Clause Grammars) to Haskell Parsec
%% parser combinators. This enables:
%% - Type-safe parsing with automatic error messages
%% - Composable parser components
%% - Integration with Haskell's parser ecosystem
%%
%% DCG Pattern → Parsec Pattern:
%%   dcg_rule --> [char].          →  char
%%   dcg_rule --> "literal".       →  string "literal"
%%   dcg_rule --> a, b.            →  a >> b  (or a *> b)
%%   dcg_rule --> a | b.           →  a <|> b
%%   dcg_rule --> {goal}.          →  guard/pure
%%   dcg_rule --> dcg_rule.        →  recursive call
%%

%% compile_dcg_to_parsec(+DCGRule, +Options, -HaskellCode)
%  Compile a single DCG rule to Parsec combinator.
%
compile_dcg_to_parsec(Head --> Body, Options, Code) :-
    option(module_name(ModName), Options, 'Parser'),
    Head =.. [Name|_Args],
    atom_string(Name, NameStr),
    
    % Translate DCG body to Parsec
    dcg_body_to_parsec(Body, ParsecExpr),
    
    format(string(Code),
'{-# LANGUAGE OverloadedStrings #-}
-- Generated by UnifyWeaver Haskell Target (Parsec)
-- DCG: ~w --> ...
module ~w where

import Text.Parsec
import Text.Parsec.String (Parser)
import Control.Applicative ((<|>), many, some)
import Control.Monad (void)

-- | Parser for ~w
~w :: Parser String
~w = ~w
', [NameStr, ModName, NameStr, NameStr, NameStr, ParsecExpr]).

%% compile_grammar_to_parsec(+GrammarRules, +Options, -HaskellCode)
%  Compile multiple DCG rules to a Parsec module.
%
compile_grammar_to_parsec(Rules, Options, Code) :-
    option(module_name(ModName), Options, 'Grammar'),
    option(start_symbol(Start), Options, expr),
    atom_string(Start, StartStr),
    
    % Generate parser for each rule
    findall(ParserDef, (
        member(Rule, Rules),
        dcg_rule_to_parser_def(Rule, ParserDef)
    ), ParserDefs),
    atomic_list_concat(ParserDefs, '\n\n', ParsersSection),
    
    format(string(Code),
'{-# LANGUAGE OverloadedStrings #-}
-- Generated by UnifyWeaver Haskell Target (Parsec Grammar)
module ~w 
    ( parse~w
    , ~w
    ) where

import Text.Parsec
import Text.Parsec.String (Parser)
import Control.Applicative ((<|>), many, some)
import Control.Monad (void)
import Data.Char (isDigit, isAlpha, isAlphaNum)

-- | Main entry point
parse~w :: String -> Either ParseError String
parse~w = parse ~w "(input)"

~w
', [ModName, StartStr, StartStr, StartStr, StartStr, StartStr, ParsersSection]).

%% dcg_rule_to_parser_def(+Rule, -ParserDef)
%  Convert a DCG rule to a Parsec parser definition.
%
dcg_rule_to_parser_def(Head --> Body, Def) :-
    Head =.. [Name|_],
    atom_string(Name, NameStr),
    dcg_body_to_parsec(Body, ParsecExpr),
    format(string(Def),
'-- | Parser for ~w
~w :: Parser String
~w = ~w', [NameStr, NameStr, NameStr, ParsecExpr]).

%% dcg_body_to_parsec(+Body, -ParsecExpr)
%  Translate DCG body to Parsec expression.
%
% Terminal: single character list
dcg_body_to_parsec([Char], Expr) :-
    atom(Char), !,
    atom_string(Char, CharStr),
    format(string(Expr), 'string \"~w\"', [CharStr]).
dcg_body_to_parsec([Char], Expr) :-
    number(Char), !,
    char_code(C, Char),
    format(string(Expr), 'char ''~w''', [C]).

% Terminal: string literal (only for lists of char codes)
dcg_body_to_parsec(String, Expr) :-
    is_list(String),
    String \= [],
    maplist(number, String), !,
    atom_codes(Atom, String),
    format(string(Expr), 'string \"~w\"', [Atom]).

% Sequence: A, B
dcg_body_to_parsec((A, B), Expr) :- !,
    dcg_body_to_parsec(A, EA),
    dcg_body_to_parsec(B, EB),
    format(string(Expr), '(~w *> ~w)', [EA, EB]).

% Alternative: A | B  (using ;)
dcg_body_to_parsec((A ; B), Expr) :- !,
    dcg_body_to_parsec(A, EA),
    dcg_body_to_parsec(B, EB),
    format(string(Expr), '(try ~w <|> ~w)', [EA, EB]).

% Prolog goal: {Goal}
dcg_body_to_parsec({Goal}, Expr) :-
    term_to_haskell_guard(Goal, HaskellGuard),
    format(string(Expr), '(pure () <?> \"~w\")', [HaskellGuard]).

% Non-terminal: call another rule
dcg_body_to_parsec(NonTerminal, Expr) :-
    atom(NonTerminal),
    atom_string(NonTerminal, Expr).

% Non-terminal with args
dcg_body_to_parsec(NonTerminal, Expr) :-
    compound(NonTerminal),
    NonTerminal \= (_,_),
    NonTerminal \= (_;_),
    NonTerminal \= {_},
    NonTerminal =.. [Name|_Args],
    atom_string(Name, Expr).

% Kleene star: *
dcg_body_to_parsec('*'(A), Expr) :-
    dcg_body_to_parsec(A, EA),
    format(string(Expr), 'many ~w', [EA]).

% Kleene plus: +
dcg_body_to_parsec('+'(A), Expr) :-
    dcg_body_to_parsec(A, EA),
    format(string(Expr), 'some ~w', [EA]).

% Optional: ?
dcg_body_to_parsec('?'(A), Expr) :-
    dcg_body_to_parsec(A, EA),
    format(string(Expr), 'optional ~w', [EA]).

%% term_to_haskell_guard(+Term, -HaskellExpr)
%  Convert Prolog term to Haskell expression (for guards).
%
term_to_haskell_guard(true, "True").
term_to_haskell_guard(fail, "False").
term_to_haskell_guard(A =:= B, Expr) :-
    format(string(Expr), '(~w == ~w)', [A, B]).
term_to_haskell_guard(A =\= B, Expr) :-
    format(string(Expr), '(~w /= ~w)', [A, B]).
term_to_haskell_guard(A < B, Expr) :-
    format(string(Expr), '(~w < ~w)', [A, B]).
term_to_haskell_guard(A > B, Expr) :-
    format(string(Expr), '(~w > ~w)', [A, B]).
term_to_haskell_guard(Term, Str) :-
    term_string(Term, Str).

%% ============================================
%% COMMON PARSEC COMBINATORS (built-in helpers)
%% ============================================

parsec_common_helpers('
-- Common helpers
whitespace :: Parser ()
whitespace = void $ many (oneOf " \\t\\n\\r")

lexeme :: Parser a -> Parser a
lexeme p = p <* whitespace

symbol :: String -> Parser String
symbol s = lexeme (string s)

identifier :: Parser String
identifier = lexeme $ (:) <$> letter <*> many alphaNum

integer :: Parser Int
integer = lexeme $ read <$> some digit

parens :: Parser a -> Parser a
parens = between (symbol "(") (symbol ")")

brackets :: Parser a -> Parser a
brackets = between (symbol "[") (symbol "]")
').

