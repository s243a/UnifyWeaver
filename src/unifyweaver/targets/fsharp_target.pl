:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% fsharp_target.pl - F# Code Generation Target
% Compiles Prolog predicates to F# programs using functional idioms.

:- module(fsharp_target, [
    compile_predicate_to_fsharp/3,         % +PredIndicator, +Options, -FSharpCode
    compile_facts_to_fsharp/3,             % +Pred, +Arity, -FSharpCode  
    compile_tail_recursion_fsharp/3,       % +Pred/Arity, +Options, -FSharpCode
    compile_linear_recursion_fsharp/3,     % +Pred/Arity, +Options, -FSharpCode
    compile_mutual_recursion_fsharp/3,     % +Predicates, +Options, -FSharpCode
    write_fsharp_program/2,                % +Code, +Filename
    init_fsharp_target/0                   % Initialize target
]).

:- use_module(library(lists)).
:- use_module('../bindings/fsharp_bindings', [init_fsharp_bindings/0]).

%% init_fsharp_target
init_fsharp_target :-
    init_fsharp_bindings.

%% compile_predicate_to_fsharp(+PredIndicator, +Options, -Code)
compile_predicate_to_fsharp(Pred/Arity, Options, Code) :-
    functor(Head, Pred, Arity),
    findall(Head-Body, user:clause(Head, Body), Clauses),
    (   Clauses = []
    ->  format(user_error, 'F# target: no clauses for ~w/~w~n', [Pred, Arity]),
        fail
    ;   compile_clauses_to_fsharp(Pred, Arity, Clauses, Options, Code)
    ).

%% compile_clauses_to_fsharp(+Pred, +Arity, +Clauses, +Options, -Code)
compile_clauses_to_fsharp(Pred, Arity, Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    (   forall(member(_-Body, Clauses), Body == true)
    ->  compile_facts_fsharp(PredStr, PredUpStr, Arity, Clauses, Code)
    ;   compile_rule_fsharp(PredStr, PredUpStr, Arity, Clauses, Code)
    ).

%% compile_facts_fsharp(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_facts_fsharp(PredStr, PredUpStr, Arity, Clauses, Code) :-
    generate_fsharp_fields(Arity, FieldDefs),
    findall(Entry, (
        member(Head-true, Clauses),
        Head =.. [_|Args],
        generate_fsharp_fact_entry(Args, Entry)
    ), Entries),
    atomic_list_concat(Entries, '\n        ', EntriesCode),
    generate_fsharp_print_pattern(Arity, PrintPattern),
    generate_fsharp_print_args(Arity, PrintArgs),
    
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Fact Export
// Predicate: ~w/~w

open System

type ~w = {
    ~w
}

let getAll~w () =
    [
        ~w
    ]

let stream~w () =
    getAll~w () |> Seq.ofList

let contains~w target =
    getAll~w () |> List.exists ((=) target)

[<EntryPoint>]
let main argv =
    getAll~w ()
    |> List.iter (fun fact -> printfn "~w" ~w)
    0
', [PredStr, Arity, PredUpStr, FieldDefs, 
    PredUpStr, EntriesCode,
    PredUpStr, PredUpStr,
    PredUpStr, PredUpStr,
    PredUpStr, PrintPattern, PrintArgs]).

%% compile_rule_fsharp(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_rule_fsharp(PredStr, _PredUpStr, Arity, _Clauses, Code) :-
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Rule Compilation
// Predicate: ~w/~w

open System
open System.IO

let processLine (line: string) =
    let parts = line.Split('':'')
    if parts.Length >= ~w then Some line
    else None

[<EntryPoint>]
let main argv =
    use reader = new StreamReader(Console.OpenStandardInput())
    
    let rec readLines () = seq {
        let line = reader.ReadLine()
        if line <> null then
            yield line
            yield! readLines ()
    }
    
    readLines ()
    |> Seq.choose processLine
    |> Seq.iter (printfn "%s")
    
    0
', [PredStr, Arity, Arity]).

%% ============================================
%% TAIL RECURSION (let rec with accumulator)
%% ============================================

compile_tail_recursion_fsharp(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Tail Recursion
// Predicate: ~w/~w
// Optimized to O(1) stack space using tail-recursive let rec

open System

// Tail-recursive function with accumulator
let ~w n =
    let rec loop current acc =
        if current <= 0 then acc
        else loop (current - 1) (acc + current)
    loop n 0

[<EntryPoint>]
let main argv =
    if argv.Length >= 1 then
        let n = int argv.[0]
        printfn "%d" (~w n)
    0
', [PredStr, Arity, PredStr, PredStr]).

%% ============================================
%% LINEAR RECURSION (Map-based memoization)
%% ============================================

compile_linear_recursion_fsharp(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Linear Recursion
// Predicate: ~w/~w
// Uses mutable Dictionary for O(n) memoization

open System
open System.Collections.Generic

let private memo = Dictionary<int, int>()

let rec ~w n =
    match memo.TryGetValue(n) with
    | true, v -> v
    | false, _ ->
        let result =
            match n with
            | n when n <= 0 -> 0
            | 1 -> 1
            | n -> (~w (n - 1)) + n
        memo.[n] <- result
        result

let clearMemo () = memo.Clear()

[<EntryPoint>]
let main argv =
    if argv.Length >= 1 then
        let n = int argv.[0]
        printfn "%d" (~w n)
    0
', [PredStr, Arity, PredStr, PredStr, PredStr]).

%% ============================================
%% MUTUAL RECURSION (and keyword)
%% ============================================

compile_mutual_recursion_fsharp(Predicates, _Options, Code) :-
    findall(PredStr, (
        member(Pred/_Arity, Predicates),
        atom_string(Pred, PredStr)
    ), PredStrs),
    atomic_list_concat(PredStrs, '_', GroupName),
    
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Mutual Recursion
// Group: ~w
// Uses F# mutual recursion with "and" keyword

open System
open System.Collections.Generic

let private memo = Dictionary<string, bool>()

// Mutually recursive functions using "and"
let rec is_even n =
    let key = sprintf "is_even:%d" n
    match memo.TryGetValue(key) with
    | true, v -> v
    | false, _ ->
        let result =
            match n with
            | 0 -> true
            | n when n > 0 -> is_odd (n - 1)
            | _ -> false
        memo.[key] <- result
        result

and is_odd n =
    let key = sprintf "is_odd:%d" n
    match memo.TryGetValue(key) with
    | true, v -> v
    | false, _ ->
        let result =
            match n with
            | 0 -> false
            | n when n > 0 -> is_even (n - 1)
            | _ -> false
        memo.[key] <- result
        result

let clearMemo () = memo.Clear()

[<EntryPoint>]
let main argv =
    if argv.Length >= 2 then
        let func = argv.[0]
        let n = int argv.[1]
        match func with
        | "is_even" -> printfn "%b" (is_even n)
        | "is_odd" -> printfn "%b" (is_odd n)
        | _ -> printfn "Unknown function"
    0
', [GroupName]).

%% compile_facts_to_fsharp(+Pred, +Arity, -Code)
compile_facts_to_fsharp(Pred, Arity, Code) :-
    compile_predicate_to_fsharp(Pred/Arity, [], Code).

%% write_fsharp_program(+Code, +Filename)
write_fsharp_program(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('F# program written to: ~w~n', [Filename]).

%% Helper predicates
generate_fsharp_fields(Arity, Fields) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), 'Arg~w: string', [N])
    ), FieldList),
    atomic_list_concat(FieldList, '\n    ', Fields).

generate_fsharp_fact_entry(Args, Entry) :-
    length(Args, Arity),
    findall(FieldVal, (
        nth1(N, Args, Arg),
        format(string(FieldVal), 'Arg~w = "~w"', [N, Arg])
    ), FieldVals),
    atomic_list_concat(FieldVals, '; ', FieldsStr),
    format(string(Entry), '{ ~w }', [FieldsStr]).

generate_fsharp_print_pattern(Arity, Pattern) :-
    findall('%s', between(1, Arity, _), Placeholders),
    atomic_list_concat(Placeholders, ':', Pattern).

generate_fsharp_print_args(Arity, Result) :-
    findall(Arg, (
        between(1, Arity, N),
        format(string(Arg), 'fact.Arg~w', [N])
    ), Args),
    atomic_list_concat(Args, ' ', Result).
