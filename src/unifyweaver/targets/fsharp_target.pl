:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% fsharp_target.pl - F# Code Generation Target
% Compiles Prolog predicates to F# programs using functional idioms.

:- module(fsharp_target, [
    compile_predicate_to_fsharp/3,     % +PredIndicator, +Options, -FSharpCode
    compile_facts_to_fsharp/3,         % +Pred, +Arity, -FSharpCode  
    write_fsharp_program/2             % +Code, +Filename
]).

:- use_module(library(lists)).

%% compile_predicate_to_fsharp(+PredIndicator, +Options, -Code)
%  Compile a Prolog predicate to F#.
compile_predicate_to_fsharp(Pred/Arity, Options, Code) :-
    functor(Head, Pred, Arity),
    findall(Head-Body, user:clause(Head, Body), Clauses),
    (   Clauses = []
    ->  format(user_error, 'F# target: no clauses for ~w/~w~n', [Pred, Arity]),
        fail
    ;   compile_clauses_to_fsharp(Pred, Arity, Clauses, Options, Code)
    ).

%% compile_clauses_to_fsharp(+Pred, +Arity, +Clauses, +Options, -Code)
compile_clauses_to_fsharp(Pred, Arity, Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    % Check if all clauses are facts
    (   forall(member(_-Body, Clauses), Body == true)
    ->  compile_facts_fsharp(PredStr, PredUpStr, Arity, Clauses, Code)
    ;   compile_rule_fsharp(PredStr, PredUpStr, Arity, Clauses, Code)
    ).

%% compile_facts_fsharp(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_facts_fsharp(PredStr, PredUpStr, Arity, Clauses, Code) :-
    % Generate record fields
    generate_fsharp_fields(Arity, FieldDefs),
    
    % Generate fact entries
    findall(Entry, (
        member(Head-true, Clauses),
        Head =.. [_|Args],
        generate_fsharp_fact_entry(Args, Entry)
    ), Entries),
    atomic_list_concat(Entries, '\n        ', EntriesCode),
    
    % Generate print pattern
    generate_fsharp_print_pattern(Arity, PrintPattern),
    
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Fact Export
// Predicate: ~w/~w

open System

// Fact record type
type ~w = {
    ~w
}

// All facts
let getAll~w () =
    [
        ~w
    ]

// Stream facts
let stream~w () =
    getAll~w () |> Seq.ofList

// Check if fact exists
let contains~w target =
    getAll~w () |> List.exists ((=) target)

// Main entry point
[<EntryPoint>]
let main argv =
    getAll~w ()
    |> List.iter (fun fact -> printfn "~w" ~w)
    0
', [PredStr, Arity, PredUpStr, FieldDefs, 
    PredUpStr, EntriesCode,
    PredUpStr, PredUpStr,
    PredUpStr, PredUpStr,
    PredUpStr, PrintPattern, generate_fsharp_print_args(Arity)]).

%% compile_rule_fsharp(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_rule_fsharp(PredStr, _PredUpStr, Arity, _Clauses, Code) :-
    format(string(Code),
'// Generated by UnifyWeaver F# Target - Rule Compilation
// Predicate: ~w/~w

open System
open System.IO

// Stream processing function
let processLine (line: string) =
    let parts = line.Split('':'')
    if parts.Length >= ~w then
        // Process: ~w
        Some line
    else
        None

[<EntryPoint>]
let main argv =
    use reader = new StreamReader(Console.OpenStandardInput())
    
    let rec readLines () = seq {
        let line = reader.ReadLine()
        if line <> null then
            yield line
            yield! readLines ()
    }
    
    readLines ()
    |> Seq.choose processLine
    |> Seq.iter (printfn "%s")
    
    0
', [PredStr, Arity, Arity, PredStr]).

%% compile_facts_to_fsharp(+Pred, +Arity, -Code)
compile_facts_to_fsharp(Pred, Arity, Code) :-
    compile_predicate_to_fsharp(Pred/Arity, [], Code).

%% write_fsharp_program(+Code, +Filename)
write_fsharp_program(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('F# program written to: ~w~n', [Filename]).

%% Helper predicates
generate_fsharp_fields(Arity, Fields) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), 'Arg~w: string', [N])
    ), FieldList),
    atomic_list_concat(FieldList, '\n    ', Fields).

generate_fsharp_fact_entry(Args, Entry) :-
    length(Args, Arity),
    findall(FieldVal, (
        nth1(N, Args, Arg),
        format(string(FieldVal), 'Arg~w = "~w"', [N, Arg])
    ), FieldVals),
    atomic_list_concat(FieldVals, '; ', FieldsStr),
    format(string(Entry), '{ ~w }', [FieldsStr]).

generate_fsharp_print_pattern(Arity, Pattern) :-
    findall('%s', between(1, Arity, _), Placeholders),
    atomic_list_concat(Placeholders, ':', Pattern).

generate_fsharp_print_args(Arity) :-
    findall(Arg, (
        between(1, Arity, N),
        format(string(Arg), 'fact.Arg~w', [N])
    ), Args),
    atomic_list_concat(Args, ' ', _Result).

generate_fsharp_print_args(Arity, Result) :-
    findall(Arg, (
        between(1, Arity, N),
        format(string(Arg), 'fact.Arg~w', [N])
    ), Args),
    atomic_list_concat(Args, ' ', Result).
