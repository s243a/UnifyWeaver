% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% cpp_target.pl - C++ Target for UnifyWeaver
% Generates modern C++ programs using nlohmann/json
% Supports streams, lambdas, and iterator patterns

:- encoding(utf8).

:- module(cpp_target, [
    compile_predicate_to_cpp/3,   % +Predicate, +Options, -CppCode
    compile_cpp_pipeline/3,       % +Predicates, +Options, -CppCode
    compile_facts_to_cpp/3,       % +Pred, +Arity, -CppCode  -- NEW
    generate_cmake_cpp/2,         % +Options, -CMakeContent
    write_cpp_program/2,          % +CppCode, +FilePath
    init_cpp_target/0,            % Initialize C++ target
    test_cpp_pipeline_mode/0      % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').

% Track required includes
:- dynamic required_cpp_include/1.

%% init_cpp_target
init_cpp_target :-
    retractall(required_cpp_include(_)).

%% clear_cpp_includes
clear_cpp_includes :-
    retractall(required_cpp_include(_)).

%% collect_cpp_include(+Include)
collect_cpp_include(Include) :-
    (   required_cpp_include(Include)
    ->  true
    ;   assertz(required_cpp_include(Include))
    ).

%% get_cpp_includes(-Includes)
get_cpp_includes(Includes) :-
    findall(I, required_cpp_include(I), Includes).

%% format_cpp_includes(+Includes, -FormattedStr)
format_cpp_includes([], "").
format_cpp_includes(Includes, FormattedStr) :-
    Includes \= [],
    sort(Includes, UniqueIncludes),
    findall(Formatted,
        (   member(Include, UniqueIncludes),
            format(string(Formatted), "#include ~w~n", [Include])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

compile_predicate_to_cpp(PredIndicator, Options, CppCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to C++ ===~n', [Pred, Arity]),

    clear_cpp_includes,

    % Check mode
    (   option(generator_mode(true), Options)
    ->  format('  Mode: Generator (iterator class)~n'),
        compile_generator_mode_cpp(Pred, Arity, Options, CppCode)
    ;   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_cpp(Pred, Arity, Options, CppCode)
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_cpp(Pred, Arity, Options, CppCode)
    ).

%% ============================================
%% GENERATOR MODE (Iterator class)
%% ============================================

compile_generator_mode_cpp(Pred, Arity, _Options, CppCode) :-
    collect_cpp_include('<iostream>'),
    collect_cpp_include('<string>'),
    collect_cpp_include('<vector>'),
    collect_cpp_include('<optional>'),
    collect_cpp_include('<functional>'),
    collect_cpp_include('<nlohmann/json.hpp>'),
    
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    (   Clauses == []
    ->  GeneratorBody = "        // No clauses - yield input once\n        results.push_back(record);"
    ;   generate_generator_body_cpp(Clauses, GeneratorBody)
    ),
    
    get_cpp_includes(IncludeList),
    format_cpp_includes(IncludeList, IncludesStr),
    
    upcase_atom(Pred, PredUpper),
    
    format(string(CppCode),
"// Generated by UnifyWeaver C++ Target - Generator Mode
// Predicate: ~w/~w

~w

using json = nlohmann::json;

/**
 * Generator for ~w predicate.
 * Returns vector of results for each input.
 */
class ~wGenerator {
public:
    std::vector<json> process(const json& record) {
        std::vector<json> results;
~w
        return results;
    }
    
    /**
     * Process all records using a callback.
     */
    template<typename Callback>
    void processAll(std::istream& input, Callback callback) {
        std::string line;
        while (std::getline(input, line)) {
            if (line.empty()) continue;
            try {
                json record = json::parse(line);
                for (const auto& result : process(record)) {
                    callback(result);
                }
            } catch (const json::exception& e) {
                std::cerr << \"JSON parse error: \" << e.what() << std::endl;
            }
        }
    }
};

void runPipeline() {
    ~wGenerator generator;
    generator.processAll(std::cin, [](const json& result) {
        std::cout << result.dump() << std::endl;
    });
}

int main() {
    runPipeline();
    return 0;
}
", [Pred, Arity, IncludesStr, Pred, PredUpper, GeneratorBody, PredUpper]).

%% generate_generator_body_cpp(+Clauses, -Code)
generate_generator_body_cpp(Clauses, Code) :-
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_cpp(Name, Clauses)
    ->  partition(is_recursive_clause_cpp(Name), Clauses, RecClauses, BaseClauses),
        compile_generator_recursive_cpp(Name, BaseClauses, RecClauses, Code)
    ;   Code = "        // Non-recursive: yield once\n        results.push_back(record);"
    ).

compile_generator_recursive_cpp(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_cpp(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"        // Recursive generator: ~w
        json current = record;
        constexpr int MAX_ITERATIONS = 10000;
        
        for (int i = 0; i < MAX_ITERATIONS; ++i) {
            results.push_back(current);
            
            // Check base case
            if (~w) {
                break;
            }
            
            // TODO: Transform for next iteration
        }", [Name, BaseCondition]).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_cpp(Pred, Arity, _Options, CppCode) :-
    collect_cpp_include('<iostream>'),
    collect_cpp_include('<string>'),
    collect_cpp_include('<optional>'),
    collect_cpp_include('<nlohmann/json.hpp>'),
    
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    (   Clauses == []
    ->  ProcessBody = "    // No clauses - pass through\n    return record;"
    ;   generate_pipeline_process_cpp(Clauses, ProcessBody)
    ),
    
    get_cpp_includes(IncludeList),
    format_cpp_includes(IncludeList, IncludesStr),
    
    format(string(CppCode),
"// Generated by UnifyWeaver C++ Target - Pipeline Mode
// Predicate: ~w/~w

~w

using json = nlohmann::json;

/**
 * Process a single record.
 * @return std::optional<json> - result or nullopt to filter out
 */
std::optional<json> process(const json& record) {
~w
}

/**
 * Run the pipeline: read JSONL from stdin, process, write to stdout.
 */
void runPipeline() {
    std::string line;
    
    while (std::getline(std::cin, line)) {
        if (line.empty()) continue;
        
        try {
            json record = json::parse(line);
            auto result = process(record);
            if (result) {
                std::cout << result->dump() << std::endl;
            }
        } catch (const json::exception& e) {
            std::cerr << \"JSON parse error: \" << e.what() << std::endl;
        }
    }
}

int main() {
    runPipeline();
    return 0;
}
", [Pred, Arity, IncludesStr, ProcessBody]).

%% generate_pipeline_process_cpp(+Clauses, -Code)
generate_pipeline_process_cpp([], "    return record;").
generate_pipeline_process_cpp(Clauses, Code) :-
    Clauses \= [],
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_cpp(Name, Clauses)
    ->  partition(is_recursive_clause_cpp(Name), Clauses, RecClauses, BaseClauses),
        (   is_tail_recursive_cpp(Name, RecClauses)
        ->  compile_tail_recursive_cpp(Name, BaseClauses, RecClauses, Code)
        ;   compile_general_recursive_cpp(Name, BaseClauses, RecClauses, Code)
        )
    ;   findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_cpp(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', Code)
    ).

%% ============================================
%% RECURSION DETECTION
%% ============================================

is_recursive_predicate_cpp(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_cpp(Body, Name).

is_recursive_clause_cpp(Name, (_, Body)) :-
    contains_recursive_call_cpp(Body, Name).

is_tail_recursive_cpp(Name, RecClauses) :-
    member((_, Body), RecClauses),
    get_last_goal_cpp(Body, LastGoal),
    functor(LastGoal, Name, _).

get_last_goal_cpp((_, B), LastGoal) :- !, get_last_goal_cpp(B, LastGoal).
get_last_goal_cpp(Goal, Goal).

contains_recursive_call_cpp(Body, Name) :-
    extract_goal_cpp(Body, Goal),
    functor(Goal, Name, _),
    !.

extract_goal_cpp(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_cpp((A, _), Goal) :- extract_goal_cpp(A, Goal).
extract_goal_cpp((_, B), Goal) :- extract_goal_cpp(B, Goal).

%% ============================================
%% TAIL RECURSION (→ while loop)
%% ============================================

compile_tail_recursive_cpp(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_cpp(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"    // Tail-recursive predicate: ~w - optimized to loop
    json current = record;
    constexpr int MAX_ITERATIONS = 10000;
    
    for (int i = 0; i < MAX_ITERATIONS; ++i) {
        // Base case check
        if (~w) {
            return current;
        }
        
        // Recursive step: transform current
        // TODO: Apply transformation
    }
    
    std::cerr << \"Warning: Max iterations exceeded for ~w\" << std::endl;
    return current;", [Name, BaseCondition, Name]).

%% ============================================
%% GENERAL RECURSION (→ stack)
%% ============================================

compile_general_recursive_cpp(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_cpp(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"    // General recursive predicate: ~w - using explicit stack
    std::vector<json> stack;
    stack.push_back(record);
    
    while (!stack.empty()) {
        json current = stack.back();
        stack.pop_back();
        
        // Base case
        if (~w) {
            return current;
        }
        
        // Push recursive case onto stack
        // TODO: Compute next value and push
    }
    
    return record;", [Name, BaseCondition]).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

translate_clause_cpp(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_cpp(Args, InputCode),
    (   Body == true
    ->  BodyCode = "    // Fact - no conditions"
    ;   translate_body_cpp(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n    return record;", [InputCode, BodyCode]).

generate_input_extraction_cpp(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "    auto arg~w = record.value(\"arg~w\", json{});", [I, I])
        ;   format(string(Line), "    // arg~w = ~w (constant)", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% ============================================
%% BODY TRANSLATION
%% ============================================

translate_body_cpp((Goal, Rest), Code) :-
    !,
    translate_goal_cpp(Goal, Code1),
    translate_body_cpp(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_cpp(Goal, Code) :-
    translate_goal_cpp(Goal, Code).

translate_goal_cpp(>(X, Y), Code) :-
    !, expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
    format(string(Code), "    if (!(~w > ~w)) return std::nullopt;", [CX, CY]).

translate_goal_cpp(<(X, Y), Code) :-
    !, expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
    format(string(Code), "    if (!(~w < ~w)) return std::nullopt;", [CX, CY]).

translate_goal_cpp(>=(X, Y), Code) :-
    !, expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
    format(string(Code), "    if (!(~w >= ~w)) return std::nullopt;", [CX, CY]).

translate_goal_cpp(=<(X, Y), Code) :-
    !, expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
    format(string(Code), "    if (!(~w <= ~w)) return std::nullopt;", [CX, CY]).

translate_goal_cpp(=:=(X, Y), Code) :-
    !, expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
    format(string(Code), "    if (~w != ~w) return std::nullopt;", [CX, CY]).

translate_goal_cpp(true, "    // true") :- !.

translate_goal_cpp(Goal, Code) :-
    format(string(Code), "    // TODO: ~w", [Goal]).

%% ============================================
%% HELPER PREDICATES
%% ============================================

generate_base_condition_cpp(Head, Condition) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), "current.value(\"arg0\", 0) == ~w", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition), "current.value(\"arg0\", \"\") == \"~w\"", [Arg])
        ;   Condition = "false"
        )
    ;   Condition = "false"
    ).

expr_to_cpp(Expr, CppExpr) :-
    (   number(Expr)
    ->  format(atom(CppExpr), "~w", [Expr])
    ;   var(Expr)
    ->  format(atom(CppExpr), "var_~p", [Expr])
    ;   Expr = X + Y
    ->  expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
        format(atom(CppExpr), "(~w + ~w)", [CX, CY])
    ;   Expr = X - Y
    ->  expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
        format(atom(CppExpr), "(~w - ~w)", [CX, CY])
    ;   Expr = X * Y
    ->  expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
        format(atom(CppExpr), "(~w * ~w)", [CX, CY])
    ;   Expr = X / Y
    ->  expr_to_cpp(X, CX), expr_to_cpp(Y, CY),
        format(atom(CppExpr), "(~w / ~w)", [CX, CY])
    ;   format(atom(CppExpr), "~w", [Expr])
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_cpp(Pred, Arity, _Options, CppCode) :-
    collect_cpp_include('<iostream>'),
    
    get_cpp_includes(IncludeList),
    format_cpp_includes(IncludeList, IncludesStr),
    
    format(string(CppCode),
"// Generated by UnifyWeaver C++ Target
// Predicate: ~w/~w

~w

int main() {
    std::cout << \"Hello from ~w\" << std::endl;
    return 0;
}
", [Pred, Arity, IncludesStr, Pred]).

%% ============================================
%% COMPILE FACTS TO C++
%% ============================================

compile_facts_to_cpp(Pred, Arity, CppCode) :-
    atom_string(Pred, PredStr),
    functor(Head, Pred, Arity),
    
    findall(Args, (clause(Head, true), Head =.. [_|Args]), AllFacts),
    
    (   AllFacts == []
    ->  FactEntries = "    // No facts defined"
    ;   findall(Entry, (
            member(Args, AllFacts),
            format_cpp_fact_entry(Args, Entry)
        ), Entries),
        atomic_list_concat(Entries, ',\n', FactEntries)
    ),
    
    format(string(CppCode),
'// Generated by UnifyWeaver C++ Target - Facts Export
// Predicate: ~w/~w

#include <iostream>
#include <string>
#include <vector>
#include <array>
#include <algorithm>

namespace ~w {

constexpr size_t ARITY = ~w;
using Fact = std::array<std::string, ARITY>;

inline const std::vector<Fact> facts = {
~w
};

inline const std::vector<Fact>& getAll() { return facts; }

template<typename... Args>
bool contains(Args&&... args) {
    Fact target = {std::forward<Args>(args)...};
    return std::find(facts.begin(), facts.end(), target) != facts.end();
}

inline void printAll() {
    for (const auto& fact : facts) {
        for (size_t i = 0; i < ARITY; ++i) {
            std::cout << fact[i];
            if (i < ARITY - 1) std::cout << \":";
        }
        std::cout << std::endl;
    }
}

} // namespace ~w

int main() {
    ~w::printAll();
    return 0;
}
', [PredStr, Arity, PredStr, Arity, FactEntries, PredStr, PredStr]).

format_cpp_fact_entry(Args, Entry) :-
    findall(Formatted, (
        member(Arg, Args),
        format(string(Formatted), '"~w"', [Arg])
    ), FormattedArgs),
    atomic_list_concat(FormattedArgs, ', ', ArgsStr),
    format(string(Entry), '    {~w}', [ArgsStr]).

%% ============================================
%% BUILD SYSTEM GENERATION
%% ============================================

generate_cmake_cpp(Options, CMakeContent) :-
    option(project_name(ProjName), Options, 'UnifyWeaverCppPipeline'),
    option(source_file(SourceFile), Options, 'pipeline.cpp'),
    
    format(string(CMakeContent),
"# Generated by UnifyWeaver C++ Target
cmake_minimum_required(VERSION 3.14)
project(~w CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Fetch nlohmann/json
include(FetchContent)
FetchContent_Declare(
    json
    URL https://github.com/nlohmann/json/releases/download/v3.11.3/json.tar.xz
)
FetchContent_MakeAvailable(json)

add_executable(pipeline ~w)
target_link_libraries(pipeline PRIVATE nlohmann_json::nlohmann_json)
", [ProjName, SourceFile]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

write_cpp_program(CppCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, CppCode),
    close(Stream),
    format('Written C++ program to: ~w~n', [FilePath]).

compile_cpp_pipeline(_Steps, _Options, Code) :-
    Code = "// Multi-step C++ pipeline - use compile_predicate_to_cpp for now".

option(Option, Options, _Default) :-
    member(Option, Options), !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

upcase_atom(Atom, Upper) :-
    atom_codes(Atom, Codes),
    maplist(upcase_code, Codes, UpperCodes),
    atom_codes(Upper, UpperCodes).

upcase_code(C, U) :-
    (   C >= 97, C =< 122
    ->  U is C - 32
    ;   U = C
    ).

%% ============================================
%% TESTS
%% ============================================

test_cpp_pipeline_mode :-
    format('~n=== Testing C++ Pipeline Mode ===~n~n'),
    
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_cpp(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'runPipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    format('~nTest 2: nlohmann/json usage~n'),
    (   sub_atom(Code1, _, _, _, 'nlohmann')
    ->  format('  [PASS] Uses nlohmann/json~n')
    ;   format('  [FAIL] Missing nlohmann/json~n')
    ),
    
    format('~nTest 3: std::optional for filtering~n'),
    (   sub_atom(Code1, _, _, _, 'std::optional')
    ->  format('  [PASS] Uses std::optional~n')
    ;   format('  [FAIL] Missing std::optional~n')
    ),
    
    format('~nTest 4: Generator mode~n'),
    compile_predicate_to_cpp(test_gen/2, [generator_mode(true)], Code2),
    (   sub_atom(Code2, _, _, _, 'Generator')
    ->  format('  [PASS] Uses Generator class~n')
    ;   format('  [FAIL] Missing Generator class~n')
    ),
    
    format('~nTest 5: CMake generation with FetchContent~n'),
    generate_cmake_cpp([project_name('TestProject')], CMake),
    (   sub_atom(CMake, _, _, _, 'FetchContent')
    ->  format('  [PASS] Uses FetchContent for dependencies~n')
    ;   format('  [FAIL] Missing FetchContent~n')
    ),
    
    format('~n=== C++ Pipeline Mode Tests Complete ===~n').
