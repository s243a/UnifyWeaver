:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% llvm_target.pl - LLVM IR Code Generation Target
%
% Compiles Prolog predicates to LLVM IR for:
% - Guaranteed tail call optimization (musttail)
% - Cross-platform native code generation
% - C ABI compatibility for FFI with Go/Rust/C

:- module(llvm_target, [
    compile_predicate_to_llvm/3,       % +PredIndicator, +Options, -LLVMCode
    compile_facts_to_llvm/3,           % +Pred, +Arity, -LLVMCode
    compile_tail_recursion_llvm/3,     % +Pred/Arity, +Options, -LLVMCode
    compile_linear_recursion_llvm/3,   % +Pred/Arity, +Options, -LLVMCode
    compile_mutual_recursion_llvm/3,   % +Predicates, +Options, -LLVMCode
    compile_transitive_closure_llvm/3, % +Pred/Arity, +Options, -LLVMCode
    write_llvm_program/2,              % +Code, +Filename
    init_llvm_target/0
]).

:- use_module(library(lists)).
:- use_module(library(option)).

%% init_llvm_target
init_llvm_target :-
    format('[LLVM Target] Initialized~n', []).

%% ============================================
%% FACTS COMPILATION
%% ============================================

compile_facts_to_llvm(Pred, Arity, Code) :-
    compile_predicate_to_llvm(Pred/Arity, [], Code).

compile_predicate_to_llvm(Pred/Arity, Options, Code) :-
    functor(Head, Pred, Arity),
    findall(Head-Body, user:clause(Head, Body), Clauses),
    (   Clauses = []
    ->  format(user_error, 'LLVM target: no clauses for ~w/~w~n', [Pred, Arity]),
        fail
    ;   (   forall(member(_-Body, Clauses), Body == true)
        ->  compile_facts_llvm(Pred, Arity, Clauses, Options, Code)
        ;   compile_rule_llvm(Pred, Arity, Clauses, Options, Code)
        )
    ).

%% compile_facts_llvm(+Pred, +Arity, +Clauses, +Options, -Code)
compile_facts_llvm(Pred, Arity, Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    length(Clauses, Count),
    
    % Generate string constants
    findall(StrConst, (
        member(Head-true, Clauses),
        Head =.. [_|Args],
        nth0(Idx, Args, Arg),
        format(string(StrConst), '@str.~w_~w = private constant [~w x i8] c"~w\\00"',
            [PredStr, Idx, length(Arg) + 1, Arg])
    ), StrConsts),
    atomic_list_concat(StrConsts, '\n', StrSection),
    
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target
; Predicate: ~w/~w
; ModuleID = ''~w''
source_filename = "~w.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; String constants
~w

; Fact count
@~w_count = constant i64 ~w

; Get count function
define i64 @get_~w_count() {
entry:
  ret i64 ~w
}
', [PredStr, Arity, PredStr, PredStr, StrSection, PredStr, Count, PredStr, Count]).

%% compile_rule_llvm(+Pred, +Arity, +Clauses, +Options, -Code)
compile_rule_llvm(Pred, Arity, _Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target - Rule
; Predicate: ~w/~w
; TODO: Implement rule compilation

define i64 @~w(i64 %%arg0) {
entry:
  ret i64 %%arg0
}
', [PredStr, Arity, PredStr]).

%% ============================================
%% TAIL RECURSION (musttail)
%% ============================================

compile_tail_recursion_llvm(Pred/Arity, Options, Code) :-
    atom_string(Pred, PredStr),
    option(export(Export), Options, false),
    
    % Generate extern wrapper if export requested
    (   Export == true
    ->  format(string(ExternWrapper),
'
; Extern C wrapper for FFI
define dllexport i64 @~w_ext(i64 %%n) {
entry:
  %%result = call i64 @~w(i64 %%n, i64 0)
  ret i64 %%result
}
', [PredStr, PredStr])
    ;   ExternWrapper = ""
    ),
    
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target - Tail Recursion
; Predicate: ~w/~w
; Guaranteed O(1) stack space via musttail

source_filename = "~w.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Tail-recursive function with musttail optimization
define i64 @~w(i64 %%n, i64 %%acc) {
entry:
  %%cmp = icmp sle i64 %%n, 0
  br i1 %%cmp, label %%base, label %%recurse

base:
  ret i64 %%acc

recurse:
  %%n1 = sub i64 %%n, 1
  %%acc1 = add i64 %%acc, %%n
  %%result = musttail call i64 @~w(i64 %%n1, i64 %%acc1)
  ret i64 %%result
}

; Entry point wrapper (single argument)
define i64 @~w_entry(i64 %%n) {
entry:
  %%result = call i64 @~w(i64 %%n, i64 0)
  ret i64 %%result
}
~w
; Main function for standalone execution
define i32 @main(i32 %%argc, i8** %%argv) {
entry:
  %%result = call i64 @~w_entry(i64 10)
  %%exitcode = trunc i64 %%result to i32
  ret i32 0
}
', [PredStr, Arity, PredStr, PredStr, PredStr, PredStr, PredStr, ExternWrapper, PredStr]).

%% ============================================
%% LINEAR RECURSION (with memoization)
%% ============================================

compile_linear_recursion_llvm(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target - Linear Recursion
; Predicate: ~w/~w
; Note: Memoization requires runtime support

source_filename = "~w.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Memo table (fixed size for simplicity)
@memo = internal global [1000 x i64] zeroinitializer
@memo_valid = internal global [1000 x i1] zeroinitializer

define i64 @~w(i64 %%n) {
entry:
  ; Check bounds
  %%in_bounds = icmp slt i64 %%n, 1000
  br i1 %%in_bounds, label %%check_memo, label %%compute

check_memo:
  %%valid_ptr = getelementptr [1000 x i1], [1000 x i1]* @memo_valid, i64 0, i64 %%n
  %%is_valid = load i1, i1* %%valid_ptr
  br i1 %%is_valid, label %%return_memo, label %%compute

return_memo:
  %%memo_ptr = getelementptr [1000 x i64], [1000 x i64]* @memo, i64 0, i64 %%n
  %%memo_val = load i64, i64* %%memo_ptr
  ret i64 %%memo_val

compute:
  ; Base cases
  %%is_zero = icmp sle i64 %%n, 0
  br i1 %%is_zero, label %%base_zero, label %%check_one

base_zero:
  ret i64 0

check_one:
  %%is_one = icmp eq i64 %%n, 1
  br i1 %%is_one, label %%base_one, label %%recursive

base_one:
  ret i64 1

recursive:
  %%n1 = sub i64 %%n, 1
  %%sub_result = call i64 @~w(i64 %%n1)
  %%result = add i64 %%sub_result, %%n
  
  ; Store in memo
  %%store_ptr = getelementptr [1000 x i64], [1000 x i64]* @memo, i64 0, i64 %%n
  store i64 %%result, i64* %%store_ptr
  %%valid_store = getelementptr [1000 x i1], [1000 x i1]* @memo_valid, i64 0, i64 %%n
  store i1 true, i1* %%valid_store
  
  ret i64 %%result
}

define i32 @main(i32 %%argc, i8** %%argv) {
entry:
  %%result = call i64 @~w(i64 10)
  ret i32 0
}
', [PredStr, Arity, PredStr, PredStr, PredStr, PredStr]).

%% ============================================
%% MUTUAL RECURSION
%% ============================================

compile_mutual_recursion_llvm(Predicates, _Options, Code) :-
    findall(PredStr, (
        member(Pred/_Arity, Predicates),
        atom_string(Pred, PredStr)
    ), PredStrs),
    atomic_list_concat(PredStrs, '_', GroupName),
    
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target - Mutual Recursion
; Group: ~w
; is_even / is_odd mutual recursion

source_filename = "~w.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Forward declaration
declare i1 @is_odd(i64)

define i1 @is_even(i64 %%n) {
entry:
  %%is_zero = icmp eq i64 %%n, 0
  br i1 %%is_zero, label %%base_true, label %%check_positive

base_true:
  ret i1 true

check_positive:
  %%is_positive = icmp sgt i64 %%n, 0
  br i1 %%is_positive, label %%recurse, label %%base_false

recurse:
  %%n1 = sub i64 %%n, 1
  %%result = musttail call i1 @is_odd(i64 %%n1)
  ret i1 %%result

base_false:
  ret i1 false
}

define i1 @is_odd(i64 %%n) {
entry:
  %%is_zero = icmp eq i64 %%n, 0
  br i1 %%is_zero, label %%base_false, label %%check_positive

base_false:
  ret i1 false

check_positive:
  %%is_positive = icmp sgt i64 %%n, 0
  br i1 %%is_positive, label %%recurse, label %%base_false2

recurse:
  %%n1 = sub i64 %%n, 1
  %%result = musttail call i1 @is_even(i64 %%n1)
  ret i1 %%result

base_false2:
  ret i1 false
}

define i32 @main(i32 %%argc, i8** %%argv) {
entry:
  %%even_10 = call i1 @is_even(i64 10)
  %%odd_10 = call i1 @is_odd(i64 10)
  ret i32 0
}
', [GroupName, GroupName]).

%% ============================================
%% TRANSITIVE CLOSURE (BFS worklist)
%% ============================================

%% compile_transitive_closure_llvm(+Pred/Arity, +Options, -Code)
%  Generates LLVM IR for graph reachability using BFS.
%  Useful for: ancestor/descendant queries, graph connectivity.
compile_transitive_closure_llvm(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    
    format(string(Code),
'; Generated by UnifyWeaver LLVM Target - Transitive Closure
; Predicate: ~w/~w
; Algorithm: BFS worklist for graph reachability

source_filename = "~w.ll"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-pc-linux-gnu"

; Edge representation: adjacency list (simplified as array pairs)
; Edge: [from, to] stored contiguously
@edges = internal global [100 x i64] zeroinitializer
@edge_count = internal global i64 0

; Visited set (bitmap for efficiency)
@visited = internal global [1000 x i1] zeroinitializer

; BFS queue
@queue = internal global [1000 x i64] zeroinitializer
@queue_head = internal global i64 0
@queue_tail = internal global i64 0

; Add an edge to the graph
define void @add_edge(i64 %from, i64 %to) {
entry:
  %count = load i64, i64* @edge_count
  %idx1 = mul i64 %count, 2
  %idx2 = add i64 %idx1, 1
  %ptr1 = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %idx1
  %ptr2 = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %idx2
  store i64 %from, i64* %ptr1
  store i64 %to, i64* %ptr2
  %new_count = add i64 %count, 1
  store i64 %new_count, i64* @edge_count
  ret void
}

; Enqueue a node
define void @enqueue(i64 %node) {
entry:
  %tail = load i64, i64* @queue_tail
  %ptr = getelementptr [1000 x i64], [1000 x i64]* @queue, i64 0, i64 %tail
  store i64 %node, i64* %ptr
  %new_tail = add i64 %tail, 1
  store i64 %new_tail, i64* @queue_tail
  ret void
}

; Dequeue a node
define i64 @dequeue() {
entry:
  %head = load i64, i64* @queue_head
  %ptr = getelementptr [1000 x i64], [1000 x i64]* @queue, i64 0, i64 %head
  %node = load i64, i64* %ptr
  %new_head = add i64 %head, 1
  store i64 %new_head, i64* @queue_head
  ret i64 %node
}

; Check if queue is empty
define i1 @queue_empty() {
entry:
  %head = load i64, i64* @queue_head
  %tail = load i64, i64* @queue_tail
  %empty = icmp eq i64 %head, %tail
  ret i1 %empty
}

; Check if node is visited
define i1 @is_visited(i64 %node) {
entry:
  %ptr = getelementptr [1000 x i1], [1000 x i1]* @visited, i64 0, i64 %node
  %val = load i1, i1* %ptr
  ret i1 %val
}

; Mark node as visited
define void @mark_visited(i64 %node) {
entry:
  %ptr = getelementptr [1000 x i1], [1000 x i1]* @visited, i64 0, i64 %node
  store i1 true, i1* %ptr
  ret void
}

; Transitive closure: can we reach target from source?
; reachable(Source, Target) -> bool
define i1 @~w(i64 %source, i64 %target) {
entry:
  ; Reset visited and queue
  store i64 0, i64* @queue_head
  store i64 0, i64* @queue_tail
  
  ; Mark source visited and enqueue
  call void @mark_visited(i64 %source)
  call void @enqueue(i64 %source)
  
  br label %bfs_loop

bfs_loop:
  %empty = call i1 @queue_empty()
  br i1 %empty, label %not_found, label %process_node

process_node:
  %current = call i64 @dequeue()
  
  ; Check if we found target
  %found = icmp eq i64 %current, %target
  br i1 %found, label %found_target, label %explore_neighbors

found_target:
  ret i1 true

explore_neighbors:
  ; Iterate through edges (simplified: check all edges)
  %edge_cnt = load i64, i64* @edge_count
  br label %edge_loop

edge_loop:
  %i = phi i64 [ 0, %explore_neighbors ], [ %i_next, %edge_continue ]
  %done = icmp sge i64 %i, %edge_cnt
  br i1 %done, label %bfs_loop, label %check_edge

check_edge:
  %from_idx = mul i64 %i, 2
  %to_idx = add i64 %from_idx, 1
  %from_ptr = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %from_idx
  %to_ptr = getelementptr [100 x i64], [100 x i64]* @edges, i64 0, i64 %to_idx
  %from = load i64, i64* %from_ptr
  %to = load i64, i64* %to_ptr
  
  ; Check if this edge starts from current node
  %is_match = icmp eq i64 %from, %current
  br i1 %is_match, label %maybe_enqueue, label %edge_continue

maybe_enqueue:
  ; Check if neighbor not visited
  %already_visited = call i1 @is_visited(i64 %to)
  br i1 %already_visited, label %edge_continue, label %do_enqueue

do_enqueue:
  call void @mark_visited(i64 %to)
  call void @enqueue(i64 %to)
  br label %edge_continue

edge_continue:
  %i_next = add i64 %i, 1
  br label %edge_loop

not_found:
  ret i1 false
}

; Main entry point for testing
define i32 @main(i32 %argc, i8** %argv) {
entry:
  ; Create test graph: 0 -> 1 -> 2 -> 3
  call void @add_edge(i64 0, i64 1)
  call void @add_edge(i64 1, i64 2)
  call void @add_edge(i64 2, i64 3)
  
  ; Test: can we reach 3 from 0?
  %result = call i1 @~w(i64 0, i64 3)
  
  ; Return 0 if reachable (success), 1 otherwise
  %exit = select i1 %result, i32 0, i32 1
  ret i32 %exit
}
', [PredStr, Arity, PredStr, PredStr, PredStr]).

%% ============================================
%% FILE OUTPUT
%% ============================================

write_llvm_program(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('LLVM IR written to: ~w~n', [Filename]),
    format('Compile with: llc -filetype=obj ~w -o ~w.o && clang ~w.o -o ~w~n', 
        [Filename, Filename, Filename, Filename]).
