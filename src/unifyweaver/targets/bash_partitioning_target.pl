:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% bash_partitioning_target.pl - Pure Bash Partitioning Code Generator
% Generates bash scripts for partitioning data without Prolog dependencies

:- module(bash_partitioning_target, [
    generate_bash_partitioner/3,    % +Strategy, +Options, -BashCode
    write_bash_partitioner/2        % +BashCode, +FilePath
]).

:- use_module(library(lists)).

%% ============================================
%% PUBLIC API
%% ============================================

%% generate_bash_partitioner(+Strategy, +Options, -BashCode)
%  Generate bash code for partitioning with given strategy
%
%  @arg Strategy Partitioning strategy: fixed_size(rows(N)|bytes(N)), hash_based(...), key_based(...)
%  @arg Options List of options
%  @arg BashCode Generated bash code as atom
%
%  Options:
%  - function_name(Name) - Name of bash function (default: partition_data)
%  - output_dir_var(Var) - Bash variable name for output directory (default: PARTITION_DIR)
%  - include_header(true|false) - Include shebang and comments (default: true)
%  - include_main(true|false) - Include main entry point that calls function (default: true)
%
generate_bash_partitioner(Strategy, Options, BashCode) :-
    option(function_name(FuncName), Options, partition_data),
    option(output_dir_var(DirVar), Options, 'PARTITION_DIR'),
    option(include_header(IncludeHeader), Options, true),
    option(include_main(IncludeMain), Options, true),

    % Generate appropriate code based on strategy
    generate_strategy_code(Strategy, FuncName, DirVar, StrategyCode),

    % Optionally add main entry point
    (   IncludeMain
    ->  generate_main_entry(FuncName, MainEntry),
        atomic_list_concat([StrategyCode, '\n\n', MainEntry], StrategyWithMain)
    ;   StrategyWithMain = StrategyCode
    ),

    % Optionally add header
    (   IncludeHeader
    ->  generate_header(Strategy, Header),
        atomic_list_concat([Header, '\n\n', StrategyWithMain], BashCode)
    ;   BashCode = StrategyWithMain
    ).

%% write_bash_partitioner(+BashCode, +FilePath)
%  Write generated bash code to file and make it executable
%
write_bash_partitioner(BashCode, FilePath) :-
    open(FilePath, write, Stream),
    format(Stream, '~w', [BashCode]),
    close(Stream),
    % Make executable
    format(atom(ChmodCmd), 'chmod +x ~w', [FilePath]),
    shell(ChmodCmd),
    format('[BashPartitioner] Generated executable bash script: ~w~n', [FilePath]).

%% ============================================
%% MAIN ENTRY POINT GENERATION
%% ============================================

generate_main_entry(FuncName, MainEntry) :-
    format(atom(MainEntry),
'# Main entry point - call function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    ~w "$@"
fi', [FuncName]).

%% ============================================
%% HEADER GENERATION
%% ============================================

generate_header(Strategy, Header) :-
    get_unifyweaver_version(Version),
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),
    strategy_description(Strategy, Description),

    format(atom(Header),
'#!/bin/bash
# Generated by UnifyWeaver ~w
# Target: Pure Bash Partitioning
# Generated: ~w
# Strategy: ~w
', [Version, DateStr, Description]).

get_unifyweaver_version('v0.0.3').

strategy_description(fixed_size(rows(N)), Desc) :-
    format(atom(Desc), 'Fixed-size partitioning (~w rows per partition)', [N]).
strategy_description(fixed_size(bytes(N)), Desc) :-
    format(atom(Desc), 'Fixed-size partitioning (~w bytes per partition)', [N]).
strategy_description(hash_based(_), 'Hash-based partitioning').
strategy_description(key_based(_), 'Key-based (GROUP BY) partitioning').

%% ============================================
%% STRATEGY CODE GENERATION
%% ============================================

%% Fixed-Size Row Partitioning
generate_strategy_code(fixed_size(rows(RowsPerPartition)), FuncName, DirVar, Code) :-
    format(atom(SplitLine), '    split -l ~w \\', [RowsPerPartition]),
    format(atom(MetadataRows), '  "rows_per_partition": ~w,', [RowsPerPartition]),
    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),

    atomic_list_concat([
        '# Partition data by rows using GNU split',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # Partition using split command',
        SplitLine,
        '          -d \\',
        '          --additional-suffix=.txt \\',
        '          "$input_file" \\',
        '          "$output_dir/partition_"',
        '',
        '    # Count partitions',
        '    local partition_count=$(ls "$output_dir"/partition_* 2>/dev/null | wc -l)',
        '',
        '    # Generate metadata',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "fixed_size",',
        '  "mode": "rows",',
        MetadataRows,
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | wc -l',
        '}'
    ], '\n', Code).

%% Fixed-Size Byte Partitioning
generate_strategy_code(fixed_size(bytes(BytesPerPartition)), FuncName, DirVar, Code) :-
    format(atom(SplitLine), '    split -b ~w \\', [BytesPerPartition]),
    format(atom(MetadataBytes), '  "bytes_per_partition": ~w,', [BytesPerPartition]),
    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),

    atomic_list_concat([
        '# Partition data by bytes using GNU split',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # Partition using split command',
        SplitLine,
        '          -d \\',
        '          --additional-suffix=.txt \\',
        '          "$input_file" \\',
        '          "$output_dir/partition_"',
        '',
        '    # Count partitions',
        '    local partition_count=$(ls "$output_dir"/partition_* 2>/dev/null | wc -l)',
        '',
        '    # Generate metadata',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "fixed_size",',
        '  "mode": "bytes",',
        MetadataBytes,
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | wc -l',
        '}'
    ], '\n', Code).

%% Placeholder for future strategies
generate_strategy_code(hash_based(_), _, _, _) :-
    throw(error(not_implemented, 'Hash-based partitioning not yet implemented for bash target')).

generate_strategy_code(key_based(_), _, _, _) :-
    throw(error(not_implemented, 'Key-based partitioning not yet implemented for bash target')).

%% Helper to get option with default
option(Option, Options, Default) :-
    (   member(Option, Options)
    ->  true
    ;   Option =.. [Key, Default],
        \+ member(Key=_, Options)
    ).
