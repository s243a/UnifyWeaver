:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% bash_partitioning_target.pl - Pure Bash Partitioning Code Generator
% Generates bash scripts for partitioning data without Prolog dependencies

:- module(bash_partitioning_target, [
    generate_bash_partitioner/3,    % +Strategy, +Options, -BashCode
    write_bash_partitioner/2        % +BashCode, +FilePath
]).

:- use_module(library(lists)).

%% ============================================
%% PUBLIC API
%% ============================================

%% generate_bash_partitioner(+Strategy, +Options, -BashCode)
%  Generate bash code for partitioning with given strategy
%
%  @arg Strategy Partitioning strategy: fixed_size(rows(N)|bytes(N)), hash_based(...), key_based(...)
%  @arg Options List of options
%  @arg BashCode Generated bash code as atom
%
%  Options:
%  - function_name(Name) - Name of bash function (default: partition_data)
%  - output_dir_var(Var) - Bash variable name for output directory (default: PARTITION_DIR)
%  - include_header(true|false) - Include shebang and comments (default: true)
%  - include_main(true|false) - Include main entry point that calls function (default: true)
%
generate_bash_partitioner(Strategy, Options, BashCode) :-
    option(function_name(FuncName), Options, partition_data),
    option(output_dir_var(DirVar), Options, 'PARTITION_DIR'),
    option(include_header(IncludeHeader), Options, true),
    option(include_main(IncludeMain), Options, true),

    % Generate appropriate code based on strategy
    generate_strategy_code(Strategy, FuncName, DirVar, StrategyCode),

    % Optionally add main entry point
    (   IncludeMain
    ->  generate_main_entry(FuncName, MainEntry),
        atomic_list_concat([StrategyCode, '\n\n', MainEntry], StrategyWithMain)
    ;   StrategyWithMain = StrategyCode
    ),

    % Optionally add header
    (   IncludeHeader
    ->  generate_header(Strategy, Header),
        atomic_list_concat([Header, '\n\n', StrategyWithMain], BashCode)
    ;   BashCode = StrategyWithMain
    ).

%% write_bash_partitioner(+BashCode, +FilePath)
%  Write generated bash code to file and make it executable
%
write_bash_partitioner(BashCode, FilePath) :-
    open(FilePath, write, Stream),
    format(Stream, '~w', [BashCode]),
    close(Stream),
    % Make executable
    format(atom(ChmodCmd), 'chmod +x ~w', [FilePath]),
    shell(ChmodCmd),
    format('[BashPartitioner] Generated executable bash script: ~w~n', [FilePath]).

%% ============================================
%% MAIN ENTRY POINT GENERATION
%% ============================================

generate_main_entry(FuncName, MainEntry) :-
    format(atom(MainEntry),
'# Main entry point - call function if script is executed directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    ~w "$@"
fi', [FuncName]).

%% ============================================
%% HEADER GENERATION
%% ============================================

generate_header(Strategy, Header) :-
    get_unifyweaver_version(Version),
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),
    strategy_description(Strategy, Description),

    format(atom(Header),
'#!/bin/bash
# Generated by UnifyWeaver ~w
# Target: Pure Bash Partitioning
# Generated: ~w
# Strategy: ~w
', [Version, DateStr, Description]).

get_unifyweaver_version('v0.0.3').

strategy_description(fixed_size(rows(N)), Desc) :-
    format(atom(Desc), 'Fixed-size partitioning (~w rows per partition)', [N]).
strategy_description(fixed_size(bytes(N)), Desc) :-
    format(atom(Desc), 'Fixed-size partitioning (~w bytes per partition)', [N]).
strategy_description(hash_based(Args), Desc) :-
    (   member(column(Col), Args)
    ->  true
    ;   Col = 1
    ),
    (   member(num_partitions(N), Args)
    ->  true
    ;   N = 8
    ),
    format(atom(Desc), 'Hash-based partitioning (column ~w, ~w partitions)', [Col, N]).
strategy_description(key_based(Args), Desc) :-
    (   member(column(Col), Args)
    ->  true
    ;   Col = 1
    ),
    format(atom(Desc), 'Key-based (GROUP BY) partitioning (column ~w)', [Col]).

%% ============================================
%% STRATEGY CODE GENERATION
%% ============================================

%% Fixed-Size Row Partitioning
generate_strategy_code(fixed_size(rows(RowsPerPartition)), FuncName, DirVar, Code) :-
    format(atom(SplitLine), '    split -l ~w \\', [RowsPerPartition]),
    format(atom(MetadataRows), '  "rows_per_partition": ~w,', [RowsPerPartition]),
    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),

    atomic_list_concat([
        '# Partition data by rows using GNU split',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # Partition using split command',
        SplitLine,
        '          -d \\',
        '          --additional-suffix=.txt \\',
        '          "$input_file" \\',
        '          "$output_dir/partition_"',
        '',
        '    # Count partitions',
        '    local partition_count=$(ls "$output_dir"/partition_* 2>/dev/null | wc -l)',
        '',
        '    # Generate metadata',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "fixed_size",',
        '  "mode": "rows",',
        MetadataRows,
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | wc -l',
        '}'
    ], '\n', Code).

%% Fixed-Size Byte Partitioning
generate_strategy_code(fixed_size(bytes(BytesPerPartition)), FuncName, DirVar, Code) :-
    format(atom(SplitLine), '    split -b ~w \\', [BytesPerPartition]),
    format(atom(MetadataBytes), '  "bytes_per_partition": ~w,', [BytesPerPartition]),
    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),

    atomic_list_concat([
        '# Partition data by bytes using GNU split',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # Partition using split command',
        SplitLine,
        '          -d \\',
        '          --additional-suffix=.txt \\',
        '          "$input_file" \\',
        '          "$output_dir/partition_"',
        '',
        '    # Count partitions',
        '    local partition_count=$(ls "$output_dir"/partition_* 2>/dev/null | wc -l)',
        '',
        '    # Generate metadata',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "fixed_size",',
        '  "mode": "bytes",',
        MetadataBytes,
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | wc -l',
        '}'
    ], '\n', Code).

%% Hash-Based Partitioning
generate_strategy_code(hash_based(Args), FuncName, DirVar, Code) :-
    % Extract configuration
    (   member(column(ColNum), Args)
    ->  true
    ;   ColNum = 1  % Default: first column
    ),
    (   member(num_partitions(NumPartitions), Args)
    ->  true
    ;   NumPartitions = 8  % Default: 8 partitions
    ),
    (   member(delimiter(Delim), Args)
    ->  true
    ;   Delim = '\t'  % Default: tab-delimited
    ),

    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),
    format(atom(ColNumStr), '~w', [ColNum]),
    format(atom(NumPartitionsStr), '~w', [NumPartitions]),
    format(atom(ColumnLine), '    local column=~w', [ColNum]),
    format(atom(PartitionsLine), '    local num_partitions=~w', [NumPartitions]),
    format(atom(DelimLine), '    local delimiter="~w"', [Delim]),

    atomic_list_concat([
        '# Partition data by hash of column using AWK',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        ColumnLine,
        PartitionsLine,
        DelimLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # Partition using AWK hash function',
        '    awk -F"$delimiter" -v col="$column" -v n="$num_partitions" -v outdir="$output_dir" \'',
        '    {',
        '        # Extract key from specified column',
        '        key = $col',
        '        ',
        '        # Simple hash: sum of character codes modulo n',
        '        hash = 0',
        '        for (i = 1; i <= length(key); i++) {',
        '            hash += int(index("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", substr(key, i, 1)))',
        '        }',
        '        partition_id = hash % n',
        '        ',
        '        # Write to partition file',
        '        printf "%s\\n", $0 > (outdir "/partition_" sprintf("%02d", partition_id) ".txt")',
        '    }',
        '    \' "$input_file"',
        '',
        '    # Close all partition files',
        '    wait',
        '',
        '    # Count partitions',
        '    local partition_count=$(ls "$output_dir"/partition_* 2>/dev/null | wc -l)',
        '',
        '    # Generate metadata',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "hash_based",',
        '  "column": ', ColNumStr, ',',
        '  "num_partitions": ', NumPartitionsStr, ',',
        '  "delimiter": "', Delim, '",',
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir (hash-based on column ', ColNumStr, ')"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | wc -l',
        '}'
    ], '\n', Code).

%% Key-Based (GROUP BY) Partitioning
generate_strategy_code(key_based(Args), FuncName, DirVar, Code) :-
    % Extract configuration
    (   member(column(ColNum), Args)
    ->  true
    ;   ColNum = 1  % Default: first column
    ),
    (   member(delimiter(Delim), Args)
    ->  true
    ;   Delim = '\t'  % Default: tab-delimited
    ),

    format(atom(FuncDef), '~w() {', [FuncName]),
    format(atom(OutputDirLine), '    local output_dir="${~w:-/tmp/partitions_$$}"', [DirVar]),
    format(atom(ColNumStr), '~w', [ColNum]),
    format(atom(ColumnLine), '    local column=~w', [ColNum]),
    format(atom(DelimLine), '    local delimiter="~w"', [Delim]),

    atomic_list_concat([
        '# Partition data by grouping on column value (GROUP BY)',
        FuncDef,
        '    local input_file="$1"',
        OutputDirLine,
        ColumnLine,
        DelimLine,
        '',
        '    # Create output directory',
        '    mkdir -p "$output_dir"',
        '',
        '    # First pass: collect unique keys and assign partition IDs',
        '    awk -F"$delimiter" -v col="$column" -v outdir="$output_dir" \'',
        '    {',
        '        key = $col',
        '        if (!(key in partition_map)) {',
        '            partition_id = partition_count++',
        '            partition_map[key] = partition_id',
        '            # Store key in metadata file',
        '            print key > (outdir "/key_" sprintf("%03d", partition_id) ".txt")',
        '        }',
        '        # Write record to appropriate partition',
        '        pid = partition_map[key]',
        '        print $0 > (outdir "/partition_" sprintf("%03d", pid) ".txt")',
        '    }',
        '    END {',
        '        # Write partition count',
        '        print partition_count > (outdir "/partition_count.txt")',
        '    }',
        '    \' "$input_file"',
        '',
        '    # Close all files',
        '    wait',
        '',
        '    # Read partition count',
        '    local partition_count=$(cat "$output_dir/partition_count.txt" 2>/dev/null || echo 0)',
        '',
        '    # Generate metadata with key mappings',
        '    cat > "$output_dir/metadata.json" <<EOF',
        '{',
        '  "strategy": "key_based",',
        '  "column": ', ColNumStr, ',',
        '  "delimiter": "', Delim, '",',
        '  "partition_count": $partition_count,',
        '  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",',
        '  "key_mappings": [',
        'EOF',
        '',
        '    # Add key mappings to metadata',
        '    local first=true',
        '    for key_file in "$output_dir"/key_*.txt; do',
        '        if [ -f "$key_file" ]; then',
        '            key=$(cat "$key_file")',
        '            pid=$(basename "$key_file" | sed \'s/key_\\([0-9]*\\).txt/\\1/\')',
        '            if [ "$first" = true ]; then',
        '                first=false',
        '            else',
        '                echo "," >> "$output_dir/metadata.json"',
        '            fi',
        '            echo "    {\"partition_id\": $pid, \"key\": \"$key\"}" >> "$output_dir/metadata.json"',
        '        fi',
        '    done',
        '',
        '    # Close metadata',
        '    cat >> "$output_dir/metadata.json" <<EOF',
        '  ]',
        '}',
        'EOF',
        '',
        '    # Export partition info',
        '    export PARTITION_COUNT=$partition_count',
        '    export PARTITION_DIR="$output_dir"',
        '',
        '    echo "[Partitioner] Created $partition_count partitions in $output_dir (grouped by column ', ColNumStr, ')"',
        '}',
        '',
        '# Helper: List all partition files',
        'list_partitions() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    ls "$dir"/partition_* 2>/dev/null | sort',
        '}',
        '',
        '# Helper: Get partition count',
        'get_partition_count() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    cat "$dir/partition_count.txt" 2>/dev/null || echo 0',
        '}',
        '',
        '# Helper: Get key for partition ID',
        'get_partition_key() {',
        '    local dir="${1:-$PARTITION_DIR}"',
        '    local pid="$2"',
        '    cat "$dir/key_$(printf "%03d" $pid).txt" 2>/dev/null',
        '}'
    ], '\n', Code).

%% Helper to get option with default
option(Option, Options, Default) :-
    (   member(Option, Options)
    ->  true
    ;   Option =.. [Key, Default],
        \+ member(Key=_, Options)
    ).
