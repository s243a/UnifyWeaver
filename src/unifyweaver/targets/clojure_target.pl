% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% clojure_target.pl - Clojure Target for UnifyWeaver
% Generates Clojure programs for record/field processing
% Supports lazy sequences, immutable data, and Java interop

:- encoding(utf8).

:- module(clojure_target, [
    compile_predicate_to_clojure/3,    % +Predicate, +Options, -ClojureCode
    compile_clojure_pipeline/3,        % +Predicates, +Options, -ClojureCode
    generate_deps_edn/2,               % +Options, -DepsFile
    write_clojure_program/2,           % +ClojureCode, +FilePath
    init_clojure_target/0,             % Initialize Clojure target
    test_clojure_pipeline_mode/0       % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').

% Track required imports
:- dynamic required_clojure_require/1.

%% init_clojure_target
init_clojure_target :-
    retractall(required_clojure_require(_)).

%% clear_clojure_requires
clear_clojure_requires :-
    retractall(required_clojure_require(_)).

%% collect_clojure_require(+Require)
collect_clojure_require(Require) :-
    (   required_clojure_require(Require)
    ->  true
    ;   assertz(required_clojure_require(Require))
    ).

%% get_clojure_requires(-Requires)
get_clojure_requires(Requires) :-
    findall(R, required_clojure_require(R), Requires).

%% format_clojure_requires(+Requires, -FormattedStr)
format_clojure_requires([], "").
format_clojure_requires(Requires, FormattedStr) :-
    Requires \= [],
    sort(Requires, UniqueRequires),
    findall(Formatted,
        (   member(Require, UniqueRequires),
            format(string(Formatted), "  (:require ~w)~n", [Require])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_clojure(+Predicate, +Options, -ClojureCode)
compile_predicate_to_clojure(PredIndicator, Options, ClojureCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to Clojure ===~n', [Pred, Arity]),

    clear_clojure_requires,

    % Check mode
    (   option(generator_mode(true), Options)
    ->  format('  Mode: Generator (lazy-seq)~n'),
        compile_generator_mode_clojure(Pred, Arity, Options, ClojureCode)
    ;   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming)~n'),
        compile_pipeline_mode_clojure(Pred, Arity, Options, ClojureCode)
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_clojure(Pred, Arity, Options, ClojureCode)
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_clojure(Pred, Arity, _Options, ClojureCode) :-
    format(string(ClojureCode),
";; Generated by UnifyWeaver Clojure Target
;; Predicate: ~w/~w

(ns generated.~w)

(defn ~w
  \"Predicate ~w/~w\"
  [& args]
  ;; TODO: Implement ~w logic
  nil)

(defn -main
  [& args]
  ;; TODO: Add main logic
  (println \"Hello from ~w\"))
", [Pred, Arity, Pred, Pred, Pred, Arity, Pred, Pred]).

%% ============================================
%% GENERATOR MODE (Clojure's lazy-seq)
%% ============================================

compile_generator_mode_clojure(Pred, Arity, Options, ClojureCode) :-
    collect_clojure_require('[clojure.data.json :as json]'),
    collect_clojure_require('[clojure.java.io :as io]'),
    
    option(namespace(Namespace), Options, 'generated.pipeline'),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate process function body
    (   Clauses == []
    ->  ProcessBody = "  ;; No clauses found - yield input unchanged\n  (list record)"
    ;   generate_generator_body_clojure(Clauses, ProcessBody)
    ),
    
    get_clojure_requires(RequireList),
    format_clojure_requires(RequireList, RequiresStr),
    
    format(string(ClojureCode),
";; Generated by UnifyWeaver Clojure Target - Generator Mode
;; Predicate: ~w/~w
;; Uses Clojure's lazy-seq for lazy evaluation

(ns ~w
~w)

(defn process
  \"Process a single record, returning zero or more results (lazy).\"
  [record]
~w)

(defn process-all
  \"Process all records from a sequence, flattening results.\"
  [records]
  (mapcat process records))

(defn parse-json-line
  \"Parse a JSONL line to a map.\"
  [line]
  (try
    (json/read-str line :key-fn keyword)
    (catch Exception e
      (binding [*out* *err*]
        (println \"JSON parse error:\" (.getMessage e)))
      nil)))

(defn to-json
  \"Convert a map to JSON string.\"
  [m]
  (json/write-str m))

(defn run-pipeline
  \"Read JSONL from stdin, process, write JSONL to stdout.\"
  []
  (with-open [rdr (io/reader *in*)]
    (doseq [result (->> (line-seq rdr)
                        (filter seq)
                        (keep parse-json-line)
                        process-all)]
      (println (to-json result)))))

(defn -main
  [& args]
  (run-pipeline))
", [Pred, Arity, Namespace, RequiresStr, ProcessBody]).

%% generate_generator_body_clojure(+Clauses, -Code)
generate_generator_body_clojure(Clauses, Code) :-
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_clojure(Name, Clauses)
    ->  partition(is_recursive_clause_clojure(Name), Clauses, RecClauses, BaseClauses),
        compile_generator_recursive_clojure(Name, BaseClauses, RecClauses, Code)
    ;   findall(ClauseCode, 
            (member((H, B), Clauses), translate_generator_clause_clojure(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', Code)
    ).

translate_generator_clause_clojure(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_clojure(Args, InputCode),
    (   Body == true
    ->  BodyCode = "    ;; Fact - unconditional"
    ;   translate_generator_body_clojure(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n    (list record)", [InputCode, BodyCode]).

translate_generator_body_clojure((Goal, Rest), Code) :-
    !,
    translate_generator_goal_clojure(Goal, Code1),
    translate_generator_body_clojure(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_generator_body_clojure(Goal, Code) :-
    translate_generator_goal_clojure(Goal, Code).

translate_generator_goal_clojure(>(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "    (when-not (> ~w ~w) (return nil))", [CX, CY]).

translate_generator_goal_clojure(<(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "    (when-not (< ~w ~w) (return nil))", [CX, CY]).

translate_generator_goal_clojure(=:=(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "    (when-not (= ~w ~w) (return nil))", [CX, CY]).

translate_generator_goal_clojure(true, "    ;; true") :- !.

translate_generator_goal_clojure(Goal, Code) :-
    format(string(Code), "    ;; TODO: ~w", [Goal]).

compile_generator_recursive_clojure(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_clojure(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"  ;; Recursive generator: ~w
  (letfn [(iterate [current depth]
            (lazy-seq
              (if (> depth 10000)
                (do (binding [*out* *err*]
                      (println \"Warning: Max depth exceeded for ~w\"))
                    nil)
                (if ~w
                  (list current)
                  (cons current (iterate current (inc depth)))))))]
    (iterate record 0))", [Name, Name, BaseCondition]).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_clojure(Pred, Arity, Options, ClojureCode) :-
    collect_clojure_require('[clojure.data.json :as json]'),
    collect_clojure_require('[clojure.java.io :as io]'),
    
    option(namespace(Namespace), Options, 'generated.pipeline'),
    
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    (   Clauses == []
    ->  ProcessBody = "  ;; No clauses found - pass through\n  record"
    ;   generate_pipeline_process_clojure(Clauses, ProcessBody)
    ),
    
    get_clojure_requires(RequireList),
    format_clojure_requires(RequireList, RequiresStr),
    
    format(string(ClojureCode),
";; Generated by UnifyWeaver Clojure Target - Pipeline Mode
;; Predicate: ~w/~w

(ns ~w
~w)

(defn process
  \"Process a single input record.
   Returns record to keep, nil to filter out.\"
  [record]
~w)

(defn parse-json-line
  \"Parse a JSONL line to a map.\"
  [line]
  (try
    (json/read-str line :key-fn keyword)
    (catch Exception e
      (binding [*out* *err*]
        (println \"JSON parse error:\" (.getMessage e)))
      nil)))

(defn to-json
  \"Convert a map to JSON string.\"
  [m]
  (json/write-str m))

(defn run-pipeline
  \"Read JSONL from stdin, process, write JSONL to stdout.\"
  []
  (with-open [rdr (io/reader *in*)]
    (doseq [result (->> (line-seq rdr)
                        (filter seq)
                        (keep parse-json-line)
                        (keep process))]
      (println (to-json result)))))

(defn -main
  [& args]
  (run-pipeline))
", [Pred, Arity, Namespace, RequiresStr, ProcessBody]).

%% generate_pipeline_process_clojure(+Clauses, -Code)
generate_pipeline_process_clojure([], "  record").
generate_pipeline_process_clojure(Clauses, Code) :-
    Clauses \= [],
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_clojure(Name, Clauses)
    ->  partition(is_recursive_clause_clojure(Name), Clauses, RecClauses, BaseClauses),
        compile_recursive_clojure(Name, BaseClauses, RecClauses, Code)
    ;   findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_clojure(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', Code)
    ).

%% ============================================
%% RECURSION DETECTION
%% ============================================

is_recursive_predicate_clojure(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_clojure(Body, Name).

is_recursive_clause_clojure(Name, (_, Body)) :-
    contains_recursive_call_clojure(Body, Name).

contains_recursive_call_clojure(Body, Name) :-
    extract_goal_clojure(Body, Goal),
    functor(Goal, Name, _),
    !.

extract_goal_clojure(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_clojure((A, _), Goal) :- extract_goal_clojure(A, Goal).
extract_goal_clojure((_, B), Goal) :- extract_goal_clojure(B, Goal).

%% ============================================
%% TAIL RECURSION (Clojure's loop/recur)
%% ============================================

compile_recursive_clojure(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_clojure(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"  ;; Recursive predicate: ~w - using loop/recur
  (loop [current record
         depth 0]
    (cond
      (> depth 10000)
      (do (binding [*out* *err*]
            (println \"Warning: Max depth for ~w\"))
          current)
      
      ~w
      current
      
      :else
      (recur current (inc depth))))", [Name, Name, BaseCondition]).

generate_base_condition_clojure(Head, Condition) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), "(= (:arg0 current) ~w)", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition), "(= (:arg0 current) \"~w\")", [Arg])
        ;   Condition = "false"
        )
    ;   Condition = "false"
    ).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

translate_clause_clojure(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_clojure(Args, InputCode),
    (   Body == true
    ->  BodyCode = "  ;; Fact - no conditions"
    ;   translate_body_clojure(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n  record", [InputCode, BodyCode]).

generate_input_extraction_clojure(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "  (let [arg~w (:arg~w record)]", [I, I])
        ;   format(string(Line), "  ;; arg~w = ~w (constant)", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% ============================================
%% BODY TRANSLATION
%% ============================================

translate_body_clojure((Goal, Rest), Code) :-
    !,
    translate_goal_clojure(Goal, Code1),
    translate_body_clojure(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_clojure(Goal, Code) :-
    translate_goal_clojure(Goal, Code).

translate_goal_clojure(>(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when-not (> ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(<(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when-not (< ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(>=(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when-not (>= ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(=<(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when-not (<= ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(=:=(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when-not (= ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(=\\=(X, Y), Code) :-
    !, expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
    format(string(Code), "  (when (= ~w ~w) (return nil))", [CX, CY]).

translate_goal_clojure(is(Var, Expr), Code) :-
    !,
    var_to_clojure(Var, ClojureVar),
    expr_to_clojure(Expr, ClojureExpr),
    format(string(Code), "  (let [~w ~w]", [ClojureVar, ClojureExpr]).

translate_goal_clojure(true, "  ;; true") :- !.

translate_goal_clojure(Goal, Code) :-
    format(string(Code), "  ;; TODO: ~w", [Goal]).

%% ============================================
%% HELPER PREDICATES
%% ============================================

var_to_clojure(Var, ClojureVar) :-
    (   var(Var)
    ->  term_to_atom(Var, VarAtom),
        format(atom(ClojureVar), "var-~w", [VarAtom])
    ;   Var = '$VAR'(N)
    ->  format(atom(ClojureVar), "v~w", [N])
    ;   term_to_atom(Var, ClojureVar)
    ).

expr_to_clojure(Expr, ClojureExpr) :-
    (   number(Expr)
    ->  format(atom(ClojureExpr), "~w", [Expr])
    ;   var(Expr)
    ->  var_to_clojure(Expr, ClojureExpr)
    ;   Expr = '$VAR'(N)
    ->  format(atom(ClojureExpr), "v~w", [N])
    ;   Expr = X + Y
    ->  expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
        format(atom(ClojureExpr), "(+ ~w ~w)", [CX, CY])
    ;   Expr = X - Y
    ->  expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
        format(atom(ClojureExpr), "(- ~w ~w)", [CX, CY])
    ;   Expr = X * Y
    ->  expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
        format(atom(ClojureExpr), "(* ~w ~w)", [CX, CY])
    ;   Expr = X / Y
    ->  expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
        format(atom(ClojureExpr), "(/ ~w ~w)", [CX, CY])
    ;   Expr = X mod Y
    ->  expr_to_clojure(X, CX), expr_to_clojure(Y, CY),
        format(atom(ClojureExpr), "(mod ~w ~w)", [CX, CY])
    ;   format(atom(ClojureExpr), "~w", [Expr])
    ).

%% ============================================
%% DEPS.EDN GENERATION
%% ============================================

generate_deps_edn(Options, DepsFile) :-
    option(main_ns(MainNs), Options, 'generated.pipeline'),
    
    format(string(DepsFile),
";; Generated by UnifyWeaver Clojure Target
{:paths [\"src\"]
 :deps {org.clojure/clojure {:mvn/version \"1.11.1\"}
        org.clojure/data.json {:mvn/version \"2.4.0\"}}
 :aliases
 {:run {:main-opts [\"-m\" \"~w\"]}}}
", [MainNs]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

write_clojure_program(ClojureCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, ClojureCode),
    close(Stream),
    format('Written Clojure program to: ~w~n', [FilePath]).

option(Option, Options, _Default) :-
    member(Option, Options), !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

compile_clojure_pipeline(_Steps, _Options, Code) :-
    Code = ";; Multi-step Clojure pipeline - use compile_predicate_to_clojure for now".

%% ============================================
%% TESTS
%% ============================================

test_clojure_pipeline_mode :-
    format('~n=== Testing Clojure Pipeline Mode ===~n~n'),
    
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_clojure(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'run-pipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    format('~nTest 2: Clojure threading macros~n'),
    (   sub_atom(Code1, _, _, _, '->>')
    ->  format('  [PASS] Uses threading macro~n')
    ;   format('  [INFO] No threading macro in this code~n')
    ),
    
    format('~nTest 3: Lisp syntax~n'),
    (   sub_atom(Code1, _, _, _, '(defn')
    ->  format('  [PASS] Uses defn~n')
    ;   format('  [FAIL] Missing defn~n')
    ),
    
    format('~nTest 4: Generator mode~n'),
    compile_predicate_to_clojure(test_gen/2, [generator_mode(true)], Code2),
    (   sub_atom(Code2, _, _, _, 'lazy-seq')
    ->  format('  [PASS] Uses lazy-seq~n')
    ;   (   sub_atom(Code2, _, _, _, 'mapcat')
        ->  format('  [PASS] Uses mapcat~n')
        ;   format('  [FAIL] Missing lazy sequence~n')
        )
    ),
    
    format('~nTest 5: Deps.edn generation~n'),
    generate_deps_edn([main_ns('generated.pipeline')], DepsCode),
    (   sub_atom(DepsCode, _, _, _, ':deps')
    ->  format('  [PASS] Generated deps.edn~n')
    ;   format('  [FAIL] Invalid deps.edn~n')
    ),
    
    format('~n=== Clojure Pipeline Mode Tests Complete ===~n').
