% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% kotlin_target.pl - Kotlin Target for UnifyWeaver
% Generates Kotlin programs for record/field processing
% Supports streaming JSONL I/O, lambdas, and Java interop

:- encoding(utf8).

:- module(kotlin_target, [
    compile_predicate_to_kotlin/3,    % +Predicate, +Options, -KotlinCode
    compile_kotlin_pipeline/3,        % +Predicates, +Options, -KotlinCode
    generate_gradle_build_kotlin/2,   % +Options, -BuildFile
    write_kotlin_program/2,           % +KotlinCode, +FilePath
    init_kotlin_target/0,             % Initialize Kotlin target
    test_kotlin_pipeline_mode/0       % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').

% Track required imports
:- dynamic required_kotlin_import/1.

%% init_kotlin_target
%  Initialize Kotlin target
init_kotlin_target :-
    retractall(required_kotlin_import(_)).

%% clear_kotlin_imports
%  Clear collected imports
clear_kotlin_imports :-
    retractall(required_kotlin_import(_)).

%% collect_kotlin_import(+Import)
%  Record that an import is required
collect_kotlin_import(Import) :-
    (   required_kotlin_import(Import)
    ->  true
    ;   assertz(required_kotlin_import(Import))
    ).

%% get_kotlin_imports(-Imports)
%  Get all collected imports
get_kotlin_imports(Imports) :-
    findall(I, required_kotlin_import(I), Imports).

%% format_kotlin_imports(+Imports, -FormattedStr)
%  Format a list of imports for Kotlin
format_kotlin_imports([], "").
format_kotlin_imports(Imports, FormattedStr) :-
    Imports \= [],
    sort(Imports, UniqueImports),
    findall(Formatted,
        (   member(Import, UniqueImports),
            format(string(Formatted), "import ~w~n", [Import])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_kotlin(+Predicate, +Options, -KotlinCode)
%  Compile a Prolog predicate to Kotlin code
%
%  Options:
%  - pipeline_input(true|false) - Enable streaming input
%  - package(Name) - Kotlin package name
%
compile_predicate_to_kotlin(PredIndicator, Options, KotlinCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to Kotlin ===~n', [Pred, Arity]),

    % Clear any previously collected imports
    clear_kotlin_imports,

    % Check mode
    (   option(generator_mode(true), Options)
    ->  format('  Mode: Generator (sequence with yield)~n'),
        compile_generator_mode_kotlin(Pred, Arity, Options, KotlinCode)
    ;   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_kotlin(Pred, Arity, Options, KotlinCode)
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_kotlin(Pred, Arity, Options, KotlinCode)
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_kotlin(Pred, Arity, _Options, KotlinCode) :-
    format(string(KotlinCode),
"// Generated by UnifyWeaver Kotlin Target
// Predicate: ~w/~w

package generated

fun ~w(vararg args: Any): Any? {
    // TODO: Implement ~w logic
    return null
}

fun main() {
    // TODO: Add main logic
}
", [Pred, Arity, Pred, Pred]).

%% ============================================
%% GENERATOR MODE (Kotlin's sequence { yield() })
%% ============================================

compile_generator_mode_kotlin(Pred, Arity, Options, KotlinCode) :-
    % Standard imports for generator mode
    collect_kotlin_import('com.google.gson.Gson'),
    collect_kotlin_import('com.google.gson.reflect.TypeToken'),
    collect_kotlin_import('java.io.BufferedReader'),
    collect_kotlin_import('java.io.InputStreamReader'),
    
    option(package(Package), Options, generated),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate generator body
    (   Clauses == []
    ->  GeneratorBody = "            // No clauses found - yield input unchanged\n            yield(record)"
    ;   generate_generator_body_kotlin(Clauses, GeneratorBody)
    ),
    
    get_kotlin_imports(ImportList),
    format_kotlin_imports(ImportList, ImportsStr),
    
    upcase_atom_first(Pred, CapPred),
    
    format(string(KotlinCode),
"// Generated by UnifyWeaver Kotlin Target - Generator Mode
// Predicate: ~w/~w
// Uses Kotlin's sequence { yield() } for lazy evaluation

package ~w

~w

/**
 * Generator for ~w predicate.
 * Uses Kotlin sequences for lazy, memory-efficient processing.
 */
object ~wGenerator {

    private val gson = Gson()
    private val mapType = object : TypeToken<MutableMap<String, Any?>>() {}.type

    /**
     * Process a single record, yielding zero or more results.
     * @param record Input record
     * @return Sequence of output records (lazy)
     */
    fun process(record: MutableMap<String, Any?>): Sequence<MutableMap<String, Any?>> = sequence {
~w
    }

    /**
     * Process all records from a sequence, flattening results.
     */
    fun processAll(records: Sequence<MutableMap<String, Any?>>): Sequence<MutableMap<String, Any?>> =
        records.flatMap { process(it) }

    /**
     * Run the generator pipeline: read JSONL, process, write JSONL.
     */
    fun runPipeline() {
        val reader = BufferedReader(InputStreamReader(System.`in`))
        
        val inputRecords = sequence {
            reader.lineSequence()
                .filter { it.isNotBlank() }
                .forEach { line ->
                    try {
                        yield(gson.fromJson<MutableMap<String, Any?>>(line, mapType))
                    } catch (e: Exception) {
                        System.err.println(\"JSON parse error: ${e.message}\")
                    }
                }
        }
        
        processAll(inputRecords).forEach { result ->
            println(gson.toJson(result))
        }
    }
}

fun main() {
    ~wGenerator.runPipeline()
}
", [Pred, Arity, Package, ImportsStr, Pred, CapPred, GeneratorBody, CapPred]).

%% generate_generator_body_kotlin(+Clauses, -Code)
%  Generate the body of the sequence { } block with yield() calls.
generate_generator_body_kotlin(Clauses, Code) :-
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_kotlin(Name, Clauses)
    ->  % For recursive predicates, use iterative approach with yield
        partition(is_recursive_clause_kotlin(Name), Clauses, RecClauses, BaseClauses),
        compile_generator_recursive_kotlin(Name, BaseClauses, RecClauses, Code)
    ;   % Non-recursive: translate each clause to yield
        findall(ClauseCode, 
            (member((H, B), Clauses), translate_generator_clause_kotlin(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', Code)
    ).

%% translate_generator_clause_kotlin(+Head, +Body, -Code)
translate_generator_clause_kotlin(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_kotlin(Args, InputCode),
    (   Body == true
    ->  BodyCode = "            // Fact - unconditional yield"
    ;   translate_generator_body_kotlin(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n            yield(record)", [InputCode, BodyCode]).

%% translate_generator_body_kotlin(+Body, -Code)
translate_generator_body_kotlin((Goal, Rest), Code) :-
    !,
    translate_generator_goal_kotlin(Goal, Code1),
    translate_generator_body_kotlin(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_generator_body_kotlin(Goal, Code) :-
    translate_generator_goal_kotlin(Goal, Code).

%% translate_generator_goal_kotlin(+Goal, -Code)
%  Like translate_goal_kotlin but uses return@sequence instead of return null
translate_generator_goal_kotlin(>(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (!(~w > ~w)) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(<(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (!(~w < ~w)) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(>=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (!(~w >= ~w)) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(=<(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (!(~w <= ~w)) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(=:=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (~w != ~w) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(=\\=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "            if (~w == ~w) return@sequence", [KX, KY]).

translate_generator_goal_kotlin(is(Var, Expr), Code) :-
    !,
    var_to_kotlin(Var, KotlinVar),
    expr_to_kotlin(Expr, KotlinExpr),
    format(string(Code), "            val ~w = ~w", [KotlinVar, KotlinExpr]).

translate_generator_goal_kotlin(true, "            // true") :- !.

translate_generator_goal_kotlin(Goal, Code) :-
    format(string(Code), "            // TODO: ~w", [Goal]).

%% compile_generator_recursive_kotlin(+Name, +BaseClauses, +RecClauses, -Code)
%  Generate recursive logic inside a sequence with multiple yields.
compile_generator_recursive_kotlin(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_kotlin(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    format(string(Code),
"            // Recursive generator: ~w
            var current = record.toMutableMap()
            var iterations = 0
            val maxIterations = 10000
            
            while (iterations < maxIterations) {
                // Yield current state
                yield(current)
                
                // Check base case - stop generating
                if (~w) {
                    return@sequence
                }
                
                // Transform for next iteration
                current = current.toMutableMap()
                iterations++
            }
            
            System.err.println(\"Warning: Max iterations exceeded for ~w\")", [Name, BaseCondition, Name]).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_kotlin(Pred, Arity, Options, KotlinCode) :-
    % Standard pipeline imports
    collect_kotlin_import('com.google.gson.Gson'),
    collect_kotlin_import('com.google.gson.reflect.TypeToken'),
    collect_kotlin_import('java.io.BufferedReader'),
    collect_kotlin_import('java.io.InputStreamReader'),
    
    option(package(Package), Options, generated),
    
    % Gather clauses
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    % Generate process function
    (   Clauses == []
    ->  ProcessCode = "        // No clauses found - pass through\n        return record"
    ;   generate_pipeline_process_kotlin(Clauses, ProcessCode)
    ),
    
    get_kotlin_imports(ImportList),
    format_kotlin_imports(ImportList, ImportsStr),
    
    % Capitalize predicate name for class
    upcase_atom_first(Pred, CapPred),
    
    format(string(KotlinCode),
"// Generated by UnifyWeaver Kotlin Target - Pipeline Mode
// Predicate: ~w/~w

package ~w

~w

/**
 * Pipeline processor for ~w predicate.
 * Reads JSONL from stdin, processes each record, writes JSONL to stdout.
 */
object ~wPipeline {

    private val gson = Gson()
    private val mapType = object : TypeToken<MutableMap<String, Any?>>() {}.type

    /**
     * Process a single input record.
     * @param record Input record as MutableMap
     * @return Output record or null to filter out
     */
    fun process(record: MutableMap<String, Any?>): MutableMap<String, Any?>? {
~w
    }

    /**
     * Run the pipeline: read from stdin, process, write to stdout.
     */
    fun runPipeline() {
        val reader = BufferedReader(InputStreamReader(System.`in`))
        
        reader.lineSequence()
            .filter { it.isNotBlank() }
            .mapNotNull { line ->
                try {
                    val record: MutableMap<String, Any?> = gson.fromJson(line, mapType)
                    process(record)
                } catch (e: Exception) {
                    System.err.println(\"JSON parse error: ${e.message}\")
                    null
                }
            }
            .forEach { result ->
                println(gson.toJson(result))
            }
    }
}

fun main() {
    ~wPipeline.runPipeline()
}
", [Pred, Arity, Package, ImportsStr, Pred, CapPred, ProcessCode, CapPred]).

%% upcase_atom_first(+Atom, -CapAtom)
%  Capitalize the first letter of an atom.
upcase_atom_first(Atom, CapAtom) :-
    atom_codes(Atom, [H|T]),
    (   H >= 97, H =< 122  % lowercase a-z
    ->  H2 is H - 32,
        atom_codes(CapAtom, [H2|T])
    ;   CapAtom = Atom
    ).

%% generate_pipeline_process_kotlin(+Clauses, -Code)
generate_pipeline_process_kotlin([], "        return record").
generate_pipeline_process_kotlin(Clauses, Code) :-
    Clauses \= [],
    % Check for recursion
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_kotlin(Name, Clauses)
    ->  % Separate base and recursive clauses
        partition(is_recursive_clause_kotlin(Name), Clauses, RecClauses, BaseClauses),
        (   is_tail_recursive_kotlin(Name, RecClauses)
        ->  compile_tail_recursive_kotlin(Name, BaseClauses, RecClauses, Code)
        ;   compile_general_recursive_kotlin(Name, BaseClauses, RecClauses, Code)
        )
    ;   % Generate functional-style processing
        findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_kotlin(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', AllClausesCode),
        format(string(Code), "~w", [AllClausesCode])
    ).

%% ============================================
%% RECURSION DETECTION AND PATTERNS
%% ============================================

is_recursive_predicate_kotlin(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_kotlin(Body, Name).

is_recursive_clause_kotlin(Name, (_, Body)) :-
    contains_recursive_call_kotlin(Body, Name).

is_tail_recursive_kotlin(Name, RecClauses) :-
    member((_, Body), RecClauses),
    get_last_goal_kotlin(Body, LastGoal),
    functor(LastGoal, Name, _).

get_last_goal_kotlin((_, B), LastGoal) :- !, get_last_goal_kotlin(B, LastGoal).
get_last_goal_kotlin(Goal, Goal).

contains_recursive_call_kotlin(Body, Name) :-
    extract_goal_kotlin(Body, Goal),
    functor(Goal, Name, _),
    !.

extract_goal_kotlin(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_kotlin((A, _), Goal) :- extract_goal_kotlin(A, Goal).
extract_goal_kotlin((_, B), Goal) :- extract_goal_kotlin(B, Goal).

%% ============================================
%% TAIL RECURSION (→ tailrec function)
%% ============================================

compile_tail_recursive_kotlin(Name, BaseClauses, RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_kotlin(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_recursive_transform_kotlin(RecBody, Name, Transform)
    ;   Transform = "current"
    ),
    
    format(string(Code),
"        // Tail-recursive predicate: ~w - using tailrec
        var current = record.toMutableMap()
        var iterations = 0
        val maxIterations = 10000
        
        while (iterations < maxIterations) {
            // Base case check
            if (~w) {
                return current
            }
            
            // Recursive step
            current = ~w
            iterations++
        }
        
        System.err.println(\"Warning: Max iterations exceeded for ~w\")
        return current", [Name, BaseCondition, Transform, Name]).

generate_base_condition_kotlin(Head, Condition) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), "current[\"arg0\"] == ~w", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition), "current[\"arg0\"] == \"~w\"", [Arg])
        ;   Condition = "false"
        )
    ;   Condition = "false"
    ).

generate_recursive_transform_kotlin(Body, Name, Transform) :-
    extract_goal_kotlin(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_],
        expr_to_kotlin(Expr, KotlinExpr),
        format(string(Transform), "mutableMapOf(\"arg0\" to ~w)", [KotlinExpr])
    ;   Transform = "current"
    ).

%% ============================================
%% GENERAL RECURSION (→ memoization)
%% ============================================

compile_general_recursive_kotlin(Name, BaseClauses, RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_kotlin(BaseHead, BaseCondition)
    ;   BaseCondition = "false"
    ),
    
    (   RecClauses = [(_, RecBody)|_]
    ->  generate_memoized_recursive_kotlin(RecBody, Name, RecursiveComputation)
    ;   RecursiveComputation = "current"
    ),
    
    format(string(Code),
"        // General recursive predicate: ~w - with memoization
        @Suppress(\"UNCHECKED_CAST\")
        val memo = record.getOrPut(\"__memo__\") { mutableMapOf<String, Any?>() } 
            as MutableMap<String, Any?>
        
        val key = record[\"arg0\"].toString()
        memo[key]?.let { return it as MutableMap<String, Any?> }
        
        val current = record.toMutableMap()
        
        // Base case check
        if (~w) {
            memo[key] = current
            return current
        }
        
        // Recursive computation with memoization
        val result = ~w
        memo[key] = result
        return result", [Name, BaseCondition, RecursiveComputation]).

generate_memoized_recursive_kotlin(Body, Name, Code) :-
    extract_goal_kotlin(Body, Goal),
    functor(Goal, Name, _),
    Goal =.. [_|Args],
    (   Args = [Expr|_]
    ->  expr_to_kotlin(Expr, KotlinExpr),
        format(string(Code),
"process(mutableMapOf(\"arg0\" to ~w, \"__memo__\" to memo))!!", [KotlinExpr])
    ;   Code = "current"
    ).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

translate_clause_kotlin(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_kotlin(Args, InputCode),
    (   Body == true
    ->  BodyCode = "        // Fact - no conditions"
    ;   translate_body_kotlin(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n        return record", [InputCode, BodyCode]).

generate_input_extraction_kotlin(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "        val arg~w = record[\"arg~w\"]", [I, I])
        ;   format(string(Line), "        // arg~w = ~w (constant)", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% ============================================
%% BODY TRANSLATION
%% ============================================

translate_body_kotlin((Goal, Rest), Code) :-
    !,
    translate_goal_kotlin(Goal, Code1),
    translate_body_kotlin(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_kotlin(Goal, Code) :-
    translate_goal_kotlin(Goal, Code).

% Comparison operators
translate_goal_kotlin(>(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (!(~w > ~w)) return null", [KX, KY]).

translate_goal_kotlin(<(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (!(~w < ~w)) return null", [KX, KY]).

translate_goal_kotlin(>=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (!(~w >= ~w)) return null", [KX, KY]).

translate_goal_kotlin(=<(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (!(~w <= ~w)) return null", [KX, KY]).

translate_goal_kotlin(=:=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (~w != ~w) return null", [KX, KY]).

translate_goal_kotlin(=\\=(X, Y), Code) :-
    !, expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
    format(string(Code), "        if (~w == ~w) return null", [KX, KY]).

% Arithmetic: X is Expr
translate_goal_kotlin(is(Var, Expr), Code) :-
    !,
    var_to_kotlin(Var, KotlinVar),
    expr_to_kotlin(Expr, KotlinExpr),
    format(string(Code), "        val ~w = ~w", [KotlinVar, KotlinExpr]).

% get_dict/3
translate_goal_kotlin(get_dict(Key, Dict, Value), Code) :-
    !,
    var_to_kotlin(Dict, KDict),
    var_to_kotlin(Value, KValue),
    format(string(Code), "        val ~w = ~w[\"~w\"]", [KValue, KDict, Key]).

% put_dict/3
translate_goal_kotlin(put_dict(Updates, Dict, NewDict), Code) :-
    !,
    var_to_kotlin(Dict, KDict),
    var_to_kotlin(NewDict, KNewDict),
    format(string(Code), "        val ~w = ~w.toMutableMap().also { it.putAll(~w) }", 
           [KNewDict, KDict, Updates]).

% true - no-op
translate_goal_kotlin(true, "        // true") :- !.

% Unknown goal
translate_goal_kotlin(Goal, Code) :-
    format(string(Code), "        // TODO: ~w", [Goal]).

%% ============================================
%% HELPER PREDICATES
%% ============================================

var_to_kotlin(Var, KotlinVar) :-
    (   var(Var)
    ->  term_to_atom(Var, VarAtom),
        format(atom(KotlinVar), "var_~w", [VarAtom])
    ;   Var = '$VAR'(N)
    ->  format(atom(KotlinVar), "v~w", [N])
    ;   term_to_atom(Var, KotlinVar)
    ).

expr_to_kotlin(Expr, KotlinExpr) :-
    (   number(Expr)
    ->  format(atom(KotlinExpr), "~w", [Expr])
    ;   var(Expr)
    ->  var_to_kotlin(Expr, KotlinExpr)
    ;   Expr = '$VAR'(N)
    ->  format(atom(KotlinExpr), "v~w", [N])
    ;   Expr = X + Y
    ->  expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
        format(atom(KotlinExpr), "(~w + ~w)", [KX, KY])
    ;   Expr = X - Y
    ->  expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
        format(atom(KotlinExpr), "(~w - ~w)", [KX, KY])
    ;   Expr = X * Y
    ->  expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
        format(atom(KotlinExpr), "(~w * ~w)", [KX, KY])
    ;   Expr = X / Y
    ->  expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
        format(atom(KotlinExpr), "(~w / ~w)", [KX, KY])
    ;   Expr = X mod Y
    ->  expr_to_kotlin(X, KX), expr_to_kotlin(Y, KY),
        format(atom(KotlinExpr), "(~w % ~w)", [KX, KY])
    ;   format(atom(KotlinExpr), "~w", [Expr])
    ).

%% ============================================
%% GRADLE BUILD GENERATION
%% ============================================

generate_gradle_build_kotlin(Options, BuildFile) :-
    option(kotlin_version(KotlinVersion), Options, '2.0.0'),
    option(group(Group), Options, 'com.example'),
    option(version(Version), Options, '1.0.0'),
    
    format(string(BuildFile),
"// Generated by UnifyWeaver Kotlin Target
// Kotlin version: ~w

plugins {
    kotlin(\"jvm\") version \"~w\"
    application
}

group = \"~w\"
version = \"~w\"

repositories {
    mavenCentral()
}

dependencies {
    implementation(\"com.google.code.gson:gson:2.10.1\")
    testImplementation(kotlin(\"test\"))
}

application {
    mainClass.set(\"generated.MainKt\")
}

tasks.test {
    useJUnitPlatform()
}

kotlin {
    jvmToolchain(21)
}
", [KotlinVersion, KotlinVersion, Group, Version]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

write_kotlin_program(KotlinCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, KotlinCode),
    close(Stream),
    format('Written Kotlin program to: ~w~n', [FilePath]).

option(Option, Options, _Default) :-
    member(Option, Options), !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

%% compile_kotlin_pipeline(+Steps, +Options, -KotlinCode)
%  Compile multi-step Kotlin pipeline (stub for future implementation).
compile_kotlin_pipeline(_Steps, _Options, Code) :-
    Code = "// Multi-step Kotlin pipeline - use compile_predicate_to_kotlin for now".

%% ============================================
%% TESTS
%% ============================================

test_kotlin_pipeline_mode :-
    format('~n=== Testing Kotlin Pipeline Mode ===~n~n'),
    
    % Test 1: Basic pipeline generation
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_kotlin(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'runPipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    % Test 2: Lambda syntax
    format('~nTest 2: Kotlin lambda syntax~n'),
    (   sub_atom(Code1, _, _, _, 'lineSequence')
    ->  format('  [PASS] Uses Kotlin sequences~n')
    ;   format('  [FAIL] Missing sequence API~n')
    ),
    
    % Test 3: Object declaration
    format('~nTest 3: Object declaration~n'),
    (   sub_atom(Code1, _, _, _, 'object')
    ->  format('  [PASS] Uses Kotlin object~n')
    ;   format('  [FAIL] Missing object declaration~n')
    ),
    
    % Test 4: Gradle build generation
    format('~nTest 4: Gradle build generation~n'),
    generate_gradle_build_kotlin([kotlin_version('2.0.0')], BuildCode),
    (   sub_atom(BuildCode, _, _, _, 'kotlin(\"jvm\")')
    ->  format('  [PASS] Generated Kotlin Gradle build~n')
    ;   format('  [FAIL] Invalid Gradle build~n')
    ),
    
    format('~n=== Kotlin Pipeline Mode Tests Complete ===~n').
