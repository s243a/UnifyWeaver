:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% prolog_target.pl - Prolog as Compilation Target
% Transpiles user Prolog code to standalone executable Prolog scripts
%
% Philosophy:
% - This is a GENERAL transpilation target, not partitioning-specific
% - User writes Prolog predicates â†’ UnifyWeaver generates executable .pl script
% - Generated script includes runtime dependencies (partitioner, data sources, etc.)
% - Script is standalone: #!/usr/bin/env swipl with initialization
%
% Use Cases:
% - Partitioning/parallel execution (leverages Prolog's data structure strengths)
% - Data transformation pipelines (complex logic hard to express in bash)
% - Prolog predicates that need runtime library support
% - Quick prototyping (faster than bash transpilation)

:- module(prolog_target, [
    generate_prolog_script/3,     % +UserPredicates, +Options, -ScriptCode
    analyze_dependencies/2,       % +UserPredicates, -RequiredModules
    write_prolog_script/2         % +ScriptCode, +OutputPath
]).

:- use_module(library(lists)).
:- use_module(library(apply)).

%% ============================================
%% MAIN ENTRY POINT
%% ============================================

%% generate_prolog_script(+UserPredicates, +Options, -ScriptCode)
%  Generate complete Prolog script from user predicates
%
%  @arg UserPredicates List of predicate indicators (Pred/Arity)
%  @arg Options Compilation options:
%       - entry_point(Goal) - Main goal to execute (default: main)
%       - inline_runtime(true/false) - Inline runtime library vs reference
%       - arguments(ArgSpec) - Command-line argument parsing
%       - output_mode(Mode) - stdout, file, return
%  @arg ScriptCode Generated script as atom
%
%  @example Generate script for user predicates
%    ?- generate_prolog_script([process_data/2, helper/1], [], Code).
generate_prolog_script(UserPredicates, Options, ScriptCode) :-
    % 1. Analyze what user code needs
    analyze_dependencies(UserPredicates, Dependencies),

    % 2. Generate script components
    generate_shebang(ShebangCode),
    generate_header(UserPredicates, Options, HeaderCode),
    generate_module_imports(Dependencies, Options, ImportsCode),
    generate_user_code(UserPredicates, Options, UserCode),
    generate_entry_point(Options, EntryCode),

    % 3. Assemble complete script
    atomic_list_concat([
        ShebangCode,
        HeaderCode,
        ImportsCode,
        UserCode,
        EntryCode
    ], '\n\n', ScriptCode).

%% ============================================
%% SCRIPT COMPONENT GENERATION
%% ============================================

%% generate_shebang(-Code)
%  Generate shebang line for executable script
generate_shebang('#!/usr/bin/env swipl').

%% generate_header(+UserPredicates, +Options, -Code)
%  Generate script header with metadata
generate_header(UserPredicates, Options, Code) :-
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),

    % Extract source file if provided
    (   member(source_file(SourceFile), Options)
    ->  format(atom(SourceComment), '% Source: ~w', [SourceFile])
    ;   SourceComment = ''
    ),

    % Format predicate list
    length(UserPredicates, NumPreds),
    format(atom(PredsStr), '~w', [UserPredicates]),

    % Build lines
    format(atom(DateLine), '% Generated: ~w', [DateStr]),
    format(atom(NumPredsLine), '% Predicates transpiled: ~w', [NumPreds]),
    format(atom(PredsLine), '% ~w', [PredsStr]),

    % Combine
    (   SourceComment = ''
    ->  Lines = ['% Generated by UnifyWeaver v0.0.3',
                 '% Target: Prolog',
                 DateLine,
                 NumPredsLine,
                 PredsLine]
    ;   Lines = ['% Generated by UnifyWeaver v0.0.3',
                 '% Target: Prolog',
                 DateLine,
                 SourceComment,
                 NumPredsLine,
                 PredsLine]
    ),
    atomic_list_concat(Lines, '\n', Code).

%% generate_module_imports(+Dependencies, +Options, -Code)
%  Generate module import statements
%
%  @arg Dependencies List of required modules/features
%  @arg Options Compilation options (inline_runtime, etc.)
%  @arg Code Generated import code
generate_module_imports(Dependencies, Options, Code) :-
    % Check if runtime should be inlined or referenced
    (   member(inline_runtime(true), Options)
    ->  % Will inline later, no imports needed
        Code = '% Runtime library inlined below'
    ;   % Reference runtime library via imports
        generate_import_statements(Dependencies, ImportStatements),
        atomic_list_concat(ImportStatements, '\n', Code)
    ).

%% generate_import_statements(+Dependencies, -Statements)
%  Convert dependency list to import statements
generate_import_statements(Dependencies, Statements) :-
    % Add search path setup - use multifile to make it work before module loads
    SearchPathSetup = [
        '% Set up UnifyWeaver runtime library search path',
        ':- multifile user:file_search_path/2.',
        ':- dynamic user:file_search_path/2.',
        '',
        '% Check for UNIFYWEAVER_HOME environment variable',
        'setup_unifyweaver_path :- getenv(\'UNIFYWEAVER_HOME\', Home), !, asserta(user:file_search_path(unifyweaver, Home)).',
        'setup_unifyweaver_path.  % Assume installed as pack if UNIFYWEAVER_HOME not set',
        '',
        ':- setup_unifyweaver_path.'
    ],

    % Convert dependencies to use_module statements
    findall(Import, (
        member(Dep, Dependencies),
        dependency_to_import(Dep, Import)
    ), Imports),

    % Combine
    append(SearchPathSetup, [''] , HeaderWithSpace),
    append(HeaderWithSpace, Imports, Statements).

%% dependency_to_import(+Dependency, -ImportStatement)
%  Convert dependency term to use_module statement
dependency_to_import(module(ModulePath), Import) :-
    format(atom(Import), ':- use_module(~w).', [ModulePath]).

dependency_to_import(ensure_loaded(ModulePath), Import) :-
    format(atom(Import), ':- ensure_loaded(~w).', [ModulePath]).

dependency_to_import(plugin_registration(Type, Name, Module), Import) :-
    format(atom(Import), ':- register_~w(~w, ~w).', [Type, Name, Module]).

%% generate_user_code(+UserPredicates, +Options, -Code)
%  Generate user's predicates (copied or templated)
%
%  Strategy:
%  - Simple predicates: Copy verbatim using clause/2
%  - Complex predicates with config: Use templates
%  - Detect which strategy per predicate
generate_user_code(UserPredicates, Options, Code) :-
    format(atom(Header), '% === User Code (Transpiled) ===~n', []),

    findall(PredCode, (
        member(Pred/Arity, UserPredicates),
        generate_predicate_code(Pred/Arity, Options, PredCode)
    ), PredCodes),

    atomic_list_concat([Header|PredCodes], '\n\n', Code).

%% generate_predicate_code(+Pred/Arity, +Options, -Code)
%  Generate code for a single predicate
generate_predicate_code(Pred/Arity, _Options, Code) :-
    % For now, use verbatim copying
    % TODO: Add template-based generation for configured predicates
    copy_predicate_clauses(Pred/Arity, Code).

%% copy_predicate_clauses(+Pred/Arity, -Code)
%  Copy predicate clauses verbatim using introspection
copy_predicate_clauses(Pred/Arity, Code) :-
    functor(Head, Pred, Arity),

    % Find all clauses
    findall(ClauseStr, (
        clause(Head, Body),
        clause_to_string((Head :- Body), ClauseStr)
    ), ClauseStrs),

    (   ClauseStrs = []
    ->  % No clauses found - might be undefined or built-in
        format(atom(Code), '% ~w/~w - Not found or built-in~n', [Pred, Arity])
    ;   atomic_list_concat(ClauseStrs, '\n', Code)
    ).

%% clause_to_string(+Clause, -String)
%  Convert clause term to string representation
clause_to_string(Clause, String) :-
    % Use with_output_to to capture portray_clause output
    with_output_to(atom(String),
        portray_clause(Clause)
    ).

%% generate_entry_point(+Options, -Code)
%  Generate main entry point and initialization
generate_entry_point(Options, Code) :-
    % Determine entry point goal
    (   member(entry_point(EntryGoal), Options)
    ->  format(atom(EntryGoalStr), '~w', [EntryGoal])
    ;   EntryGoalStr = 'main'
    ),

    % Determine argument handling
    (   member(arguments(ArgSpec), Options)
    ->  generate_argument_parsing(ArgSpec, ArgParseCode)
    ;   ArgParseCode = '    % No argument parsing'
    ),

    % Build entry goal line
    atom_concat('    ', EntryGoalStr, EntryGoalIndented),
    atom_concat(EntryGoalIndented, ',', EntryGoalLine),

    % Build lines
    atomic_list_concat([
        '% === Entry Point ===',
        'main :-',
        ArgParseCode,
        EntryGoalLine,
        '    halt(0).',
        '',
        'main :-',
        '    % If main goal fails, exit with error',
        '    format(user_error, \'Error: Execution failed~n\', []),',
        '    halt(1).',
        '',
        ':- initialization(main, main).'
    ], '\n', Code).

%% generate_argument_parsing(+ArgSpec, -Code)
%  Generate code to parse command-line arguments
generate_argument_parsing(args(VarList), Code) :-
    % VarList = [file, option1, option2, ...]
    length(VarList, NumArgs),
    format(atom(Code),
           'current_prolog_flag(argv, Argv),~n~
                (   length(Argv, ~w)~n~
                ->  Argv = ~w~n~
                ;   format(user_error, \'Usage: ~w~n\', []),~n~
                    halt(1)~n~
                )',
           [NumArgs, VarList, VarList]).

generate_argument_parsing(optional_args(VarList, Defaults), Code) :-
    % With defaults for optional arguments
    format(atom(Code),
           'current_prolog_flag(argv, Argv),~n~
                parse_arguments(Argv, ~w, ~w)',
           [VarList, Defaults]).

%% ============================================
%% DEPENDENCY ANALYSIS
%% ============================================

%% analyze_dependencies(+UserPredicates, -Dependencies)
%  Analyze user code to determine runtime dependencies
%
%  @arg UserPredicates List of Pred/Arity
%  @arg Dependencies List of dependency terms:
%       - module(ModulePath) - Module to import
%       - ensure_loaded(Path) - File to ensure_loaded
%       - plugin_registration(Type, Name, Module) - Plugin to register
%
%  @example Detect partitioner usage
%    ?- analyze_dependencies([process/2], Deps).
%    Deps = [module(unifyweaver(core/partitioner)), ...].
analyze_dependencies(UserPredicates, Dependencies) :-
    % Analyze each predicate's body for feature usage
    findall(Dep, (
        member(Pred/Arity, UserPredicates),
        functor(Head, Pred, Arity),
        clause(Head, Body),
        extract_dependencies_from_body(Body, Dep)
    ), AllDeps),

    % Remove duplicates
    sort(AllDeps, Dependencies).

%% extract_dependencies_from_body(+Body, -Dependency)
%  Extract dependencies from clause body
extract_dependencies_from_body(Body, Dependency) :-
    % Check for known patterns
    contains_goal(Body, Goal),
    goal_requires_dependency(Goal, Dependency).

%% contains_goal(+Body, -Goal)
%  Recursively extract goals from clause body
contains_goal(Goal, Goal) :-
    callable(Goal).

contains_goal((A, B), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ).

contains_goal((A ; B), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ).

contains_goal((A -> B ; C), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ;   contains_goal(C, Goal)
    ).

%% goal_requires_dependency(+Goal, -Dependency)
%  Map goal patterns to required dependencies
%
%  This is where we detect feature usage and map to runtime modules

% Partitioning features
goal_requires_dependency(partitioner_init(_, _, _), module(unifyweaver(core/partitioner))).
goal_requires_dependency(partitioner_partition(_, _, _), module(unifyweaver(core/partitioner))).
goal_requires_dependency(partition_data(_, _, _), module(unifyweaver(core/partitioner))).

% Parallel backend features
goal_requires_dependency(backend_init(_, _), module(unifyweaver(core/parallel_backend))).
goal_requires_dependency(backend_execute(_, _, _, _), module(unifyweaver(core/parallel_backend))).
goal_requires_dependency(parallel_map(_, _, _), module(unifyweaver(core/parallel_backend))).

% Data source features
goal_requires_dependency(read_csv(_, _), module(unifyweaver(sources/csv))).
goal_requires_dependency(read_json(_, _), module(unifyweaver(sources/json))).
goal_requires_dependency(http_get(_, _), module(unifyweaver(sources/http))).

% Detect strategy/backend registration needs
goal_requires_dependency(partitioner_init(Strategy, _, _), StrategyDep) :-
    Strategy =.. [StrategyName|_],
    strategy_requires_module(StrategyName, StrategyDep).

goal_requires_dependency(backend_init(Backend, _), BackendDep) :-
    Backend =.. [BackendName|_],
    backend_requires_module(BackendName, BackendDep).

%% strategy_requires_module(+StrategyName, -Dependency)
%  Map strategy name to required module
strategy_requires_module(fixed_size, ensure_loaded(unifyweaver(core/partitioners/fixed_size))).
strategy_requires_module(fixed_size, plugin_registration(partitioner, fixed_size, fixed_size_partitioner)).

strategy_requires_module(hash_based, ensure_loaded(unifyweaver(core/partitioners/hash_based))).
strategy_requires_module(hash_based, plugin_registration(partitioner, hash_based, hash_based_partitioner)).

strategy_requires_module(key_based, ensure_loaded(unifyweaver(core/partitioners/key_based))).
strategy_requires_module(key_based, plugin_registration(partitioner, key_based, key_based_partitioner)).

%% backend_requires_module(+BackendName, -Dependency)
%  Map backend name to required module
backend_requires_module(gnu_parallel, ensure_loaded(unifyweaver(core/backends/gnu_parallel))).
backend_requires_module(gnu_parallel, plugin_registration(backend, gnu_parallel, gnu_parallel_backend)).

%% ============================================
%% OUTPUT GENERATION
%% ============================================

%% write_prolog_script(+ScriptCode, +OutputPath)
%  Write generated script to file and make executable
write_prolog_script(ScriptCode, OutputPath) :-
    % Write script
    open(OutputPath, write, Stream, [encoding(utf8)]),
    write(Stream, ScriptCode),
    nl(Stream),
    close(Stream),

    % Make executable (chmod +x)
    format(atom(ChmodCmd), 'chmod +x ~w', [OutputPath]),
    shell(ChmodCmd),

    format('[PrologTarget] Generated executable script: ~w~n', [OutputPath]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

%% is_user_predicate(+Pred/Arity)
%  Check if predicate is user-defined (not built-in or library)
is_user_predicate(Pred/Arity) :-
    functor(Head, Pred, Arity),
    % Has at least one clause
    clause(Head, _),
    % Not from system modules
    \+ predicate_property(Head, built_in),
    \+ predicate_property(Head, imported_from(_)).
