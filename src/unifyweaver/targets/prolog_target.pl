:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% prolog_target.pl - Prolog as Compilation Target
% Transpiles user Prolog code to standalone executable Prolog scripts
%
% Philosophy:
% - This is a GENERAL transpilation target, not partitioning-specific
% - User writes Prolog predicates â†’ UnifyWeaver generates executable .pl script
% - Generated script includes runtime dependencies (partitioner, data sources, etc.)
% - Script is standalone: #!/usr/bin/env swipl with initialization
%
% Use Cases:
% - Partitioning/parallel execution (leverages Prolog's data structure strengths)
% - Data transformation pipelines (complex logic hard to express in bash)
% - Prolog predicates that need runtime library support
% - Quick prototyping (faster than bash transpilation)

:- module(prolog_target, [
    generate_prolog_script/3,     % +UserPredicates, +Options, -ScriptCode
    analyze_dependencies/2,       % +UserPredicates, -RequiredModules
    write_prolog_script/2,        % +ScriptCode, +OutputPath
    write_prolog_script/3         % +ScriptCode, +OutputPath, +Options
]).

:- use_module(library(lists)).
:- use_module(library(apply)).
:- use_module(library(option)).
:- use_module(prolog_dialects).
:- use_module(prolog_constraints).

%% ============================================
%% MAIN ENTRY POINT
%% ============================================

%% generate_prolog_script(+UserPredicates, +Options, -ScriptCode)
%  Generate complete Prolog script from user predicates
%
%  @arg UserPredicates List of predicate indicators (Pred/Arity)
%  @arg Options Compilation options:
%       - dialect(Dialect) - Target Prolog dialect (swi, gnu) default: swi
%       - entry_point(Goal) - Main goal to execute (default: main)
%       - inline_runtime(true/false) - Inline runtime library vs reference
%       - arguments(ArgSpec) - Command-line argument parsing
%       - output_mode(Mode) - stdout, file, return
%       - compile(true/false) - Generate compilation command for dialect
%  @arg ScriptCode Generated script as atom
%
%  @example Generate script for user predicates
%    ?- generate_prolog_script([process_data/2, helper/1], [dialect(gnu)], Code).
generate_prolog_script(UserPredicates, Options, ScriptCode) :-
    % 0. Determine target dialect
    option(dialect(Dialect), Options, swi),

    % Validate dialect support
    (   supported_dialect(Dialect)
    ->  true
    ;   format(atom(Error), 'Unsupported dialect: ~w', [Dialect]),
        throw(error(unsupported_dialect(Dialect), Error))
    ),

    % Validate predicates for dialect
    validate_for_dialect(Dialect, UserPredicates, Issues),
    (   Issues = []
    ->  true
    ;   format('[Warning] Compatibility issues for ~w: ~w~n', [Dialect, Issues])
    ),

    % 1. Analyze what user code needs
    analyze_dependencies(UserPredicates, Dependencies),

    % 2. Generate dialect-specific script components
    dialect_shebang(Dialect, ShebangCode),

    EnhancedOptions = [predicates(UserPredicates)|Options],
    dialect_header(Dialect, EnhancedOptions, HeaderCode),

    dialect_imports(Dialect, Dependencies, ImportsCode),

    generate_user_code(UserPredicates, Options, UserCode),

    option(entry_point(EntryGoal), Options, main),
    dialect_initialization(Dialect, EntryGoal, Options, InitCode),

    generate_main_predicate(Options, MainCode),

    % 3. Assemble complete script
    atomic_list_concat([
        ShebangCode,
        HeaderCode,
        ImportsCode,
        UserCode,
        '\n% === Entry Point ===',
        MainCode,
        InitCode
    ], '\n\n', ScriptCode).

%% ============================================
%% SCRIPT COMPONENT GENERATION
%% ============================================

%% generate_shebang(-Code)
%  Generate shebang line for executable script
generate_shebang('#!/usr/bin/env swipl').

%% generate_header(+UserPredicates, +Options, -Code)
%  Generate script header with metadata
generate_header(UserPredicates, Options, Code) :-
    get_time(Timestamp),
    format_time(atom(DateStr), '%Y-%m-%d %H:%M:%S', Timestamp),

    % Extract source file if provided
    (   member(source_file(SourceFile), Options)
    ->  format(atom(SourceComment), '% Source: ~w', [SourceFile])
    ;   SourceComment = ''
    ),

    % Format predicate list
    length(UserPredicates, NumPreds),
    format(atom(PredsStr), '~w', [UserPredicates]),

    % Build lines
    format(atom(DateLine), '% Generated: ~w', [DateStr]),
    format(atom(NumPredsLine), '% Predicates transpiled: ~w', [NumPreds]),
    format(atom(PredsLine), '% ~w', [PredsStr]),

    % Combine
    (   SourceComment = ''
    ->  Lines = ['% Generated by UnifyWeaver v0.0.3',
                 '% Target: Prolog',
                 DateLine,
                 NumPredsLine,
                 PredsLine]
    ;   Lines = ['% Generated by UnifyWeaver v0.0.3',
                 '% Target: Prolog',
                 DateLine,
                 SourceComment,
                 NumPredsLine,
                 PredsLine]
    ),
    atomic_list_concat(Lines, '\n', Code).

%% generate_module_imports(+Dependencies, +Options, -Code)
%  Generate module import statements
%
%  @arg Dependencies List of required modules/features
%  @arg Options Compilation options (inline_runtime, etc.)
%  @arg Code Generated import code
generate_module_imports(Dependencies, Options, Code) :-
    % Check if runtime should be inlined or referenced
    (   member(inline_runtime(true), Options)
    ->  % Will inline later, no imports needed
        Code = '% Runtime library inlined below'
    ;   % Reference runtime library via imports
        generate_import_statements(Dependencies, ImportStatements),
        atomic_list_concat(ImportStatements, '\n', Code)
    ).

%% generate_import_statements(+Dependencies, -Statements)
%  Convert dependency list to import statements
generate_import_statements(Dependencies, Statements) :-
    % Add search path setup - use multifile to make it work before module loads
    SearchPathSetup = [
        '% Set up UnifyWeaver runtime library search path',
        ':- multifile user:file_search_path/2.',
        ':- dynamic user:file_search_path/2.',
        '',
        '% Check for UNIFYWEAVER_HOME environment variable',
        'setup_unifyweaver_path :- getenv(\'UNIFYWEAVER_HOME\', Home), !, asserta(user:file_search_path(unifyweaver, Home)).',
        'setup_unifyweaver_path.  % Assume installed as pack if UNIFYWEAVER_HOME not set',
        '',
        ':- setup_unifyweaver_path.'
    ],

    % Convert dependencies to use_module statements
    findall(Import, (
        member(Dep, Dependencies),
        dependency_to_import(Dep, Import)
    ), Imports),

    % Combine
    append(SearchPathSetup, [''] , HeaderWithSpace),
    append(HeaderWithSpace, Imports, Statements).

%% dependency_to_import(+Dependency, -ImportStatement)
%  Convert dependency term to use_module statement
dependency_to_import(module(ModulePath), Import) :-
    format(atom(Import), ':- use_module(~w).', [ModulePath]).

dependency_to_import(ensure_loaded(ModulePath), Import) :-
    format(atom(Import), ':- ensure_loaded(~w).', [ModulePath]).

dependency_to_import(plugin_registration(Type, Name, Module), Import) :-
    format(atom(Import), ':- register_~w(~w, ~w).', [Type, Name, Module]).

%% generate_user_code(+UserPredicates, +Options, -Code)
%  Generate user's predicates (copied or templated)
%
%  Strategy:
%  - Simple predicates: Copy verbatim using clause/2
%  - Complex predicates with config: Use templates
%  - Detect which strategy per predicate
generate_user_code(UserPredicates, Options, Code) :-
    format(atom(Header), '% === User Code (Transpiled) ===~n', []),

    findall(PredCode, (
        member(Pred/Arity, UserPredicates),
        generate_predicate_code(Pred/Arity, Options, PredCode)
    ), PredCodes),

    atomic_list_concat([Header|PredCodes], '\n\n', Code).

%% generate_predicate_code(+Pred/Arity, +Options, -Code)
%  Generate code for a single predicate with constraint handling
generate_predicate_code(Pred/Arity, Options, Code) :-
    % Get dialect for constraint handling
    option(dialect(Dialect), Options, swi),

    % Copy predicate clauses verbatim
    copy_predicate_clauses(Pred/Arity, BaseCode),

    % Apply constraints if specified
    (   option(constraints(Constraints), Options)
    ->  handle_constraints(Constraints, Dialect, Pred/Arity, BaseCode, Code)
    ;   Code = BaseCode  % No constraints, use verbatim copy
    ).

%% copy_predicate_clauses(+Pred/Arity, -Code)
%  Copy predicate clauses verbatim using introspection
copy_predicate_clauses(Pred/Arity, Code) :-
    functor(Head, Pred, Arity),

    % Find all clauses
    findall(ClauseStr, (
        clause(Head, Body),
        clause_to_string((Head :- Body), ClauseStr)
    ), ClauseStrs),

    (   ClauseStrs = []
    ->  % No clauses found - might be undefined or built-in
        format(atom(Code), '% ~w/~w - Not found or built-in~n', [Pred, Arity])
    ;   atomic_list_concat(ClauseStrs, '\n', Code)
    ).

%% clause_to_string(+Clause, -String)
%  Convert clause term to string representation
clause_to_string(Clause, String) :-
    % Use with_output_to to capture portray_clause output
    with_output_to(atom(String),
        portray_clause(Clause)
    ).

%% generate_entry_point(+Options, -Code)
%  Generate main entry point and initialization
generate_entry_point(Options, Code) :-
    % Determine entry point goal
    (   member(entry_point(EntryGoal), Options)
    ->  format(atom(EntryGoalStr), '~w', [EntryGoal])
    ;   EntryGoalStr = 'main'
    ),

    % Determine argument handling
    (   member(arguments(ArgSpec), Options)
    ->  generate_argument_parsing(ArgSpec, ArgParseCode)
    ;   ArgParseCode = '    % No argument parsing'
    ),

    % Build entry goal line
    format(atom(EntryGoalLine), '    ~w,', [EntryGoalStr]),

    % Build lines
    atomic_list_concat([
        '% === Entry Point ===',
        'main :-',
        ArgParseCode,
        EntryGoalLine,
        '    halt(0).',
        '',
        'main :-',
        '    % If main goal fails, exit with error',
        '    format(user_error, \'Error: Execution failed~n\', []),',
        '    halt(1).',
        '',
        ':- initialization(main, main).'
    ], '\n', Code).

%% generate_argument_parsing(+ArgSpec, -Code)
%  Generate code to parse command-line arguments
generate_argument_parsing(args(VarList), Code) :-
    % VarList = [file, option1, option2, ...]
    length(VarList, NumArgs),
    format(atom(Code),
           'current_prolog_flag(argv, Argv),~n~
                (   length(Argv, ~w)~n~
                ->  Argv = ~w~n~
                ;   format(user_error, \'Usage: ~w~n\', []),~n~
                    halt(1)~n~
                )',
           [NumArgs, VarList, VarList]).

generate_argument_parsing(optional_args(VarList, Defaults), Code) :-
    % With defaults for optional arguments
    format(atom(Code),
           'current_prolog_flag(argv, Argv),~n~
                parse_arguments(Argv, ~w, ~w)',
           [VarList, Defaults]).

%% ============================================
%% DEPENDENCY ANALYSIS
%% ============================================

%% analyze_dependencies(+UserPredicates, -Dependencies)
%  Analyze user code to determine runtime dependencies
%
%  @arg UserPredicates List of Pred/Arity
%  @arg Dependencies List of dependency terms:
%       - module(ModulePath) - Module to import
%       - ensure_loaded(Path) - File to ensure_loaded
%       - plugin_registration(Type, Name, Module) - Plugin to register
%
%  @example Detect partitioner usage
%    ?- analyze_dependencies([process/2], Deps).
%    Deps = [module(unifyweaver(core/partitioner)), ...].
analyze_dependencies(UserPredicates, Dependencies) :-
    % Analyze each predicate's body for feature usage
    findall(Dep, (
        member(Pred/Arity, UserPredicates),
        functor(Head, Pred, Arity),
        clause(Head, Body),
        extract_dependencies_from_body(Body, Dep)
    ), AllDeps),

    % Remove duplicates
    sort(AllDeps, Dependencies).

%% extract_dependencies_from_body(+Body, -Dependency)
%  Extract dependencies from clause body
extract_dependencies_from_body(Body, Dependency) :-
    % Check for known patterns
    contains_goal(Body, Goal),
    goal_requires_dependency(Goal, Dependency).

%% contains_goal(+Body, -Goal)
%  Recursively extract goals from clause body
contains_goal(Goal, Goal) :-
    callable(Goal).

contains_goal((A, B), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ).

contains_goal((A ; B), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ).

contains_goal((A -> B ; C), Goal) :-
    !,
    (   contains_goal(A, Goal)
    ;   contains_goal(B, Goal)
    ;   contains_goal(C, Goal)
    ).

%% goal_requires_dependency(+Goal, -Dependency)
%  Map goal patterns to required dependencies
%
%  This is where we detect feature usage and map to runtime modules

% Partitioning features
goal_requires_dependency(partitioner_init(_, _, _), module(unifyweaver(core/partitioner))).
goal_requires_dependency(partitioner_partition(_, _, _), module(unifyweaver(core/partitioner))).
goal_requires_dependency(partition_data(_, _, _), module(unifyweaver(core/partitioner))).

% Parallel backend features
goal_requires_dependency(backend_init(_, _), module(unifyweaver(core/parallel_backend))).
goal_requires_dependency(backend_execute(_, _, _, _), module(unifyweaver(core/parallel_backend))).
goal_requires_dependency(parallel_map(_, _, _), module(unifyweaver(core/parallel_backend))).

% Data source features
goal_requires_dependency(read_csv(_, _), module(unifyweaver(sources/csv))).
goal_requires_dependency(read_json(_, _), module(unifyweaver(sources/json))).
goal_requires_dependency(http_get(_, _), module(unifyweaver(sources/http))).

% Detect strategy/backend registration needs
goal_requires_dependency(partitioner_init(Strategy, _, _), StrategyDep) :-
    Strategy =.. [StrategyName|_],
    strategy_requires_module(StrategyName, StrategyDep).

goal_requires_dependency(backend_init(Backend, _), BackendDep) :-
    Backend =.. [BackendName|_],
    backend_requires_module(BackendName, BackendDep).

%% strategy_requires_module(+StrategyName, -Dependency)
%  Map strategy name to required module
strategy_requires_module(fixed_size, ensure_loaded(unifyweaver(core/partitioners/fixed_size))).
strategy_requires_module(fixed_size, plugin_registration(partitioner, fixed_size, fixed_size_partitioner)).

strategy_requires_module(hash_based, ensure_loaded(unifyweaver(core/partitioners/hash_based))).
strategy_requires_module(hash_based, plugin_registration(partitioner, hash_based, hash_based_partitioner)).

strategy_requires_module(key_based, ensure_loaded(unifyweaver(core/partitioners/key_based))).
strategy_requires_module(key_based, plugin_registration(partitioner, key_based, key_based_partitioner)).

%% backend_requires_module(+BackendName, -Dependency)
%  Map backend name to required module
backend_requires_module(gnu_parallel, ensure_loaded(unifyweaver(core/backends/gnu_parallel))).
backend_requires_module(gnu_parallel, plugin_registration(backend, gnu_parallel, gnu_parallel_backend)).

%% ============================================
%% OUTPUT GENERATION
%% ============================================

%%generate_main_predicate(+Options, -MainPred)
%  Generate main/0 predicate from options
generate_main_predicate(Options, MainPred) :-
    option(entry_point(EntryGoal), Options, main),
    option(arguments(ArgSpec), Options, none),

    (   ArgSpec = none
    ->  ArgParseCode = ''
    ;   generate_argument_parsing(ArgSpec, ArgParseCode)
    ),

    format(atom(EntryGoalStr), '~w', [EntryGoal]),
    format(atom(EntryGoalLine), '    ~w,', [EntryGoalStr]),

    atomic_list_concat([
        'main :-',
        ArgParseCode,
        EntryGoalLine,
        '    halt(0).',
        '',
        'main :-',
        '    format(user_error, \'Error: Execution failed~n\', []),',
        '    halt(1).'
    ], '\n', MainPred).

%% write_prolog_script(+ScriptCode, +OutputPath)
%  Write generated script to file and make executable
write_prolog_script(ScriptCode, OutputPath) :-
    write_prolog_script(ScriptCode, OutputPath, []).

%% write_prolog_script(+ScriptCode, +OutputPath, +Options)
%  Write script with compilation support
write_prolog_script(ScriptCode, OutputPath, Options) :-
    % Write script
    open(OutputPath, write, Stream, [encoding(utf8)]),
    write(Stream, ScriptCode),
    nl(Stream),
    close(Stream),

    % Make executable (chmod +x)
    format(atom(ChmodCmd), 'chmod +x ~w', [OutputPath]),
    shell(ChmodCmd),

    format('[PrologTarget] Generated script: ~w~n', [OutputPath]),

    % Optionally compile for dialects that support it
    (   option(compile(true), Options),
        option(dialect(Dialect), Options)
    ->  compile_script_safe(Dialect, OutputPath, Options)
    ;   true
    ).

%% compile_script(+Dialect, +ScriptPath)
%  Compile script using dialect-specific compiler
compile_script(Dialect, ScriptPath) :-
    (   dialect_compile_command(Dialect, ScriptPath, CompileCmd)
    ->  format('[PrologTarget] Compiling with ~w: ~w~n', [Dialect, CompileCmd]),
        shell(CompileCmd, ExitCode),
        (   ExitCode = 0
        ->  format('[PrologTarget] Compilation complete~n')
        ;   format('[PrologTarget] ERROR: Compilation failed with exit code ~w~n', [ExitCode]),
            throw(error(compilation_failed(Dialect, ExitCode),
                       context(compile_script/2, 'Compiler returned non-zero exit code')))
        )
    ;   format('[PrologTarget] Dialect ~w does not support compilation~n', [Dialect])
    ).

%% compile_script_safe(+Dialect, +ScriptPath, +Options)
%  Compile script with graceful failure handling
%
%  If compilation fails, checks if fallback is enabled and attempts
%  alternative dialects. For v0.1, logs warnings but continues.
%
%  TODO (v0.2): Implement full multi-dialect fallback that regenerates
%  code for alternative dialects when compilation fails.
compile_script_safe(Dialect, ScriptPath, Options) :-
    catch(
        compile_script(Dialect, ScriptPath),
        error(compilation_failed(FailedDialect, ExitCode), Context),
        (   % Compilation failed - handle gracefully
            format('[PrologTarget] WARNING: ~w compilation failed (exit ~w)~n',
                   [FailedDialect, ExitCode]),

            % Check if we should fail or continue
            (   option(fail_on_compile_error(true), Options)
            ->  % Propagate error if strict mode
                throw(error(compilation_failed(FailedDialect, ExitCode), Context))
            ;   % Otherwise continue with interpreted script
                format('[PrologTarget] Continuing with interpreted script: ~w~n', [ScriptPath]),
                format('[PrologTarget] NOTE: Full multi-dialect fallback planned for v0.2~n')
            )
        )
    ).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

%% is_user_predicate(+Pred/Arity)
%  Check if predicate is user-defined (not built-in or library)
is_user_predicate(Pred/Arity) :-
    functor(Head, Pred, Arity),
    % Has at least one clause
    clause(Head, _),
    % Not from system modules
    \+ predicate_property(Head, built_in),
    \+ predicate_property(Head, imported_from(_)).
