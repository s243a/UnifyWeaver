% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% c_target.pl - C Target for UnifyWeaver
% Generates C programs for record/field processing
% Uses cJSON for JSON handling

:- encoding(utf8).

:- module(c_target, [
    compile_predicate_to_c/3,     % +Predicate, +Options, -CCode
    compile_c_pipeline/3,         % +Predicates, +Options, -CCode
    compile_facts_to_c/3,         % +Pred, +Arity, -CCode  -- NEW
    generate_makefile/2,          % +Options, -MakefileContent
    generate_cmake/2,             % +Options, -CMakeContent
    write_c_program/2,            % +CCode, +FilePath
    init_c_target/0,              % Initialize C target
    test_c_pipeline_mode/0        % Test pipeline mode
]).

:- use_module(library(lists)).

% Binding system integration
:- use_module('../core/binding_registry').

% Track required includes
:- dynamic required_c_include/1.

%% init_c_target
init_c_target :-
    retractall(required_c_include(_)).

%% clear_c_includes
clear_c_includes :-
    retractall(required_c_include(_)).

%% collect_c_include(+Include)
collect_c_include(Include) :-
    (   required_c_include(Include)
    ->  true
    ;   assertz(required_c_include(Include))
    ).

%% get_c_includes(-Includes)
get_c_includes(Includes) :-
    findall(I, required_c_include(I), Includes).

%% format_c_includes(+Includes, -FormattedStr)
format_c_includes([], "").
format_c_includes(Includes, FormattedStr) :-
    Includes \= [],
    sort(Includes, UniqueIncludes),
    findall(Formatted,
        (   member(Include, UniqueIncludes),
            format(string(Formatted), "#include ~w~n", [Include])
        ),
        FormattedList),
    atomic_list_concat(FormattedList, '', FormattedStr).

%% ============================================
%% PUBLIC API
%% ============================================

%% compile_predicate_to_c(+Predicate, +Options, -CCode)
compile_predicate_to_c(PredIndicator, Options, CCode) :-
    (   PredIndicator = _Module:Pred/Arity
    ->  true
    ;   PredIndicator = Pred/Arity
    ),
    format('=== Compiling ~w/~w to C ===~n', [Pred, Arity]),

    clear_c_includes,

    % Check mode
    (   option(generator_mode(true), Options)
    ->  format('  Mode: Generator (callback iterator)~n'),
        compile_generator_mode_c(Pred, Arity, Options, CCode)
    ;   option(pipeline_input(true), Options)
    ->  format('  Mode: Pipeline (streaming JSONL)~n'),
        compile_pipeline_mode_c(Pred, Arity, Options, CCode)
    ;   format('  Mode: Simple predicate~n'),
        compile_simple_mode_c(Pred, Arity, Options, CCode)
    ).

%% ============================================
%% COMPILE FACTS TO C
%% ============================================

compile_facts_to_c(Pred, Arity, CCode) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredCap),
    functor(Head, Pred, Arity),
    
    findall(Args, (clause(Head, true), Head =.. [_|Args]), AllFacts),
    length(AllFacts, NumFacts),
    
    (   AllFacts == []
    ->  FactEntries = "    /* No facts defined */"
    ;   findall(Entry, (
            member(Args, AllFacts),
            format_c_fact_entry(Args, Entry)
        ), Entries),
        atomic_list_concat(Entries, ',\n', FactEntries)
    ),
    
    format(string(CCode),
'/* Generated by UnifyWeaver C Target - Facts Export */
/* Predicate: ~w/~w */

#include <stdio.h>
#include <string.h>

#define NUM_~w_FACTS ~w
#define ~w_ARITY ~w

/* Facts array: ~w(arg1, arg2, ...) */
static const char* ~w_facts[NUM_~w_FACTS][~w_ARITY] = {
~w
};

/* Get all facts */
void ~w_get_all(void (*callback)(const char**, int)) {
    for (int i = 0; i < NUM_~w_FACTS; i++) {
        callback(~w_facts[i], ~w_ARITY);
    }
}

/* Check if fact exists */
int ~w_contains(const char** args) {
    for (int i = 0; i < NUM_~w_FACTS; i++) {
        int match = 1;
        for (int j = 0; j < ~w_ARITY; j++) {
            if (strcmp(~w_facts[i][j], args[j]) != 0) {
                match = 0;
                break;
            }
        }
        if (match) return 1;
    }
    return 0;
}

/* Print fact helper */
static void print_fact(const char** fact, int arity) {
    for (int i = 0; i < arity; i++) {
        printf(\"%s\", fact[i]);
        if (i < arity - 1) printf(\":\");
    }
    printf(\"\\n\");
}

int main(int argc, char** argv) {
    (void)argc; (void)argv;
    ~w_get_all(print_fact);
    return 0;
}
', [PredStr, Arity, PredCap, NumFacts, PredCap, Arity, PredStr, PredStr, 
    PredCap, PredCap, FactEntries, PredStr, PredCap, PredStr, PredCap, 
    PredStr, PredCap, PredCap, PredStr, PredStr]).

format_c_fact_entry(Args, Entry) :-
    findall(Formatted, (
        member(Arg, Args),
        format(string(Formatted), '"~w"', [Arg])
    ), FormattedArgs),
    atomic_list_concat(FormattedArgs, ', ', ArgsStr),
    format(string(Entry), '    { ~w }', [ArgsStr]).

%% ============================================
%% GENERATOR MODE (Callback-based iterator)
%% ============================================

compile_generator_mode_c(Pred, Arity, _Options, CCode) :-
    collect_c_include('<stdio.h>'),
    collect_c_include('<stdlib.h>'),
    collect_c_include('<string.h>'),
    collect_c_include('"cJSON.h"'),
    
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    (   Clauses == []
    ->  GeneratorBody = "    /* No clauses - yield input unchanged */\n    callback(record, user_data);\n    return 1;"
    ;   generate_generator_body_c(Clauses, GeneratorBody)
    ),
    
    get_c_includes(IncludeList),
    format_c_includes(IncludeList, IncludesStr),
    
    format(string(CCode),
"/* Generated by UnifyWeaver C Target - Generator Mode */
/* Predicate: ~w/~w */
/* Uses callback-based iteration pattern */

~w

typedef void (*record_callback)(cJSON* record, void* user_data);

/**
 * Generator: processes record and calls callback for each result.
 * @param record Input JSON record
 * @param callback Function to call for each generated result
 * @param user_data User data passed to callback
 * @return Number of results generated
 */
int generate_~w(cJSON* record, record_callback callback, void* user_data) {
~w
}

/**
 * Process all records from JSONL stdin.
 */
void run_generator(record_callback callback, void* user_data) {
    char line[65536];
    
    while (fgets(line, sizeof(line), stdin)) {
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';
        if (strlen(line) == 0) continue;
        
        cJSON* record = cJSON_Parse(line);
        if (!record) {
            fprintf(stderr, \"JSON parse error\\n\");
            continue;
        }
        
        generate_~w(record, callback, user_data);
        cJSON_Delete(record);
    }
}

void print_result(cJSON* record, void* user_data) {
    (void)user_data;
    char* json_str = cJSON_PrintUnformatted(record);
    if (json_str) {
        printf(\"%s\\n\", json_str);
        free(json_str);
    }
}

int main(int argc, char** argv) {
    (void)argc; (void)argv;
    run_generator(print_result, NULL);
    return 0;
}
", [Pred, Arity, IncludesStr, Pred, GeneratorBody, Pred]).

%% generate_generator_body_c(+Clauses, -Code)
generate_generator_body_c(Clauses, Code) :-
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_c(Name, Clauses)
    ->  partition(is_recursive_clause_c(Name), Clauses, RecClauses, BaseClauses),
        compile_generator_recursive_c(Name, BaseClauses, RecClauses, Code)
    ;   Code = "    /* Non-recursive: yield once */\n    callback(record, user_data);\n    return 1;"
    ).

compile_generator_recursive_c(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_c(BaseHead, BaseCondition)
    ;   BaseCondition = "0"
    ),
    
    format(string(Code),
"    /* Recursive generator: ~w */
    cJSON* current = cJSON_Duplicate(record, 1);
    int count = 0;
    int max_iterations = 10000;
    
    for (int i = 0; i < max_iterations; i++) {
        callback(current, user_data);
        count++;
        
        /* Check base case */
        if (~w) {
            cJSON_Delete(current);
            return count;
        }
        
        /* TODO: Transform for next iteration */
    }
    
    fprintf(stderr, \"Warning: Max iterations exceeded for ~w\\n\");
    cJSON_Delete(current);
    return count;", [Name, BaseCondition, Name]).

%% ============================================
%% PIPELINE MODE
%% ============================================

compile_pipeline_mode_c(Pred, Arity, _Options, CCode) :-
    collect_c_include('<stdio.h>'),
    collect_c_include('<stdlib.h>'),
    collect_c_include('<string.h>'),
    collect_c_include('"cJSON.h"'),
    
    functor(Head, Pred, Arity),
    findall((Head, Body), clause(Head, Body), Clauses),
    
    (   Clauses == []
    ->  ProcessBody = "    /* No clauses - pass through */\n    return record;"
    ;   generate_pipeline_process_c(Clauses, ProcessBody)
    ),
    
    get_c_includes(IncludeList),
    format_c_includes(IncludeList, IncludesStr),
    
    format(string(CCode),
"/* Generated by UnifyWeaver C Target - Pipeline Mode */
/* Predicate: ~w/~w */

~w

/**
 * Process a single record.
 * @param record Input JSON (takes ownership)
 * @return Processed record or NULL to filter out
 */
cJSON* process(cJSON* record) {
~w
}

/**
 * Run the pipeline: read JSONL from stdin, process, write to stdout.
 */
void run_pipeline(void) {
    char line[65536];
    
    while (fgets(line, sizeof(line), stdin)) {
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\\n') line[len-1] = '\\0';
        if (strlen(line) == 0) continue;
        
        cJSON* record = cJSON_Parse(line);
        if (!record) {
            fprintf(stderr, \"JSON parse error: %%s\\n\", cJSON_GetErrorPtr());
            continue;
        }
        
        cJSON* result = process(record);
        if (result) {
            char* json_str = cJSON_PrintUnformatted(result);
            if (json_str) {
                printf(\"%%s\\n\", json_str);
                free(json_str);
            }
            if (result != record) cJSON_Delete(result);
        }
        cJSON_Delete(record);
    }
}

int main(int argc, char** argv) {
    (void)argc; (void)argv;
    run_pipeline();
    return 0;
}
", [Pred, Arity, IncludesStr, ProcessBody]).

%% generate_pipeline_process_c(+Clauses, -Code)
generate_pipeline_process_c([], "    return record;").
generate_pipeline_process_c(Clauses, Code) :-
    Clauses \= [],
    Clauses = [(Head, _)|_],
    functor(Head, Name, _),
    (   is_recursive_predicate_c(Name, Clauses)
    ->  partition(is_recursive_clause_c(Name), Clauses, RecClauses, BaseClauses),
        (   is_tail_recursive_c(Name, RecClauses)
        ->  compile_tail_recursive_c(Name, BaseClauses, RecClauses, Code)
        ;   compile_general_recursive_c(Name, BaseClauses, RecClauses, Code)
        )
    ;   findall(ClauseCode, 
            (member((H, B), Clauses), translate_clause_c(H, B, ClauseCode)),
            ClauseCodes),
        atomic_list_concat(ClauseCodes, '\n', Code)
    ).

%% ============================================
%% RECURSION DETECTION
%% ============================================

is_recursive_predicate_c(Name, Clauses) :-
    member((_, Body), Clauses),
    contains_recursive_call_c(Body, Name).

is_recursive_clause_c(Name, (_, Body)) :-
    contains_recursive_call_c(Body, Name).

is_tail_recursive_c(Name, RecClauses) :-
    member((_, Body), RecClauses),
    get_last_goal_c(Body, LastGoal),
    functor(LastGoal, Name, _).

get_last_goal_c((_, B), LastGoal) :- !, get_last_goal_c(B, LastGoal).
get_last_goal_c(Goal, Goal).

contains_recursive_call_c(Body, Name) :-
    extract_goal_c(Body, Goal),
    functor(Goal, Name, _),
    !.

extract_goal_c(Goal, Goal) :-
    compound(Goal),
    \+ Goal = (_,_),
    \+ Goal = (_;_).
extract_goal_c((A, _), Goal) :- extract_goal_c(A, Goal).
extract_goal_c((_, B), Goal) :- extract_goal_c(B, Goal).

%% ============================================
%% TAIL RECURSION (→ while loop)
%% ============================================

compile_tail_recursive_c(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_c(BaseHead, BaseCondition)
    ;   BaseCondition = "0"
    ),
    
    format(string(Code),
"    /* Tail-recursive predicate: ~w - optimized to while loop */
    cJSON* current = cJSON_Duplicate(record, 1);
    int max_iterations = 10000;
    
    for (int i = 0; i < max_iterations; i++) {
        /* Base case check */
        if (~w) {
            return current;
        }
        
        /* Recursive step: transform current */
        /* TODO: Apply transformation */
    }
    
    fprintf(stderr, \"Warning: Max iterations exceeded for ~w\\n\");
    return current;", [Name, BaseCondition, Name]).

%% ============================================
%% GENERAL RECURSION (→ explicit stack)
%% ============================================

compile_general_recursive_c(Name, BaseClauses, _RecClauses, Code) :-
    (   BaseClauses = [(BaseHead, _)|_]
    ->  generate_base_condition_c(BaseHead, BaseCondition)
    ;   BaseCondition = "0"
    ),
    
    format(string(Code),
"    /* General recursive predicate: ~w - using explicit stack */
    #define MAX_STACK 1000
    cJSON* stack[MAX_STACK];
    int stack_top = 0;
    
    stack[stack_top++] = cJSON_Duplicate(record, 1);
    cJSON* result = NULL;
    
    while (stack_top > 0) {
        cJSON* current = stack[--stack_top];
        
        /* Base case */
        if (~w) {
            result = current;
            break;
        }
        
        /* Push recursive case onto stack */
        /* TODO: Compute next value and push */
        cJSON_Delete(current);
    }
    
    /* Cleanup stack */
    while (stack_top > 0) {
        cJSON_Delete(stack[--stack_top]);
    }
    
    return result ? result : cJSON_Duplicate(record, 1);", [Name, BaseCondition]).

%% ============================================
%% CLAUSE TRANSLATION
%% ============================================

translate_clause_c(Head, Body, Code) :-
    Head =.. [_Pred|Args],
    generate_input_extraction_c(Args, InputCode),
    (   Body == true
    ->  BodyCode = "    /* Fact - no conditions */"
    ;   translate_body_c(Body, BodyCode)
    ),
    format(string(Code), "~w\n~w\n    return record;", [InputCode, BodyCode]).

generate_input_extraction_c(Args, Code) :-
    findall(Line, (
        nth0(I, Args, Arg),
        (   var(Arg)
        ->  format(string(Line), "    cJSON* arg~w = cJSON_GetObjectItem(record, \"arg~w\");", [I, I])
        ;   format(string(Line), "    /* arg~w = ~w (constant) */", [I, Arg])
        )
    ), Lines),
    atomic_list_concat(Lines, '\n', Code).

%% ============================================
%% BODY TRANSLATION
%% ============================================

translate_body_c((Goal, Rest), Code) :-
    !,
    translate_goal_c(Goal, Code1),
    translate_body_c(Rest, Code2),
    format(string(Code), "~w\n~w", [Code1, Code2]).
translate_body_c(Goal, Code) :-
    translate_goal_c(Goal, Code).

translate_goal_c(>(X, Y), Code) :-
    !, expr_to_c(X, CX), expr_to_c(Y, CY),
    format(string(Code), "    if (!(~w > ~w)) return NULL;", [CX, CY]).

translate_goal_c(<(X, Y), Code) :-
    !, expr_to_c(X, CX), expr_to_c(Y, CY),
    format(string(Code), "    if (!(~w < ~w)) return NULL;", [CX, CY]).

translate_goal_c(>=(X, Y), Code) :-
    !, expr_to_c(X, CX), expr_to_c(Y, CY),
    format(string(Code), "    if (!(~w >= ~w)) return NULL;", [CX, CY]).

translate_goal_c(=<(X, Y), Code) :-
    !, expr_to_c(X, CX), expr_to_c(Y, CY),
    format(string(Code), "    if (!(~w <= ~w)) return NULL;", [CX, CY]).

translate_goal_c(=:=(X, Y), Code) :-
    !, expr_to_c(X, CX), expr_to_c(Y, CY),
    format(string(Code), "    if (~w != ~w) return NULL;", [CX, CY]).

translate_goal_c(true, "    /* true */") :- !.

translate_goal_c(Goal, Code) :-
    format(string(Code), "    /* TODO: ~w */", [Goal]).

%% ============================================
%% HELPER PREDICATES
%% ============================================

generate_base_condition_c(Head, Condition) :-
    Head =.. [_|Args],
    (   Args = [Arg|_],
        (   number(Arg)
        ->  format(string(Condition), 
                "cJSON_GetObjectItem(current, \"arg0\") && cJSON_GetObjectItem(current, \"arg0\")->valueint == ~w", [Arg])
        ;   atom(Arg)
        ->  format(string(Condition),
                "cJSON_GetObjectItem(current, \"arg0\") && strcmp(cJSON_GetObjectItem(current, \"arg0\")->valuestring, \"~w\") == 0", [Arg])
        ;   Condition = "0"
        )
    ;   Condition = "0"
    ).

expr_to_c(Expr, CExpr) :-
    (   number(Expr)
    ->  format(atom(CExpr), "~w", [Expr])
    ;   var(Expr)
    ->  format(atom(CExpr), "var_~p", [Expr])
    ;   Expr = X + Y
    ->  expr_to_c(X, CX), expr_to_c(Y, CY),
        format(atom(CExpr), "(~w + ~w)", [CX, CY])
    ;   Expr = X - Y
    ->  expr_to_c(X, CX), expr_to_c(Y, CY),
        format(atom(CExpr), "(~w - ~w)", [CX, CY])
    ;   Expr = X * Y
    ->  expr_to_c(X, CX), expr_to_c(Y, CY),
        format(atom(CExpr), "(~w * ~w)", [CX, CY])
    ;   Expr = X / Y
    ->  expr_to_c(X, CX), expr_to_c(Y, CY),
        format(atom(CExpr), "(~w / ~w)", [CX, CY])
    ;   format(atom(CExpr), "~w", [Expr])
    ).

%% ============================================
%% SIMPLE MODE
%% ============================================

compile_simple_mode_c(Pred, Arity, _Options, CCode) :-
    collect_c_include('<stdio.h>'),
    
    get_c_includes(IncludeList),
    format_c_includes(IncludeList, IncludesStr),
    
    format(string(CCode),
"/* Generated by UnifyWeaver C Target */
/* Predicate: ~w/~w */

~w

int main(int argc, char** argv) {
    (void)argc; (void)argv;
    printf(\"Hello from ~w\\n\");
    return 0;
}
", [Pred, Arity, IncludesStr, Pred]).

%% ============================================
%% BUILD SYSTEM GENERATION
%% ============================================

generate_makefile(Options, MakefileContent) :-
    option(program_name(ProgName), Options, 'pipeline'),
    option(source_file(SourceFile), Options, 'pipeline.c'),
    
    format(string(MakefileContent),
"# Generated by UnifyWeaver C Target
CC = gcc
CFLAGS = -Wall -Wextra -O2 -std=c11
LDFLAGS = -lcjson

TARGET = ~w
SOURCES = ~w cJSON.c

.PHONY: all clean

all: $(TARGET)

$(TARGET): $(SOURCES)
\t$(CC) $(CFLAGS) -o $@ $^ $(LDFLAGS)

clean:
\trm -f $(TARGET)
", [ProgName, SourceFile]).

generate_cmake(Options, CMakeContent) :-
    option(project_name(ProjName), Options, 'UnifyWeaverPipeline'),
    option(source_file(SourceFile), Options, 'pipeline.c'),
    
    format(string(CMakeContent),
"# Generated by UnifyWeaver C Target
cmake_minimum_required(VERSION 3.10)
project(~w C)

set(CMAKE_C_STANDARD 11)
set(CMAKE_C_STANDARD_REQUIRED ON)

add_executable(pipeline ~w cJSON.c)
target_link_libraries(pipeline cjson)
", [ProjName, SourceFile]).

%% ============================================
%% UTILITY PREDICATES
%% ============================================

write_c_program(CCode, FilePath) :-
    open(FilePath, write, Stream),
    write(Stream, CCode),
    close(Stream),
    format('Written C program to: ~w~n', [FilePath]).

compile_c_pipeline(_Steps, _Options, Code) :-
    Code = "/* Multi-step C pipeline - use compile_predicate_to_c for now */".

option(Option, Options, _Default) :-
    member(Option, Options), !.
option(Option, _Options, Default) :-
    Option =.. [_, Default].

%% ============================================
%% TESTS
%% ============================================

test_c_pipeline_mode :-
    format('~n=== Testing C Pipeline Mode ===~n~n'),
    
    format('Test 1: Basic pipeline generation~n'),
    compile_predicate_to_c(test_pred/2, [pipeline_input(true)], Code1),
    (   sub_atom(Code1, _, _, _, 'run_pipeline')
    ->  format('  [PASS] Generated pipeline code~n')
    ;   format('  [FAIL] Missing pipeline code~n')
    ),
    
    format('~nTest 2: cJSON usage~n'),
    (   sub_atom(Code1, _, _, _, 'cJSON')
    ->  format('  [PASS] Uses cJSON~n')
    ;   format('  [FAIL] Missing cJSON~n')
    ),
    
    format('~nTest 3: Generator mode~n'),
    compile_predicate_to_c(test_gen/2, [generator_mode(true)], Code2),
    (   sub_atom(Code2, _, _, _, 'callback')
    ->  format('  [PASS] Uses callback pattern~n')
    ;   format('  [FAIL] Missing callback~n')
    ),
    
    format('~nTest 4: Makefile generation~n'),
    generate_makefile([program_name('test_prog')], Makefile),
    (   sub_atom(Makefile, _, _, _, 'gcc')
    ->  format('  [PASS] Generated Makefile~n')
    ;   format('  [FAIL] Invalid Makefile~n')
    ),
    
    format('~nTest 5: CMake generation~n'),
    generate_cmake([project_name('TestProject')], CMake),
    (   sub_atom(CMake, _, _, _, 'cmake_minimum_required')
    ->  format('  [PASS] Generated CMakeLists.txt~n')
    ;   format('  [FAIL] Invalid CMakeLists.txt~n')
    ),
    
    format('~n=== C Pipeline Mode Tests Complete ===~n').
