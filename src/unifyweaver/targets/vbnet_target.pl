:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% vbnet_target.pl - VB.NET Code Generation Target
% Compiles Prolog predicates to VB.NET programs for stream processing.

:- module(vbnet_target, [
    compile_predicate_to_vbnet/3,     % +PredIndicator, +Options, -VBCode
    compile_facts_to_vbnet/3,         % +Pred, +Arity, -VBCode  
    write_vbnet_program/2             % +Code, +Filename
]).

:- use_module(library(lists)).

%% compile_predicate_to_vbnet(+PredIndicator, +Options, -Code)
%  Compile a Prolog predicate to VB.NET.
compile_predicate_to_vbnet(Pred/Arity, Options, Code) :-
    functor(Head, Pred, Arity),
    findall(Head-Body, user:clause(Head, Body), Clauses),
    (   Clauses = []
    ->  format(user_error, 'VB.NET target: no clauses for ~w/~w~n', [Pred, Arity]),
        fail
    ;   compile_clauses_to_vbnet(Pred, Arity, Clauses, Options, Code)
    ).

%% compile_clauses_to_vbnet(+Pred, +Arity, +Clauses, +Options, -Code)
compile_clauses_to_vbnet(Pred, Arity, Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    % Check if all clauses are facts
    (   forall(member(_-Body, Clauses), Body == true)
    ->  compile_facts_vbnet(PredStr, PredUpStr, Arity, Clauses, Code)
    ;   compile_rule_vbnet(PredStr, PredUpStr, Arity, Clauses, Code)
    ).

%% compile_facts_vbnet(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_facts_vbnet(PredStr, PredUpStr, Arity, Clauses, Code) :-
    % Generate struct fields
    generate_vbnet_fields(Arity, FieldDefs),
    
    % Generate fact entries
    findall(Entry, (
        member(Head-true, Clauses),
        Head =.. [_|Args],
        generate_vbnet_fact_entry(Args, PredUpStr, Entry)
    ), Entries),
    atomic_list_concat(Entries, ',\n            ', EntriesCode),
    
    format(string(Code),
'Imports System
Imports System.Collections.Generic

'' Generated by UnifyWeaver VB.NET Target - Fact Export
'' Predicate: ~w/~w

Public Class ~w
~w
    
    Public Sub New(~w)
~w
    End Sub
End Class

Module Facts
    Public Function GetAll~w() As List(Of ~w)
        Return New List(Of ~w) From {
            ~w
        }
    End Function
    
    Public Function Contains(target As ~w) As Boolean
        Return GetAll~w().Exists(Function(f) f.Equals(target))
    End Function
End Module

Module Program
    Sub Main()
        For Each fact In GetAll~w()
            Console.WriteLine(~w)
        Next
    End Sub
End Module
', [PredStr, Arity, PredUpStr, FieldDefs, 
    generate_vbnet_ctor_params(Arity), generate_vbnet_ctor_body(Arity),
    PredUpStr, PredUpStr, PredUpStr, EntriesCode,
    PredUpStr, PredUpStr, PredUpStr, generate_vbnet_print(Arity)]).

%% compile_rule_vbnet(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_rule_vbnet(PredStr, _PredUpStr, Arity, _Clauses, Code) :-
    format(string(Code),
'Imports System
Imports System.IO

'' Generated by UnifyWeaver VB.NET Target - Rule Compilation
'' Predicate: ~w/~w

Module Program
    Sub Main()
        Dim reader = New StreamReader(Console.OpenStandardInput())
        Dim line As String
        
        line = reader.ReadLine()
        While line IsNot Nothing
            Dim parts = line.Split(":"c)
            If parts.Length >= ~w Then
                '' Process: ~w
                Console.WriteLine(line)
            End If
            line = reader.ReadLine()
        End While
    End Sub
End Module
', [PredStr, Arity, Arity, PredStr]).

%% compile_facts_to_vbnet(+Pred, +Arity, -Code)
compile_facts_to_vbnet(Pred, Arity, Code) :-
    compile_predicate_to_vbnet(Pred/Arity, [], Code).

%% write_vbnet_program(+Code, +Filename)
write_vbnet_program(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('VB.NET program written to: ~w~n', [Filename]).

%% Helper predicates
generate_vbnet_fields(Arity, Fields) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), '    Public Property Arg~w As String', [N])
    ), FieldList),
    atomic_list_concat(FieldList, '\n', Fields).

generate_vbnet_ctor_params(Arity) :-
    findall(Param, (
        between(1, Arity, N),
        format(string(Param), 'arg~w As String', [N])
    ), Params),
    atomic_list_concat(Params, ', ', _Result).

generate_vbnet_ctor_params(Arity, Result) :-
    findall(Param, (
        between(1, Arity, N),
        format(string(Param), 'arg~w As String', [N])
    ), Params),
    atomic_list_concat(Params, ', ', Result).

generate_vbnet_ctor_body(Arity) :-
    findall(Assign, (
        between(1, Arity, N),
        format(string(Assign), '        Me.Arg~w = arg~w', [N, N])
    ), Assigns),
    atomic_list_concat(Assigns, '\n', _Result).

generate_vbnet_ctor_body(Arity, Result) :-
    findall(Assign, (
        between(1, Arity, N),
        format(string(Assign), '        Me.Arg~w = arg~w', [N, N])
    ), Assigns),
    atomic_list_concat(Assigns, '\n', Result).

generate_vbnet_fact_entry(Args, StructName, Entry) :-
    findall(ArgStr, (
        member(Arg, Args),
        format(string(ArgStr), '"~w"', [Arg])
    ), ArgStrs),
    atomic_list_concat(ArgStrs, ', ', ArgsJoined),
    format(string(Entry), 'New ~w(~w)', [StructName, ArgsJoined]).

generate_vbnet_print(Arity) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), 'fact.Arg~w', [N])
    ), Fields),
    atomic_list_concat(Fields, ' & ":" & ', _Code).

generate_vbnet_print(Arity, Code) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), 'fact.Arg~w', [N])
    ), Fields),
    atomic_list_concat(Fields, ' & ":" & ', Code).
