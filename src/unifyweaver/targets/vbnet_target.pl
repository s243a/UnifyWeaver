:- encoding(utf8).
% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (@s243a)
%
% vbnet_target.pl - VB.NET Code Generation Target
% Compiles Prolog predicates to VB.NET programs for stream processing.

:- module(vbnet_target, [
    compile_predicate_to_vbnet/3,          % +PredIndicator, +Options, -VBCode
    compile_facts_to_vbnet/3,              % +Pred, +Arity, -VBCode  
    compile_tail_recursion_vbnet/3,        % +Pred/Arity, +Options, -VBCode
    compile_linear_recursion_vbnet/3,      % +Pred/Arity, +Options, -VBCode
    compile_mutual_recursion_vbnet/3,      % +Predicates, +Options, -VBCode
    write_vbnet_program/2,                 % +Code, +Filename
    init_vbnet_target/0                    % Initialize target
]).

:- use_module(library(lists)).
:- use_module('../bindings/vbnet_bindings', [init_vbnet_bindings/0]).

%% init_vbnet_target
init_vbnet_target :-
    init_vbnet_bindings.

%% compile_predicate_to_vbnet(+PredIndicator, +Options, -Code)
compile_predicate_to_vbnet(Pred/Arity, Options, Code) :-
    functor(Head, Pred, Arity),
    findall(Head-Body, user:clause(Head, Body), Clauses),
    (   Clauses = []
    ->  format(user_error, 'VB.NET target: no clauses for ~w/~w~n', [Pred, Arity]),
        fail
    ;   compile_clauses_to_vbnet(Pred, Arity, Clauses, Options, Code)
    ).

%% compile_clauses_to_vbnet(+Pred, +Arity, +Clauses, +Options, -Code)
compile_clauses_to_vbnet(Pred, Arity, Clauses, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    (   forall(member(_-Body, Clauses), Body == true)
    ->  compile_facts_vbnet(PredStr, PredUpStr, Arity, Clauses, Code)
    ;   compile_rule_vbnet(PredStr, PredUpStr, Arity, Clauses, Code)
    ).

%% compile_facts_vbnet(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_facts_vbnet(PredStr, PredUpStr, Arity, Clauses, Code) :-
    generate_vbnet_fields(Arity, FieldDefs),
    generate_vbnet_ctor_params(Arity, CtorParams),
    generate_vbnet_ctor_body(Arity, CtorBody),
    findall(Entry, (
        member(Head-true, Clauses),
        Head =.. [_|Args],
        generate_vbnet_fact_entry(Args, PredUpStr, Entry)
    ), Entries),
    atomic_list_concat(Entries, ',\n            ', EntriesCode),
    generate_vbnet_print(Arity, PrintCode),
    
    format(string(Code),
'Imports System
Imports System.Collections.Generic

'' Generated by UnifyWeaver VB.NET Target - Fact Export
'' Predicate: ~w/~w

Public Class ~w
~w
    
    Public Sub New(~w)
~w
    End Sub
End Class

Module Facts
    Public Function GetAll~w() As List(Of ~w)
        Return New List(Of ~w) From {
            ~w
        }
    End Function
    
    Public Function Stream~w() As IEnumerable(Of ~w)
        Return GetAll~w()
    End Function
    
    Public Function Contains(target As ~w) As Boolean
        Return GetAll~w().Exists(Function(f) f.Equals(target))
    End Function
End Module

Module Program
    Sub Main()
        For Each fact In GetAll~w()
            Console.WriteLine(~w)
        Next
    End Sub
End Module
', [PredStr, Arity, PredUpStr, FieldDefs, CtorParams, CtorBody,
    PredUpStr, PredUpStr, PredUpStr, EntriesCode,
    PredUpStr, PredUpStr, PredUpStr,
    PredUpStr, PredUpStr, PredUpStr, PrintCode]).

%% compile_rule_vbnet(+PredStr, +PredUpStr, +Arity, +Clauses, -Code)
compile_rule_vbnet(PredStr, _PredUpStr, Arity, _Clauses, Code) :-
    format(string(Code),
'Imports System
Imports System.IO

'' Generated by UnifyWeaver VB.NET Target - Rule Compilation
'' Predicate: ~w/~w

Module Program
    Sub Main()
        Dim reader = New StreamReader(Console.OpenStandardInput())
        Dim line As String
        
        line = reader.ReadLine()
        While line IsNot Nothing
            Dim parts = line.Split(":"c)
            If parts.Length >= ~w Then
                Console.WriteLine(line)
            End If
            line = reader.ReadLine()
        End While
    End Sub
End Module
', [PredStr, Arity, Arity]).

%% ============================================
%% TAIL RECURSION (Do While loop)
%% ============================================

compile_tail_recursion_vbnet(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    format(string(Code),
'Imports System

'' Generated by UnifyWeaver VB.NET Target - Tail Recursion
'' Predicate: ~w/~w
'' Optimized to O(1) stack space using Do While loop

Module ~wModule
    '' Tail-recursive function compiled to iterative loop
    Public Function ~w(n As Integer, acc As Integer) As Integer
        Dim current = n
        Dim accumulator = acc
        
        Do While current > 0
            accumulator += current
            current -= 1
        Loop
        
        Return accumulator
    End Function
    
    '' Entry point
    Public Function ~w(n As Integer) As Integer
        Return ~w(n, 0)
    End Function
End Module

Module Program
    Sub Main(args As String())
        If args.Length >= 1 Then
            Dim n = Integer.Parse(args(0))
            Console.WriteLine(~wModule.~w(n))
        End If
    End Sub
End Module
', [PredStr, Arity, PredUpStr, PredStr, PredStr, PredStr, PredUpStr, PredStr]).

%% ============================================
%% LINEAR RECURSION (Dictionary memo)
%% ============================================

compile_linear_recursion_vbnet(Pred/Arity, _Options, Code) :-
    atom_string(Pred, PredStr),
    upcase_atom(Pred, PredUp),
    atom_string(PredUp, PredUpStr),
    
    format(string(Code),
'Imports System
Imports System.Collections.Generic

'' Generated by UnifyWeaver VB.NET Target - Linear Recursion
'' Predicate: ~w/~w
'' Uses Dictionary-based memoization for O(n) performance

Module ~wModule
    Private ReadOnly _memo As New Dictionary(Of Integer, Integer)
    
    Public Function ~w(n As Integer) As Integer
        '' Check memo
        If _memo.ContainsKey(n) Then
            Return _memo(n)
        End If
        
        '' Base cases
        If n <= 0 Then Return 0
        If n = 1 Then Return 1
        
        '' Recursive case with memoization
        Dim result = ~w(n - 1) + n
        _memo(n) = result
        Return result
    End Function
    
    Public Sub ClearMemo()
        _memo.Clear()
    End Sub
End Module

Module Program
    Sub Main(args As String())
        If args.Length >= 1 Then
            Dim n = Integer.Parse(args(0))
            Console.WriteLine(~wModule.~w(n))
        End If
    End Sub
End Module
', [PredStr, Arity, PredUpStr, PredStr, PredStr, PredUpStr, PredStr]).

%% ============================================
%% MUTUAL RECURSION (Shared Dictionary)
%% ============================================

compile_mutual_recursion_vbnet(Predicates, _Options, Code) :-
    findall(PredStr, (
        member(Pred/_Arity, Predicates),
        atom_string(Pred, PredStr)
    ), PredStrs),
    atomic_list_concat(PredStrs, '_', GroupName),
    upcase_atom(GroupName, GroupUp),
    atom_string(GroupUp, GroupUpStr),
    
    % Generate functions for each predicate
    findall(FuncCode, (
        member(Pred/Arity, Predicates),
        generate_vbnet_mutual_function(Pred, Arity, Predicates, FuncCode)
    ), FuncCodes),
    atomic_list_concat(FuncCodes, '\n\n', FunctionsCode),
    
    format(string(Code),
'Imports System
Imports System.Collections.Generic

'' Generated by UnifyWeaver VB.NET Target - Mutual Recursion
'' Group: ~w

Module ~wModule
    Private ReadOnly _memo As New Dictionary(Of String, Boolean)
    
~w
    
    Public Sub ClearMemo()
        _memo.Clear()
    End Sub
End Module

Module Program
    Sub Main(args As String())
        If args.Length >= 2 Then
            Dim func = args(0)
            Dim n = Integer.Parse(args(1))
            Select Case func
                Case "is_even"
                    Console.WriteLine(~wModule.is_even(n))
                Case "is_odd"
                    Console.WriteLine(~wModule.is_odd(n))
            End Select
        End If
    End Sub
End Module
', [GroupName, GroupUpStr, FunctionsCode, GroupUpStr, GroupUpStr]).

%% generate_vbnet_mutual_function(+Pred, +Arity, +AllPredicates, -Code)
generate_vbnet_mutual_function(Pred, _Arity, AllPredicates, Code) :-
    atom_string(Pred, PredStr),
    
    % Find the other predicate to call
    member(OtherPred/_OtherArity, AllPredicates),
    OtherPred \= Pred,
    atom_string(OtherPred, OtherPredStr),
    
    format(string(Code),
'    Public Function ~w(n As Integer) As Boolean
        Dim key = "~w:" & n.ToString()
        If _memo.ContainsKey(key) Then
            Return _memo(key)
        End If
        
        '' Base case
        If n = 0 Then
            _memo(key) = ("~w" = "is_even")
            Return ("~w" = "is_even")
        End If
        
        '' Recursive case - call other predicate
        If n > 0 Then
            Dim result = ~w(n - 1)
            _memo(key) = result
            Return result
        End If
        
        Return False
    End Function', [PredStr, PredStr, PredStr, PredStr, OtherPredStr]).

%% compile_facts_to_vbnet(+Pred, +Arity, -Code)
compile_facts_to_vbnet(Pred, Arity, Code) :-
    compile_predicate_to_vbnet(Pred/Arity, [], Code).

%% write_vbnet_program(+Code, +Filename)
write_vbnet_program(Code, Filename) :-
    open(Filename, write, Stream),
    write(Stream, Code),
    close(Stream),
    format('VB.NET program written to: ~w~n', [Filename]).

%% Helper predicates
generate_vbnet_fields(Arity, Fields) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), '    Public Property Arg~w As String', [N])
    ), FieldList),
    atomic_list_concat(FieldList, '\n', Fields).

generate_vbnet_ctor_params(Arity, Result) :-
    findall(Param, (
        between(1, Arity, N),
        format(string(Param), 'arg~w As String', [N])
    ), Params),
    atomic_list_concat(Params, ', ', Result).

generate_vbnet_ctor_body(Arity, Result) :-
    findall(Assign, (
        between(1, Arity, N),
        format(string(Assign), '        Me.Arg~w = arg~w', [N, N])
    ), Assigns),
    atomic_list_concat(Assigns, '\n', Result).

generate_vbnet_fact_entry(Args, StructName, Entry) :-
    findall(ArgStr, (
        member(Arg, Args),
        format(string(ArgStr), '"~w"', [Arg])
    ), ArgStrs),
    atomic_list_concat(ArgStrs, ', ', ArgsJoined),
    format(string(Entry), 'New ~w(~w)', [StructName, ArgsJoined]).

generate_vbnet_print(Arity, Code) :-
    findall(Field, (
        between(1, Arity, N),
        format(string(Field), 'fact.Arg~w', [N])
    ), Fields),
    atomic_list_concat(Fields, ' & ":" & ', Code).
