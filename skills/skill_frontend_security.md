# Skill: Frontend Security

Security patterns for frontend applications including module whitelisting, input validation, rate limiting, and firewall policies.

## When to Use

- User asks "how do I secure my frontend app?"
- User needs to whitelist Python modules for RPyC bridge
- User wants input validation for API calls
- User needs rate limiting middleware
- User asks about firewall policies or security rules

## Quick Start

```prolog
:- use_module('src/unifyweaver/glue/rpyc_security').
:- use_module('src/unifyweaver/core/firewall').

% Check if a Python call is allowed
is_call_allowed(math, sqrt, Result).
% Result = true

% Generate TypeScript security whitelist
generate_typescript_whitelist(Code).

% Generate Express security middleware
generate_express_security_middleware(Code).
```

## RPyC Security (Python Bridge)

The `rpyc_security.pl` module provides declarative security rules for controlling which Python modules and functions can be called from TypeScript/JavaScript code.

### Default Allowed Modules

| Module | Functions |
|--------|-----------|
| `math` | sqrt, sin, cos, tan, log, exp, pow, floor, ceil, abs, etc. |
| `statistics` | mean, median, mode, stdev, variance, etc. |
| `numpy` | array, zeros, ones, sum, mean, std, reshape, dot, etc. |
| `json` | loads, dumps |
| `datetime` | now, utcnow, today, fromisoformat |

### Security Rule Predicates

```prolog
% Define allowed functions for a module
rpyc_allowed_module(Module, Functions).

% Define allowed attributes (constants)
rpyc_allowed_attr(Module, Attributes).

% Rate limiting configuration
rpyc_rate_limit(Config).

% Named security policies
rpyc_security_policy(Name, Rules).
```

### Add/Remove Rules

```prolog
% Add new allowed module
add_allowed_module(scipy, [optimize, integrate, interpolate]).

% Add allowed attributes
add_allowed_attr(scipy, [__version__]).

% Remove module from whitelist
remove_allowed_module(numpy).

% Clear all rules
clear_security_rules.
```

### Validation

```prolog
% Check if function call is allowed
is_call_allowed(math, sqrt, true).
is_call_allowed(os, system, false).

% Check if attribute access is allowed
is_attr_allowed(math, pi, true).

% Validate with detailed result
validate_call(math, sqrt, Result).
% Result = ok

validate_call(os, system, Result).
% Result = error(module_not_allowed(os))
```

## TypeScript Whitelist Generation

### Generate Whitelist

```prolog
generate_typescript_whitelist(Code).
```

**Output:**
```typescript
/**
 * RPyC Security Whitelist
 * Generated by UnifyWeaver - DO NOT EDIT
 */

// Allowed modules and their functions
export const ALLOWED_MODULES: Record<string, Set<string>> = {
  math: new Set(["sqrt", "sin", "cos", "tan", "log", "exp", ...]),
  statistics: new Set(["mean", "median", "mode", ...]),
  numpy: new Set(["array", "zeros", "ones", ...]),
  json: new Set(["loads", "dumps"]),
  datetime: new Set(["now", "utcnow", "today", "fromisoformat"])
};

// Allowed module attributes
export const ALLOWED_ATTRS: Record<string, Set<string>> = {
  math: new Set(["pi", "e", "tau", "inf", "nan"]),
  numpy: new Set(["__version__", "pi", "e", "inf", "nan", "newaxis"])
};

// Check if a function call is allowed
export function isCallAllowed(module: string, func: string): boolean {
  const allowed = ALLOWED_MODULES[module];
  return allowed !== undefined && allowed.has(func);
}

// Check if an attribute access is allowed
export function isAttrAllowed(module: string, attr: string): boolean {
  const allowed = ALLOWED_ATTRS[module];
  return allowed !== undefined && allowed.has(attr);
}
```

### Generate Validator

```prolog
generate_typescript_validator(Code).
```

**Output:**
```typescript
/**
 * RPyC Call Validator
 */

import { isCallAllowed, isAttrAllowed } from './whitelist';

// Rate limiting configuration
export const RATE_LIMIT = {
  requestsPerSecond: 100,
  burstSize: 20,
  timeoutMs: 5000,
};

// Validation result type
export interface ValidationResult {
  valid: boolean;
  error?: string;
  sanitized?: {
    module: string;
    func?: string;
    attr?: string;
    args?: unknown[];
  };
}

// Validate a function call request
export function validateCall(
  module: unknown,
  func: unknown,
  args: unknown
): ValidationResult {
  // Type validation
  if (typeof module !== 'string') {
    return { valid: false, error: 'Module must be a string' };
  }
  // ... sanitization and whitelist checks
}
```

### Generate Combined Security Module

```prolog
generate_typescript_security(Code).
% Combines whitelist + validator
```

## Express Middleware Generation

```prolog
generate_express_security_middleware(Code).
```

**Output:**
```typescript
/**
 * Express Security Middleware for RPyC
 */

import { Request, Response, NextFunction } from 'express';
import { validateCall, validateAttr, RATE_LIMIT } from './validator';

// Rate limiting middleware
export function rateLimiter(req: Request, res: Response, next: NextFunction): void {
  const key = getRateLimitKey(req);
  const now = Date.now();
  // ... rate limit logic
  if (record.count > 100) {
    res.status(429).json({
      error: 'Rate limit exceeded',
      retryAfter: Math.ceil((record.resetTime - now) / 1000),
    });
    return;
  }
  next();
}

// Request timeout middleware
export function timeoutMiddleware(req: Request, res: Response, next: NextFunction): void {
  const timeout = setTimeout(() => {
    if (!res.headersSent) {
      res.status(408).json({ error: 'Request timeout' });
    }
  }, 5000);
  // ... cleanup
  next();
}

// Call validation middleware
export function validateCallMiddleware(req: Request, res: Response, next: NextFunction): void {
  const { module, func, args } = req.body;
  const result = validateCall(module, func, args);
  if (!result.valid) {
    res.status(400).json({ error: result.error });
    return;
  }
  (req as any).sanitized = result.sanitized;
  next();
}

// Combined security middleware stack
export const securityMiddleware = [
  rateLimiter,
  timeoutMiddleware,
];
```

## Rate Limiting

### Configure Rate Limits

```prolog
rpyc_rate_limit(config(
    requests_per_second(100),
    burst_size(20),
    timeout_ms(5000)
)).
```

### Get Config Values

```prolog
get_config_rate_limit(RateLimit).
get_config_timeout(Timeout).
```

### Generate with Config

```prolog
generate_typescript_whitelist_with_config(Code).
% Includes SECURITY_CONFIG object
```

## Firewall System

The `firewall.pl` module provides control plane security policies for backend and service usage.

### Firewall Policies

```prolog
% Predicate-specific firewall rules
rule_firewall(PredIndicator, PolicyTerms).

% Global default policy
firewall_default(PolicyTerms).
```

### Policy Terms

| Term | Description |
|------|-------------|
| `execution([backends])` | Whitelist of execution backends |
| `services([services])` | Whitelist of external services |
| `denied([targets])` | Blacklist (takes precedence) |
| `network_access(allowed\|denied)` | Control network access |
| `network_hosts([patterns])` | Whitelist of host patterns |
| `python_modules([modules])` | Whitelist of Python imports |
| `file_read_patterns([patterns])` | Allowed file read patterns |
| `file_write_patterns([patterns])` | Allowed file write patterns |
| `cache_dirs([dirs])` | Allowed cache directories |

### Examples

```prolog
% Deny LLM service for sensitive predicate
:- assertz(firewall:rule_firewall(sensitive_pred/2, [denied([llm])])).

% Allow only bash execution with SQL service
:- assertz(firewall:rule_firewall(db_query/2, [
    execution([bash]),
    services([sql])
])).

% Global default to deny LLM
:- assertz(firewall:firewall_default([denied([llm])])).

% Restrict network access to internal hosts
:- assertz(firewall:rule_firewall(api_call/2, [
    network_access(allowed),
    network_hosts(['*.internal.company.com', 'localhost'])
])).

% Restrict Python imports
:- assertz(firewall:rule_firewall(python_task/2, [
    python_modules([math, json, statistics])
])).
```

### Firewall Validation

```prolog
% Get policy for predicate
get_firewall_policy(ancestor/2, Firewall).

% Validate compilation request
validate_against_firewall(Target, Options, Firewall).

% Validate specific service
validate_service(python3, Firewall).

% Validate network access
validate_network_access(URL, Firewall).

% Validate Python imports
validate_python_imports(Code, Firewall).

% Validate file access
validate_file_access(File, read, Firewall).
validate_file_access(File, write, Firewall).
```

### Firewall Modes

```prolog
set_firewall_mode(Mode).
current_firewall_mode(Mode).
```

| Mode | Behavior |
|------|----------|
| `strict` | Violations block compilation (default) |
| `warn` | Allow with warning message |
| `permissive` | Allow without extra warning |
| `disabled` | Skip enforcement |

### Higher-Order Implications

The firewall supports logical inference for deriving policies.

```prolog
% Built-in default implications
firewall_implies_default(Condition, Consequence).

% User-defined implications
firewall_implies(Condition, Consequence).

% Disable specific implications
firewall_implies_disabled(Condition, Consequence).

% Derive policies from condition
derive_policy(Condition, Policies).
```

**Default Implications:**

| Condition | Consequence |
|-----------|-------------|
| `no_bash_available` | Deny bash service for PowerShell |
| `denied_target_language(bash)` | Deny bash service for all targets |
| `network_access(denied)` | Deny all network services |
| `security_policy(strict)` | Prefer built-ins over executables |
| `environment(restricted)` | Deny external service calls |
| `mode(offline)` | Deny all network access |
| `environment(termux)` | Allow alternative SSH port 8022 |
| `system_type(air_gapped)` | Complete network denial |

### Environment-Specific Policies

```prolog
% Corporate environment - internal hosts only
firewall_implies_default(environment(corporate),
    network_hosts(['*.internal.company.com', 'localhost'])).

% Development - localhost only
firewall_implies_default(environment(development),
    network_hosts(['localhost', '127.0.0.1', '*.local'])).

% CI/CD - test APIs only
firewall_implies_default(environment(ci),
    network_hosts(['*.test.*', 'localhost', 'mock.*'])).
```

## Input Sanitization

The validator performs input sanitization:

```typescript
// Sanitize module/function names (prevent injection)
const sanitizedModule = module.replace(/[^a-zA-Z0-9_]/g, '');
const sanitizedFunc = func.replace(/[^a-zA-Z0-9_]/g, '');

// Reject if sanitization changed the value
if (sanitizedModule !== module) {
  return { valid: false, error: `Invalid module name: ${module}` };
}

// Validate args are serializable
try {
  JSON.stringify(args);
} catch {
  return { valid: false, error: 'Args contain non-serializable values' };
}
```

## Integration with Preferences

```prolog
% Validate using both local rules and firewall
validate_with_firewall(Module, Function, Result).
```

## Common Patterns

### Secure Python Bridge

```prolog
% Define strict whitelist
rpyc_allowed_module(my_module, [safe_func1, safe_func2]).

% Generate security code
generate_typescript_security(TSCode).
generate_express_security_middleware(MiddlewareCode).
```

### Network-Restricted Service

```prolog
rule_firewall(external_api/2, [
    network_access(allowed),
    network_hosts(['api.trusted-service.com']),
    services([http]),
    denied([llm, file_write])
]).
```

### Sandboxed Execution

```prolog
rule_firewall(sandbox_task/2, [
    execution([python]),
    python_modules([math, json]),
    network_access(denied),
    file_read_patterns(['data/*.csv']),
    file_write_patterns([])  % No writes allowed
]).
```

### Progressive Security

```prolog
% Development: permissive
set_firewall_mode(permissive).

% Staging: warn on violations
set_firewall_mode(warn).

% Production: strict enforcement
set_firewall_mode(strict).
```

## Related

**Parent Skill:**
- `skill_gui_tools.md` - GUI master skill

**Sibling Skills:**
- `skill_accessibility.md` - ARIA, keyboard navigation

**Code:**
- `src/unifyweaver/glue/rpyc_security.pl` - RPyC whitelisting
- `src/unifyweaver/core/firewall.pl` - Control plane firewall
- `src/unifyweaver/core/firewall_v2.pl` - Extended firewall
