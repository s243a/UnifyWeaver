# Skill: WebAssembly

Compile Prolog to LLVM IR, then to WebAssembly for native-speed browser execution.

## When to Use

- User needs performance-critical client-side code
- User wants to compile algorithms to WASM
- User needs FFI with Go, Rust, or C
- User asks about LLVM compilation or tail-call optimization

## Quick Start

```prolog
:- use_module('src/unifyweaver/targets/llvm_target').

% Compile tail-recursive function with guaranteed O(1) stack
compile_tail_recursion_llvm(factorial/2, [export(true)], LLVMCode).

% Generate WebAssembly module
compile_wasm_module([factorial], [], WASMCode).

% Generate TypeScript bindings
generate_ts_bindings([factorial], TSCode).
```

## LLVM IR Generation

### Target Info

```prolog
target_info(llvm, info{
    name: "LLVM IR",
    file_extension: ".ll",
    features: [tail_call, native_speed, cross_platform, ffi],
    compile_command: "clang"
}).
```

### Initialize Target

```prolog
init_llvm_target.
```

## Compilation Functions

### Facts to LLVM

```prolog
compile_facts_to_llvm(Pred, Arity, Code).
```

Generates LLVM IR with string constants and count accessor.

### Tail Recursion

```prolog
compile_tail_recursion_llvm(Pred/Arity, Options, Code).
```

**Options:**
- `export(true)` - Generate extern C wrapper for FFI

**Output (factorial):**
```llvm
; Guaranteed O(1) stack space via musttail
define i64 @factorial(i64 %n, i64 %acc) {
entry:
  %cmp = icmp sle i64 %n, 0
  br i1 %cmp, label %base, label %recurse

base:
  ret i64 %acc

recurse:
  %n_minus_1 = sub i64 %n, 1
  %new_acc = mul i64 %acc, %n
  %result = musttail call i64 @factorial(i64 %n_minus_1, i64 %new_acc)
  ret i64 %result
}
```

The `musttail` annotation guarantees tail-call optimization.

### Linear Recursion

```prolog
compile_linear_recursion_llvm(Pred/Arity, Options, Code).
```

For Fibonacci-style recursion (with memoization).

### Transitive Closure

```prolog
compile_transitive_closure_llvm(Pred/Arity, Options, Code).
```

For graph traversal algorithms.

### Mutual Recursion

```prolog
compile_mutual_recursion_llvm(Predicates, Options, Code).
```

For mutually recursive predicates.

## WebAssembly Target

### Compile WASM Module

```prolog
compile_wasm_module(Functions, Options, Code).
```

```prolog
compile_wasm_module([factorial, fibonacci], [memory(256)], WASMCode).
```

### Build WASM Module

```prolog
build_wasm_module(LLFile, OutputName, Commands).
```

Returns shell commands to compile:

```bash
clang --target=wasm32 -O3 -nostdlib -Wl,--no-entry -Wl,--export-all \
  -o factorial.wasm factorial.ll
```

### WASM with String Support

```prolog
compile_wasm_string_module(Functions, Options, Code).
generate_wasm_string_runtime(RuntimeCode).
```

Includes memory allocation functions for string handling in WASM.

## JavaScript/TypeScript Bindings

### Generate JS Bindings

```prolog
generate_js_bindings(Functions, JSCode).
```

**Output:**
```javascript
class WasmModule {
  constructor() {
    this.instance = null;
  }

  async init(wasmUrl = './module.wasm') {
    const response = await fetch(wasmUrl);
    const buffer = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(buffer);
    this.instance = instance;
  }

  factorial(n) {
    return this.instance.exports.factorial_ext(n);
  }
}

export const wasmModule = new WasmModule();
```

### Generate TypeScript Bindings

```prolog
generate_ts_bindings(Functions, TSCode).
```

**Output:**
```typescript
interface WasmExports {
  factorial_ext: (n: number) => number;
}

class WasmModule {
  private instance: WebAssembly.Instance | null = null;

  async init(wasmUrl: string = './module.wasm'): Promise<void> {
    const response = await fetch(wasmUrl);
    const buffer = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(buffer);
    this.instance = instance;
  }

  factorial(n: number): number {
    if (!this.instance) throw new Error('Module not initialized');
    return (this.instance.exports as WasmExports).factorial_ext(n);
  }
}

export const wasmModule = new WasmModule();
```

### TypeScript String Bindings

```prolog
generate_ts_string_bindings(Functions, TSCode).
```

Includes encoder/decoder for string arguments.

## FFI (Foreign Function Interface)

### Generate C Header

```prolog
generate_c_header(Functions, HeaderCode).
```

**Output:**
```c
/* Generated by UnifyWeaver LLVM Target */
#ifndef MODULE_H
#define MODULE_H

#include <stdint.h>

int64_t factorial_ext(int64_t n);
int64_t fibonacci_ext(int64_t n);

#endif
```

### Generate Go Bindings (cgo)

```prolog
generate_cgo_bindings(Functions, GoCode).
```

**Output:**
```go
package module

/*
#cgo LDFLAGS: -L. -lmodule
#include "module.h"
*/
import "C"

func Factorial(n int64) int64 {
    return int64(C.factorial_ext(C.int64_t(n)))
}
```

### Generate Rust FFI

```prolog
generate_rust_ffi(Functions, RustCode).
```

**Output:**
```rust
#[link(name = "module")]
extern "C" {
    fn factorial_ext(n: i64) -> i64;
}

pub fn factorial(n: i64) -> i64 {
    unsafe { factorial_ext(n) }
}
```

## Build Shared Library

```prolog
compile_shared_library_llvm(Functions, Options, LLVMCode).
build_shared_library(LLFile, OutputName, Commands).
```

**Commands:**
```bash
clang -shared -fPIC -O3 -o libmodule.so module.ll
```

## File Output

```prolog
write_llvm_program(Code, Filename).
```

## Common Workflows

### Browser WASM Module

```prolog
% 1. Compile to LLVM IR
compile_tail_recursion_llvm(compute/2, [export(true)], LLVMCode).
write_llvm_program(LLVMCode, 'compute.ll').

% 2. Generate WASM
build_wasm_module('compute.ll', 'compute', BuildCmds).

% 3. Generate TypeScript bindings
generate_ts_bindings([compute], TSCode).
```

### Native Library for Go

```prolog
% 1. Compile to LLVM IR
compile_shared_library_llvm([factorial, fibonacci], [], LLVMCode).
write_llvm_program(LLVMCode, 'math.ll').

% 2. Generate C header
generate_c_header([factorial, fibonacci], Header).

% 3. Generate Go bindings
generate_cgo_bindings([factorial, fibonacci], GoCode).

% 4. Build shared library
build_shared_library('math.ll', 'math', BuildCmds).
```

### Graph Algorithm to WASM

```prolog
% 1. Compile transitive closure
compile_transitive_closure_llvm(reachable/2, [], LLVMCode).

% 2. Export graph data
generate_graph_data_export(edge/2, DataCode).

% 3. Combine and compile
build_wasm_module('graph.ll', 'graph', BuildCmds).

% 4. TypeScript bindings
generate_ts_bindings([reachable, get_edges], TSCode).
```

## Performance Considerations

### Tail-Call Optimization

Using `musttail` ensures:
- O(1) stack space
- No stack overflow for deep recursion
- Compiler-guaranteed optimization

### Memory Management

WASM modules have:
- Linear memory (configurable size)
- Manual allocation for strings
- No garbage collection (deterministic performance)

### Browser Compatibility

WebAssembly is supported in:
- Chrome 57+
- Firefox 52+
- Safari 11+
- Edge 16+

## Related

**Parent Skill:**
- `skill_gui_runtime.md` - GUI runtime sub-master

**Sibling Skills:**
- `skill_data_binding.md` - React binding
- `skill_browser_python.md` - Pyodide

**Code:**
- `src/unifyweaver/targets/llvm_target.pl` - LLVM compilation
- `src/unifyweaver/targets/llvm_bindings.pl` - LLVM bindings
