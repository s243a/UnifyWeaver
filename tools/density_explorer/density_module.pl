% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% density_module.pl - Density Manifold Explorer Generator
%
% Generates complete density visualization app from Prolog specifications.
% Uses Plotly.js for browser-based visualization.
%
% Pipeline: Prolog -> HTML + JavaScript (Plotly.js)
%
% Usage:
%   swipl -g "consult('density_module.pl'), density_module:generate_all" -t halt
%
% Output: generated/index.html (does NOT overwrite web/index.html)

:- encoding(utf8).

:- module(density_module, [
    % Configuration
    app_config/1,
    tab/3,
    control/4,
    checkbox/3,
    export_format/3,
    dataset/3,

    % Code generation
    generate_html/1,
    generate_all/0
]).

:- use_module(library(lists)).

%% ============================================
%% APPLICATION CONFIGURATION
%% ============================================

app_config([
    title("Density Manifold Explorer"),
    version("2.0"),
    description("Interactive visualization of embedding density manifolds"),
    theme(dark),
    accent_color('#e94560'),
    background('#1a1a2e'),
    sidebar_bg('#16213e'),
    border_color('#0f3460')
]).

%% ============================================
%% TAB DEFINITIONS
%% ============================================

% tab(Id, Label, IsDefault)
tab(view, "View", true).
tab(data, "Data", false).
tab(compute, "Compute", false).

%% ============================================
%% CONTROL DEFINITIONS
%% ============================================

% checkbox(Id, Label, DefaultChecked)
checkbox(showPoints, "Show Points", true).
checkbox(showPeaks, "Show Peaks", true).
checkbox(showContours, "Show Contours", true).
checkbox(showTree, "Show Tree", true).
checkbox(showArrows, "Show Arrows", false).
checkbox(showColorbar, "Show Density Scale", false).

% control(Tab, Type, Id, Options)
control(view, slider, maxDepth, [label("Max Depth"), min(1), max(20), default(10)]).
control(view, select, exportFormat, [label("Format"), options([
    option(vue, "VUE (.vue) - Open source concept map"),
    option(mm, "FreeMind (.mm) - Open source mindmap"),
    option(mermaid, "Mermaid (.md) - GitHub/GitLab/Obsidian"),
    option(opml, "OPML (.opml) - Outline format"),
    option(json, "JSON (.json) - Raw data")
])]).

control(data, select, datasetSelect, [label("Dataset"), options([
    option('data/physics.json', "Physics (pre-computed)"),
    option(demo, "Demo clusters (Pyodide)"),
    option(custom, "Custom URL...")
])]).

control(data, select, projectionMode, [label("Projection"), options([
    option(svd, "SVD (max variance)"),
    option(custom, "Custom axis")
])]).

control(compute, slider, bandwidth, [label("KDE Bandwidth"), min(0.01), max(1.0), step(0.01), default(0.1)]).
control(compute, slider, gridSize, [label("Grid Resolution"), min(50), max(200), step(10), default(100)]).
control(compute, slider, nPeaks, [label("Number of Peaks"), min(1), max(20), default(5)]).

%% ============================================
%% EXPORT FORMAT DEFINITIONS
%% ============================================

% export_format(Id, Label, Extension)
export_format(vue, "VUE Concept Map", ".vue").
export_format(mm, "FreeMind", ".mm").
export_format(mermaid, "Mermaid", ".md").
export_format(opml, "OPML Outline", ".opml").
export_format(json, "JSON", ".json").

%% ============================================
%% DATASET DEFINITIONS
%% ============================================

% dataset(Id, Label, Url)
dataset(physics, "Physics", "data/physics.json").
dataset(demo, "Demo Clusters", "demo").
dataset(custom, "Custom URL", "").

%% ============================================
%% MAIN GENERATION
%% ============================================

generate_all :-
    format('Generating density explorer...~n~n'),

    generate_html(HTMLCode),
    open('generated/index.html', write, S1),
    write(S1, HTMLCode),
    close(S1),
    format('  Created: generated/index.html~n'),

    format('~nDone! Open generated/index.html in a browser.~n'),
    format('Note: Original web/index.html is unchanged.~n').

%% ============================================
%% HTML GENERATION
%% ============================================

generate_html(Code) :-
    generate_css(CSS),
    generate_body(Body),
    generate_javascript(JS),
    app_config(Config),
    member(title(Title), Config),
    format(string(Code),
"<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
  <title>~w</title>
  <!-- Generated by UnifyWeaver density_module.pl -->
  <script src=\"https://cdn.plot.ly/plotly-2.27.0.min.js\"></script>
  <style>
~w
  </style>
</head>
<body>
~w
  <script>
~w
  </script>
</body>
</html>
", [Title, CSS, Body, JS]).

%% ============================================
%% CSS GENERATION
%% ============================================

generate_css(CSS) :-
    app_config(Config),
    member(accent_color(Accent), Config),
    member(background(Bg), Config),
    member(sidebar_bg(SidebarBg), Config),
    member(border_color(Border), Config),
    format(string(CSS),
"    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: ~w;
      color: #eee;
      min-height: 100vh;
    }
    .container { display: flex; height: 100vh; }
    .sidebar {
      width: 320px;
      background: ~w;
      padding: 20px;
      overflow-y: auto;
      border-right: 1px solid ~w;
    }
    .sidebar h1 {
      font-size: 1.4rem;
      margin-bottom: 20px;
      color: ~w;
    }
    .sidebar h2 {
      font-size: 0.9rem;
      margin: 20px 0 10px;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    .tab-buttons {
      display: flex;
      gap: 2px;
      margin-bottom: 15px;
      background: ~w;
      border-radius: 6px;
      padding: 3px;
    }
    .tab-btn {
      flex: 1;
      padding: 8px 10px;
      background: transparent;
      border: none;
      color: #94a3b8;
      font-size: 0.85rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s;
    }
    .tab-btn:hover { background: rgba(233, 69, 96, 0.2); color: #eee; }
    .tab-btn.active { background: ~w; color: #fff; }
    .tab-panel { display: none; }
    .tab-panel.active { display: block; }
    .control-group { margin-bottom: 15px; }
    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.85rem;
      color: #a0aec0;
    }
    .control-group input[type='range'] { width: 100%; accent-color: ~w; }
    .control-group select {
      width: 100%;
      padding: 8px;
      background: ~w;
      border: 1px solid ~w;
      color: #eee;
      border-radius: 4px;
    }
    .control-group .value { text-align: right; font-size: 0.85rem; color: ~w; }
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
    }
    .checkbox-group input[type='checkbox'] { accent-color: ~w; width: 18px; height: 18px; }
    button {
      width: 100%;
      padding: 12px;
      background: ~w;
      border: none;
      color: white;
      font-weight: bold;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 10px;
      transition: background 0.2s;
    }
    button:hover:not(:disabled) { filter: brightness(1.1); }
    button:disabled { background: #4a5568; cursor: not-allowed; }
    button.secondary { background: ~w; margin-top: 5px; }
    .main { flex: 1; display: flex; flex-direction: column; }
    #plot { flex: 1; min-height: 0; }
    .info-bar {
      padding: 10px 20px;
      background: ~w;
      display: flex;
      gap: 30px;
      border-top: 1px solid ~w;
      flex-wrap: wrap;
    }
    .info-item { display: flex; flex-direction: column; }
    .info-item .label { font-size: 0.75rem; color: #94a3b8; text-transform: uppercase; }
    .info-item .value { font-size: 1.1rem; color: ~w; font-weight: bold; }
    .status {
      padding: 10px 20px;
      background: ~w;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .peaks-list { margin-top: 10px; }
    .peak-item {
      padding: 8px 12px;
      background: ~w;
      border-radius: 4px;
      margin-bottom: 5px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .peak-item:hover { background: ~w; }
    .peak-item .name { color: ~w; }
    .peak-item .density { color: #94a3b8; font-size: 0.75rem; }
    .search-results { max-height: 150px; overflow-y: auto; margin-bottom: 10px; }
    .search-result {
      padding: 6px 8px;
      cursor: pointer;
      border-radius: 4px;
      font-size: 0.85rem;
      color: #94a3b8;
    }
    .search-result:hover { background: rgba(233, 69, 96, 0.2); color: #eee; }
    @media (max-width: 768px) {
      body { min-width: 150vw; overflow-x: auto; }
      .container { min-width: 150vw; }
      .sidebar { width: 280px; }
    }",
    [Bg, SidebarBg, Border, Accent, Border, Accent, Accent, Bg, Border, Accent, Accent, Accent, Border, SidebarBg, Border, Accent, Border, Bg, Border, Accent]).

%% ============================================
%% BODY GENERATION
%% ============================================

generate_body(Body) :-
    app_config(Config),
    member(title(Title), Config),
    generate_tabs_html(TabsHTML),
    generate_view_tab(ViewTab),
    generate_data_tab(DataTab),
    generate_compute_tab(ComputeTab),
    format(string(Body),
"  <div class=\"container\">
    <div class=\"sidebar\">
      <h1>~w</h1>
      <div id=\"modeIndicator\" style=\"padding:8px 12px;background:#0f3460;border-radius:4px;margin-bottom:15px;font-size:0.85rem;text-align:center;\">
        Loading...
      </div>
      <div class=\"tab-buttons\">
~w
      </div>
~w
~w
~w
    </div>
    <div class=\"main\">
      <div id=\"plot\"></div>
      <div class=\"info-bar\">
        <div class=\"info-item\"><span class=\"label\">Points</span><span class=\"value\" id=\"infoPoints\">-</span></div>
        <div class=\"info-item\"><span class=\"label\">Grid</span><span class=\"value\" id=\"infoGrid\">-</span></div>
        <div class=\"info-item\"><span class=\"label\">Bandwidth</span><span class=\"value\" id=\"infoBandwidth\">-</span></div>
        <div class=\"info-item\"><span class=\"label\">Peaks</span><span class=\"value\" id=\"infoPeaks\">-</span></div>
      </div>
      <div class=\"status\" id=\"status\">Ready</div>
    </div>
  </div>", [Title, TabsHTML, ViewTab, DataTab, ComputeTab]).

generate_tabs_html(HTML) :-
    findall(TabHTML, (
        tab(Id, Label, IsDefault),
        (IsDefault -> Class = "tab-btn active" ; Class = "tab-btn"),
        format(string(TabHTML), "        <button class=\"~w\" data-tab=\"~w\">~w</button>", [Class, Id, Label])
    ), TabHTMLs),
    atomic_list_concat(TabHTMLs, '\n', HTML).

generate_view_tab(HTML) :-
    generate_checkboxes_html(CheckboxesHTML),
    format(string(HTML),
"      <div class=\"tab-panel active\" id=\"tab-view\">
        <h2>Search</h2>
        <div class=\"control-group\">
          <input type=\"text\" id=\"nodeSearch\" placeholder=\"Search nodes...\" style=\"width:100%;padding:8px;background:#1a1a2e;border:1px solid #0f3460;color:#eee;border-radius:4px;\">
        </div>
        <div id=\"searchResults\" class=\"search-results\"></div>
        <h2>Display</h2>
~w
        <h2>Tree</h2>
        <div class=\"control-group\">
          <label>Max Depth: <span class=\"value\" id=\"maxDepthValue\">10</span></label>
          <input type=\"range\" id=\"maxDepth\" min=\"1\" max=\"20\" value=\"10\">
        </div>
        <h2>Peaks</h2>
        <div class=\"peaks-list\" id=\"peaksList\"></div>
        <h2>Export</h2>
        <button class=\"secondary\" id=\"exportBtn\">Export Mindmap</button>
      </div>", [CheckboxesHTML]).

generate_data_tab(HTML) :-
    HTML = "      <div class=\"tab-panel\" id=\"tab-data\">
        <h2>Dataset</h2>
        <div class=\"control-group\">
          <select id=\"datasetSelect\">
            <option value=\"data/physics.json\">Physics (pre-computed)</option>
            <option value=\"demo\">Demo clusters</option>
            <option value=\"custom\">Custom URL...</option>
          </select>
        </div>
        <h2>Projection</h2>
        <div class=\"control-group\">
          <select id=\"projectionMode\">
            <option value=\"svd\">SVD (max variance)</option>
            <option value=\"custom\">Custom axis</option>
          </select>
        </div>
        <button id=\"loadDataBtn\">Load Dataset</button>
      </div>".

generate_compute_tab(HTML) :-
    HTML = "      <div class=\"tab-panel\" id=\"tab-compute\">
        <h2>Density Settings</h2>
        <div class=\"control-group\">
          <label>KDE Bandwidth: <span class=\"value\" id=\"bandwidthValue\">0.1</span></label>
          <input type=\"range\" id=\"bandwidth\" min=\"0.01\" max=\"1\" step=\"0.01\" value=\"0.1\">
        </div>
        <div class=\"control-group\">
          <label>Grid Resolution: <span class=\"value\" id=\"gridSizeValue\">100</span></label>
          <input type=\"range\" id=\"gridSize\" min=\"50\" max=\"200\" step=\"10\" value=\"100\">
        </div>
        <div class=\"control-group\">
          <label>Number of Peaks: <span class=\"value\" id=\"nPeaksValue\">5</span></label>
          <input type=\"range\" id=\"nPeaks\" min=\"1\" max=\"20\" value=\"5\">
        </div>
        <button id=\"recomputeBtn\">Recompute Density</button>
      </div>".

generate_checkboxes_html(HTML) :-
    findall(CbHTML, (
        checkbox(Id, Label, Checked),
        (Checked -> CheckedAttr = " checked" ; CheckedAttr = ""),
        format(string(CbHTML), "        <div class=\"checkbox-group\"><input type=\"checkbox\" id=\"~w\"~w><label for=\"~w\">~w</label></div>", [Id, CheckedAttr, Id, Label])
    ), CbHTMLs),
    atomic_list_concat(CbHTMLs, '\n', HTML).

%% ============================================
%% JAVASCRIPT GENERATION
%% ============================================

generate_javascript(JS) :-
    app_config(Config),
    member(accent_color(Accent), Config),
    format(string(JS),
"    // Density Manifold Explorer - Generated by UnifyWeaver
    let plotData = null;
    let currentTree = null;
    const accentColor = '~w';

    // Demo data for testing
    const demoData = generateDemoData();

    function generateDemoData() {
      const points = [];
      const n = 200;
      // Generate 3 clusters
      for (let c = 0; c < 3; c++) {
        const cx = (c - 1) * 3;
        const cy = Math.sin(c * 2) * 2;
        for (let i = 0; i < n/3; i++) {
          points.push({
            x: cx + (Math.random() - 0.5) * 2,
            y: cy + (Math.random() - 0.5) * 2,
            title: `Cluster ${c+1} Point ${i+1}`,
            id: `c${c}_p${i}`
          });
        }
      }
      return {
        points,
        density_grid: computeDensityGrid(points, 0.3, 50),
        peaks: findPeaks(points, 5),
        tree: buildMST(points)
      };
    }

    function computeDensityGrid(points, bandwidth, gridSize) {
      const xs = points.map(p => p.x);
      const ys = points.map(p => p.y);
      const xMin = Math.min(...xs) - 1, xMax = Math.max(...xs) + 1;
      const yMin = Math.min(...ys) - 1, yMax = Math.max(...ys) + 1;
      const values = [];
      for (let j = 0; j < gridSize; j++) {
        const row = [];
        for (let i = 0; i < gridSize; i++) {
          const x = xMin + (xMax - xMin) * i / (gridSize - 1);
          const y = yMin + (yMax - yMin) * j / (gridSize - 1);
          let density = 0;
          points.forEach(p => {
            const d2 = (x - p.x)**2 + (y - p.y)**2;
            density += Math.exp(-d2 / (2 * bandwidth**2));
          });
          row.push(density);
        }
        values.push(row);
      }
      return { values, xMin, xMax, yMin, yMax, gridSize, bandwidth };
    }

    function findPeaks(points, n) {
      // Simple: return points with highest local density
      return points.slice(0, n).map((p, i) => ({
        ...p,
        density: 1 - i * 0.1,
        rank: i + 1
      }));
    }

    function buildMST(points) {
      // Simple tree: connect points in order
      const nodes = points.map((p, i) => ({ ...p, depth: Math.min(i, 10) }));
      const edges = [];
      for (let i = 1; i < Math.min(points.length, 50); i++) {
        edges.push({ source: points[i-1].id, target: points[i].id });
      }
      return { nodes, edges, root_id: points[0].id };
    }

    function isLandscape() {
      return window.innerWidth > window.innerHeight;
    }

    function getColorbarConfig() {
      if (isLandscape()) {
        // Vertical on far right for landscape
        return {
          orientation: 'v',
          x: 1.01,
          xanchor: 'left',
          y: 0.5,
          yanchor: 'middle',
          len: 0.9,
          thickness: 20,
          title: { text: 'Density', side: 'right' },
          tickfont: { size: 10 }
        };
      } else {
        // Horizontal at bottom for portrait
        return {
          orientation: 'h',
          y: -0.12,
          x: 0.5,
          xanchor: 'center',
          len: 0.9,
          thickness: 15,
          title: { text: 'Density', side: 'top' },
          tickfont: { size: 10 }
        };
      }
    }

    function getMarginConfig() {
      const showColorbar = document.getElementById('showColorbar')?.checked;
      if (isLandscape()) {
        // Minimal margins in landscape, colorbar outside plot area
        return { l: 10, r: showColorbar ? 60 : 10, t: 30, b: 30 };
      } else {
        return { l: 30, r: 10, t: 30, b: showColorbar ? 80 : 30 };
      }
    }

    function init() {
      setupEventListeners();
      loadData(demoData);
      document.getElementById('modeIndicator').textContent = 'Demo Mode';
      document.getElementById('modeIndicator').style.background = '#27ae60';
    }

    function setupEventListeners() {
      // Tabs
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
          document.querySelectorAll('.tab-panel').forEach(p => p.classList.remove('active'));
          btn.classList.add('active');
          document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
        });
      });

      // Sliders
      ['maxDepth', 'bandwidth', 'gridSize', 'nPeaks'].forEach(id => {
        const el = document.getElementById(id);
        const val = document.getElementById(id + 'Value');
        if (el && val) {
          el.addEventListener('input', () => { val.textContent = el.value; });
        }
      });

      // Checkboxes
      ['showPoints', 'showPeaks', 'showContours', 'showTree', 'showColorbar'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('change', () => updatePlot());
      });

      // Search
      document.getElementById('nodeSearch')?.addEventListener('input', handleSearch);

      // Orientation change - force complete re-render
      let resizeTimeout;
      let lastWidth = window.innerWidth;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          // Only re-render if width changed significantly (orientation change)
          if (Math.abs(window.innerWidth - lastWidth) > 100) {
            lastWidth = window.innerWidth;
            const plotEl = document.getElementById('plot');
            if (plotEl && plotData) {
              // Purge and re-create plot to force proper sizing
              Plotly.purge(plotEl);
              updatePlot();
            }
          }
        }, 150);
      });

      // Buttons
      document.getElementById('recomputeBtn')?.addEventListener('click', recompute);
      document.getElementById('exportBtn')?.addEventListener('click', exportMindmap);
    }

    function loadData(data) {
      plotData = data;
      updatePlot();
      updateInfo();
      updatePeaksList();
    }

    function updatePlot() {
      if (!plotData) return;

      const traces = [];
      const grid = plotData.density_grid;

      // Heatmap
      traces.push({
        type: 'heatmap',
        z: grid.values,
        x: Array.from({length: grid.gridSize}, (_, i) => grid.xMin + (grid.xMax - grid.xMin) * i / (grid.gridSize - 1)),
        y: Array.from({length: grid.gridSize}, (_, i) => grid.yMin + (grid.yMax - grid.yMin) * i / (grid.gridSize - 1)),
        colorscale: 'Viridis',
        showscale: document.getElementById('showColorbar')?.checked || false,
        colorbar: getColorbarConfig(),
        opacity: 0.8,
        hoverinfo: 'skip'
      });

      // Contours
      if (document.getElementById('showContours')?.checked) {
        traces.push({
          type: 'contour',
          z: grid.values,
          x: Array.from({length: grid.gridSize}, (_, i) => grid.xMin + (grid.xMax - grid.xMin) * i / (grid.gridSize - 1)),
          y: Array.from({length: grid.gridSize}, (_, i) => grid.yMin + (grid.yMax - grid.yMin) * i / (grid.gridSize - 1)),
          showscale: false,
          contours: { coloring: 'lines' },
          line: { width: 1, color: 'white' },
          opacity: 0.5,
          hoverinfo: 'skip'
        });
      }

      // Tree
      const maxDepth = parseInt(document.getElementById('maxDepth')?.value || 10);
      if (document.getElementById('showTree')?.checked && plotData.tree) {
        plotData.tree.edges.forEach(edge => {
          const source = plotData.tree.nodes.find(n => n.id === edge.source);
          const target = plotData.tree.nodes.find(n => n.id === edge.target);
          if (source && target && target.depth <= maxDepth) {
            traces.push({
              type: 'scatter',
              x: [source.x, target.x],
              y: [source.y, target.y],
              mode: 'lines',
              line: { color: 'cyan', width: 1 },
              opacity: 0.6,
              hoverinfo: 'skip',
              showlegend: false
            });
          }
        });
      }

      // Points
      if (document.getElementById('showPoints')?.checked) {
        traces.push({
          type: 'scatter',
          x: plotData.points.map(p => p.x),
          y: plotData.points.map(p => p.y),
          mode: 'markers',
          marker: { size: 6, color: 'red', opacity: 0.7 },
          text: plotData.points.map(p => p.title),
          hoverinfo: 'text',
          name: 'Points'
        });
      }

      // Peaks
      if (document.getElementById('showPeaks')?.checked && plotData.peaks) {
        traces.push({
          type: 'scatter',
          x: plotData.peaks.map(p => p.x),
          y: plotData.peaks.map(p => p.y),
          mode: 'markers+text',
          marker: { size: 12, color: 'yellow', symbol: 'star' },
          text: plotData.peaks.map(p => p.title.substring(0, 15)),
          textposition: 'top center',
          textfont: { size: 10, color: 'white' },
          hoverinfo: 'text',
          hovertext: plotData.peaks.map(p => p.title + ' (d=' + p.density.toFixed(2) + ')'),
          name: 'Peaks'
        });
      }

      const layout = {
        title: 'Density Manifold',
        xaxis: { scaleanchor: 'y', scaleratio: 1, fixedrange: false },
        yaxis: { fixedrange: false },
        paper_bgcolor: '#1a1a2e',
        plot_bgcolor: '#1a1a2e',
        font: { color: '#eee' },
        showlegend: true,
        legend: { x: 0, y: 1, bgcolor: 'rgba(0,0,0,0.5)' },
        margin: getMarginConfig(),
        dragmode: 'pan'
      };

      const config = {
        responsive: true,
        scrollZoom: true,
        displayModeBar: true,
        modeBarButtonsToAdd: ['zoom2d', 'pan2d', 'resetScale2d'],
        doubleClick: 'reset'
      };

      Plotly.react('plot', traces, layout, config);
    }

    function updateInfo() {
      if (!plotData) return;
      document.getElementById('infoPoints').textContent = plotData.points.length;
      document.getElementById('infoGrid').textContent = plotData.density_grid.gridSize + 'x' + plotData.density_grid.gridSize;
      document.getElementById('infoBandwidth').textContent = plotData.density_grid.bandwidth.toFixed(2);
      document.getElementById('infoPeaks').textContent = plotData.peaks?.length || 0;
    }

    function updatePeaksList() {
      const list = document.getElementById('peaksList');
      if (!list || !plotData?.peaks) return;
      list.innerHTML = plotData.peaks.map(p =>
        '<div class=\"peak-item\"><span class=\"name\">' + p.title + '</span><br><span class=\"density\">Density: ' + p.density.toFixed(3) + '</span></div>'
      ).join('');
    }

    function handleSearch() {
      const query = document.getElementById('nodeSearch').value.toLowerCase();
      const results = document.getElementById('searchResults');
      if (!query || !plotData) { results.innerHTML = ''; return; }

      const matches = plotData.points.filter(p => p.title.toLowerCase().includes(query)).slice(0, 10);
      results.innerHTML = matches.map(p =>
        '<div class=\"search-result\" onclick=\"centerOnPoint(\\'' + p.id + '\\')\">'+p.title+'</div>'
      ).join('');
    }

    function centerOnPoint(id) {
      const point = plotData?.points.find(p => p.id === id);
      if (!point) return;
      Plotly.relayout('plot', {
        'xaxis.range': [point.x - 2, point.x + 2],
        'yaxis.range': [point.y - 2, point.y + 2]
      });
    }

    function recompute() {
      if (!plotData) return;
      const bandwidth = parseFloat(document.getElementById('bandwidth').value);
      const gridSize = parseInt(document.getElementById('gridSize').value);
      const nPeaks = parseInt(document.getElementById('nPeaks').value);

      document.getElementById('status').textContent = 'Computing...';
      setTimeout(() => {
        plotData.density_grid = computeDensityGrid(plotData.points, bandwidth, gridSize);
        plotData.peaks = findPeaks(plotData.points, nPeaks);
        updatePlot();
        updateInfo();
        updatePeaksList();
        document.getElementById('status').textContent = 'Ready';
      }, 100);
    }

    function exportMindmap() {
      if (!plotData?.tree) return;
      const data = JSON.stringify({
        nodes: plotData.tree.nodes,
        edges: plotData.tree.edges,
        root: plotData.tree.root_id
      }, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'density_mindmap.json';
      a.click();
    }

    init();", [Accent]).

% Run with: swipl -g "consult('density_module.pl'), density_module:generate_all" -t halt
