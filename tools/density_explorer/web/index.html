<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Density Manifold Explorer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="ml-backend.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            background: #16213e;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #0f3460;
        }

        .sidebar h1 {
            font-size: 1.4rem;
            margin-bottom: 20px;
            color: #e94560;
        }

        .sidebar h2 {
            font-size: 1rem;
            margin: 20px 0 10px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sidebar h2:first-child {
            margin-top: 0;
        }

        /* Tabs */
        .tab-container {
            display: flex;
            flex-direction: column;
            flex: 1;
            min-height: 0;
        }

        .tab-buttons {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            background: #0f3460;
            border-radius: 6px;
            padding: 3px;
        }

        .tab-btn {
            flex: 1;
            padding: 8px 10px;
            background: transparent;
            border: none;
            color: #94a3b8;
            font-size: 0.8rem;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            background: rgba(233, 69, 96, 0.2);
            color: #eee;
        }

        .tab-btn.active {
            background: #e94560;
            color: #fff;
        }

        .tab-panel {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .tab-panel.active {
            display: block;
        }

        /* Search results */
        .search-results {
            max-height: 150px;
            overflow-y: auto;
            margin-bottom: 10px;
        }

        .search-result {
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
            color: #94a3b8;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .search-result:hover {
            background: rgba(233, 69, 96, 0.2);
            color: #eee;
        }

        .search-result.selected {
            background: #e94560;
            color: #fff;
        }

        .search-no-results {
            font-size: 0.8rem;
            color: #666;
            padding: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.85rem;
            color: #a0aec0;
        }

        .control-group input[type="range"] {
            width: 100%;
            accent-color: #e94560;
        }

        .control-group input[type="range"]:disabled {
            opacity: 0.5;
        }

        .control-group select {
            width: 100%;
            padding: 8px;
            background: #1a1a2e;
            border: 1px solid #0f3460;
            color: #eee;
            border-radius: 4px;
        }

        .control-group .value {
            text-align: right;
            font-size: 0.85rem;
            color: #e94560;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .checkbox-group input[type="checkbox"] {
            accent-color: #e94560;
            width: 18px;
            height: 18px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #e94560;
            border: none;
            color: white;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
            transition: background 0.2s;
        }

        button:hover:not(:disabled) {
            background: #ff6b6b;
        }

        button:disabled {
            background: #4a5568;
            cursor: not-allowed;
        }

        button.secondary {
            background: #0f3460;
            margin-top: 5px;
        }

        button.secondary:hover:not(:disabled) {
            background: #1a4a7a;
        }

        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        #plot {
            flex: 1;
            min-height: 0;
        }

        .info-bar {
            padding: 10px 20px;
            background: #16213e;
            display: flex;
            gap: 30px;
            border-top: 1px solid #0f3460;
            flex-wrap: wrap;
        }

        .info-item {
            display: flex;
            flex-direction: column;
        }

        .info-item .label {
            font-size: 0.75rem;
            color: #94a3b8;
            text-transform: uppercase;
        }

        .info-item .value {
            font-size: 1.1rem;
            color: #e94560;
            font-weight: bold;
        }

        .status {
            padding: 10px 20px;
            background: #0f3460;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status.loading {
            background: #e94560;
        }

        .status.error {
            background: #c0392b;
        }

        .pyodide-status {
            font-size: 0.8rem;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }

        .pyodide-status.ready {
            background: #27ae60;
        }

        .pyodide-status.loading {
            background: #f39c12;
        }

        .peaks-list {
            margin-top: 20px;
        }

        .peak-item {
            padding: 8px 12px;
            background: #1a1a2e;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        .peak-item:hover {
            background: #0f3460;
        }

        .peak-item .name {
            color: #e94560;
        }

        .peak-item .density {
            color: #94a3b8;
            font-size: 0.75rem;
        }

        .mode-indicator {
            padding: 8px 12px;
            background: #0f3460;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 0.85rem;
            text-align: center;
        }

        .mode-indicator.interactive {
            background: #27ae60;
        }

        .tree-toggle {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tree-toggle button {
            flex: 1;
            padding: 8px;
            font-size: 0.85rem;
            margin: 0;
        }

        .tree-toggle button.active {
            background: #e94560;
        }

        .tree-toggle button:not(.active) {
            background: #0f3460;
        }

        /* Loading overlay - only for initial load */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #0f3460;
            border-top-color: #e94560;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div class="loading-text" id="loadingText">Loading visualization...</div>
    </div>

    <div class="container">
        <div class="sidebar">
            <h1>Density Manifold Explorer</h1>

            <div class="mode-indicator" id="modeIndicator">
                Static Mode - Loading Pyodide...
            </div>

            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-btn active" data-tab="view">View</button>
                    <button class="tab-btn" data-tab="data">Data</button>
                    <button class="tab-btn" data-tab="compute">Compute</button>
                </div>

                <!-- VIEW TAB -->
                <div class="tab-panel active" id="tab-view">
                    <h2>Search</h2>
                    <div class="control-group">
                        <input type="text" id="nodeSearch" placeholder="Search nodes..." style="width:100%; padding:8px; background:#1a1a2e; border:1px solid #0f3460; color:#eee; border-radius:4px;">
                    </div>
                    <div id="searchResults" class="search-results"></div>

                    <h2>Display</h2>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showPoints" checked>
                        <label for="showPoints">Show Points</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showPeaks" checked>
                        <label for="showPeaks">Show Peaks</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showContours" checked>
                        <label for="showContours">Show Contours</label>
                    </div>

                    <h2>Tree Overlay</h2>
                    <div class="tree-toggle" id="treeToggle">
                        <!-- Populated dynamically based on available trees -->
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showTree" checked>
                        <label for="showTree">Show Tree</label>
                    </div>

                    <div class="checkbox-group">
                        <input type="checkbox" id="showArrows">
                        <label for="showArrows">Show Arrows</label>
                    </div>

                    <div class="control-group" id="arrowModeGroup" style="display: none;">
                        <label for="arrowMode">Arrow Mode</label>
                        <select id="arrowMode">
                            <option value="hierarchical">Hierarchical (general → specific)</option>
                            <option value="radial">Radial (away from root)</option>
                        </select>
                    </div>

                    <div class="control-group">
                        <label for="maxDepth">Max Depth: <span class="value" id="maxDepthValue">10</span></label>
                        <input type="range" id="maxDepth" min="1" max="20" value="10">
                    </div>
                    <div class="control-group">
                        <label for="maxBranching">Max Branching: <span class="value" id="maxBranchingValue">10</span></label>
                        <input type="range" id="maxBranching" min="2" max="20" value="10">
                    </div>

                    <div class="control-group" id="rootNodeGroup">
                        <label>Root Node</label>
                        <div style="font-size: 0.85rem; color: #94a3b8; margin-bottom: 8px;">
                            Click a node to select, then set as root
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
                            <span id="selectedNodeLabel" style="color: #e94560; flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">None selected</span>
                        </div>
                        <div style="display: flex; gap: 8px;">
                            <button class="secondary" id="setRootBtn" disabled style="flex: 1;">Set as Root</button>
                            <button class="secondary" id="resetRootBtn" style="flex: 1;">Reset</button>
                        </div>
                    </div>

                    <h2>Peaks</h2>
                    <div class="peaks-list" id="peaksList"></div>

                    <h2>Export</h2>
                    <div class="control-group">
                        <label for="exportFormat">Format</label>
                        <select id="exportFormat">
                            <option value="vue">VUE (.vue) - Open source concept map</option>
                            <option value="mm">FreeMind (.mm) - Open source mindmap</option>
                            <option value="mermaid">Mermaid (.md) - GitHub/GitLab/Obsidian</option>
                            <option value="opml">OPML (.opml) - Outline format</option>
                            <option value="graphml">GraphML (.graphml) - For yEd/Gephi</option>
                            <option value="smmx">SimpleMind (.smmx)</option>
                            <option value="json">JSON (.json) - Raw data</option>
                        </select>
                    </div>
                    <button class="secondary" id="exportMindmapBtn">Export Mindmap</button>
                    <div style="font-size: 0.8rem; color: #94a3b8; margin-top: 8px;">
                        Exports current tree view with max depth filter applied
                    </div>
                </div>

                <!-- DATA TAB -->
                <div class="tab-panel" id="tab-data">
                    <h2>Dataset</h2>
                    <div class="control-group">
                        <select id="datasetSelect">
                            <option value="data/physics.json">Physics (pre-computed)</option>
                            <option value="demo">Recompute (Pyodide)</option>
                            <option value="flask-api">Flask API (server)</option>
                            <option value="custom">Custom URL...</option>
                        </select>
                    </div>
                    <div class="control-group" id="customUrlGroup" style="display: none;">
                        <label for="customUrl">JSON URL</label>
                        <input type="text" id="customUrl" placeholder="https://..." style="width:100%; padding:8px; background:#1a1a2e; border:1px solid #0f3460; color:#eee; border-radius:4px;">
                        <button class="secondary" id="loadCustomBtn" style="margin-top:5px;">Load</button>
                    </div>

                    <!-- Flask API Configuration -->
                    <div id="flaskApiGroup" style="display: none;">
                        <div class="control-group">
                            <label for="flaskApiUrl">API URL</label>
                            <input type="text" id="flaskApiUrl" value="http://127.0.0.1:5000" style="width:100%; padding:8px; background:#1a1a2e; border:1px solid #0f3460; color:#eee; border-radius:4px;">
                        </div>
                        <div class="control-group">
                            <label for="flaskDataset">Data Subset</label>
                            <select id="flaskDataset" style="width:100%;">
                                <option value="wikipedia_physics_nomic">Wikipedia Physics (Nomic, 300)</option>
                                <option value="wikipedia_physics_nomic_titles">Wikipedia Physics (Titles v1.5, 300)</option>
                                <option value="wikipedia_physics_nomic_text">Wikipedia Physics (Text v1.5, 300)</option>
                                <option value="wikipedia_physics_articles">Wikipedia Physics (Articles, 200)</option>
                                <option value="wikipedia_physics">Wikipedia Physics (Categories, 2198)</option>
                                <option value="pearltrees_nomic_routing">Pearltrees Routing</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="flaskModel">Projection Model</label>
                            <select id="flaskModel" style="width:100%;">
                                <option value="">None (raw embeddings)</option>
                                <option value="bivector_paired" selected>Bivector Paired</option>
                                <option value="bivector_bias_shared">Bivector + Shared Bias</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="flaskProjectionMode">2D Projection Mode</label>
                            <select id="flaskProjectionMode" style="width:100%;">
                                <option value="embedding" id="embeddingModeOption">Embedding Space (semantic similarity)</option>
                                <option value="weights">Weight Space (transformation recipes)</option>
                                <option value="learned">Learned Metric (organizational structure)</option>
                                <option value="wikipedia_physics">Wikipedia Physics (trained hierarchy)</option>
                                <option value="wikipedia_physics_mds">Wikipedia Physics (MDS - distance faithful)</option>
                            </select>
                        </div>
                        <div class="control-group" id="layoutDatasetGroup" style="display:none;">
                            <label for="flaskLayoutDataset">2D Layout Dataset <span style="font-size:0.75rem; color:#94a3b8;">(override for SVD layout)</span></label>
                            <select id="flaskLayoutDataset" style="width:100%;">
                                <option value="">(Same as Data Subset)</option>
                                <option value="wikipedia_physics_nomic">Nomic 300 (unknown provenance)</option>
                                <option value="wikipedia_physics_nomic_titles">Titles v1.5 (300)</option>
                                <option value="wikipedia_physics_nomic_text">Text v1.5 (300)</option>
                                <option value="wikipedia_physics_articles">Articles 200</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="flaskTreeMetric">Tree Distance Metric</label>
                            <select id="flaskTreeMetric" style="width:100%;">
                                <option value="embedding">Embedding (semantic links)</option>
                                <option value="weights">Weights (hierarchical links)</option>
                                <option value="learned">Learned (organizational proximity)</option>
                                <option value="wikipedia_physics">Wikipedia Physics (trained hierarchy)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="flaskTreeType">Tree Algorithm</label>
                            <select id="flaskTreeType" style="width:100%;">
                                <option value="mst">MST (global minimum spanning)</option>
                                <option value="j-guided">J-Guided (BFS from central)</option>
                                <option value="density-greedy">Density Greedy (hubs from dense regions)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="flaskTopK">Max Points</label>
                            <input type="number" id="flaskTopK" value="200" min="10" max="10000" style="width:100%; padding:8px; background:#1a1a2e; border:1px solid #0f3460; color:#eee; border-radius:4px;">
                        </div>
                        <div class="control-group">
                            <label for="flaskBandwidth">Kernel Width <span style="font-size:0.75rem; color:#94a3b8;">(blank = auto)</span></label>
                            <input type="text" id="flaskBandwidth" value="" placeholder="auto (Scott's rule)" style="width:100%; padding:8px; background:#1a1a2e; border:1px solid #0f3460; color:#eee; border-radius:4px;">
                        </div>
                        <button class="secondary" id="loadFlaskBtn" style="margin-top:5px;">Load from API</button>
                        <div id="flaskApiStatus" style="font-size: 0.8rem; color: #94a3b8; margin-top: 5px;"></div>
                    </div>

                    <h2>Projection</h2>
                    <div class="control-group">
                        <select id="projectionMode">
                            <option value="svd">SVD (max variance)</option>
                            <option value="custom">Custom axis</option>
                        </select>
                    </div>
                    <div id="customProjectionPanel" style="display: none;">
                        <div class="projection-instruction" style="font-size: 0.8rem; color: #94a3b8; margin-bottom: 10px;">
                            Click two points to define X-axis
                        </div>
                        <div class="control-group">
                            <label>Axis Start: <span id="axisStartLabel" style="color: #e94560;">-</span></label>
                        </div>
                        <div class="control-group">
                            <label>Axis End: <span id="axisEndLabel" style="color: #e94560;">-</span></label>
                        </div>
                        <button class="secondary" id="clearAxisBtn">Clear Selection</button>
                        <button class="secondary" id="applyProjectionBtn" disabled>Apply Projection</button>
                    </div>

                    <h2>Embeddings</h2>
                    <div id="embeddingsSection">
                        <div class="control-group">
                            <label for="layoutEmbeddingSelect">Layout (2D projection)</label>
                            <select id="layoutEmbeddingSelect">
                                <option value="current">Current (from dataset)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="treeEmbeddingSelect">Tree (distance calc)</label>
                            <select id="treeEmbeddingSelect">
                                <option value="current">Current (from dataset)</option>
                            </select>
                        </div>
                        <div class="control-group" style="font-size: 0.8rem; color: #94a3b8;">
                            Layout: <span id="layoutEmbeddingLabel">MiniLM (384D)</span><br>
                            Tree: <span id="treeEmbeddingLabel">MiniLM (384D)</span>
                        </div>
                        <div id="embeddingLoadingStatus" style="font-size: 0.8rem; color: #e94560; display: none;">
                            Loading embeddings...
                        </div>
                        <div id="embeddingsFlaskNote" style="display: none; font-size: 0.8rem; color: #f39c12; margin-top: 5px;">
                            ℹ️ Load static data first, then Flask API will use your selected embeddings.
                        </div>
                    </div>
                </div>

                <!-- COMPUTE TAB -->
                <div class="tab-panel" id="tab-compute">
                    <h2>Pyodide Computation</h2>
                    <div class="control-group">
                        <label for="nPoints">Points: <span class="value" id="nPointsValue">200</span></label>
                        <input type="range" id="nPoints" min="50" max="500" value="200" step="50" disabled>
                    </div>

                    <div class="control-group">
                        <label for="bandwidth">Kernel Width: <span class="value" id="bandwidthValue">0.10</span></label>
                        <input type="range" id="bandwidth" min="0.01" max="1.0" value="0.1" step="0.01" disabled>
                    </div>

                    <div class="control-group">
                        <label for="gridSize">Grid Size: <span class="value" id="gridSizeValue">100</span></label>
                        <input type="range" id="gridSize" min="50" max="200" value="100" step="10" disabled>
                    </div>

                    <button id="computeBtn" disabled>Recompute (Pyodide loading...)</button>

                    <h2>Tree Algorithm</h2>
                    <div class="control-group">
                        <select id="treeAlgorithm" disabled>
                            <option value="both">Both (MST + J-guided)</option>
                            <option value="mst">MST only</option>
                            <option value="j-guided">J-guided only</option>
                        </select>
                    </div>
                    <div class="control-group" style="font-size: 0.8rem; color: #94a3b8;">
                        Tree algorithm used when recomputing with Pyodide
                    </div>

                    <h2>ML Backend</h2>
                    <div class="control-group">
                        <label for="mlBackendSelect">Backend</label>
                        <select id="mlBackendSelect">
                            <option value="transformers.js">Transformers.js</option>
                            <option value="tfjs">TensorFlow.js</option>
                            <option value="onnx">ONNX Runtime</option>
                            <option value="pyodide">Pyodide (NumPy)</option>
                        </select>
                    </div>
                    <div class="control-group" style="font-size: 0.8rem; color: #94a3b8;">
                        <span id="mlBackendStatus">Not loaded</span>
                    </div>
                    <button id="loadMLBackendBtn" class="secondary">Load ML Backend</button>
                    <button id="testEmbedBtn" class="secondary" disabled style="margin-top: 5px;">Test Embedding</button>

                    <h2>Projection Model</h2>
                    <div class="control-group">
                        <label for="projectionModelSource">Source</label>
                        <select id="projectionModelSource">
                            <option value="none">None</option>
                            <option value="url">Load from URL</option>
                            <option value="file">Load from file</option>
                        </select>
                    </div>
                    <div id="projectionUrlGroup" class="control-group" style="display: none;">
                        <input type="text" id="projectionModelUrl" placeholder="data/projection.onnx" style="width: 100%;">
                        <button id="loadProjectionUrlBtn" class="secondary" style="margin-top: 5px;">Load</button>
                    </div>
                    <div id="projectionFileGroup" class="control-group" style="display: none;">
                        <input type="file" id="projectionModelFile" accept=".onnx" style="font-size: 0.8rem;">
                    </div>
                    <div class="control-group" style="font-size: 0.8rem; color: #94a3b8;">
                        <span id="projectionModelStatus">No model loaded</span>
                    </div>
                    <div class="control-group">
                        <label for="embedBlend">Blend: <span class="value" id="embedBlendValue">0.70</span></label>
                        <input type="range" id="embedBlend" min="0" max="1" value="0.7" step="0.05" disabled>
                    </div>
                    <div class="control-group" style="font-size: 0.75rem; color: #94a3b8;">
                        <span id="embedBlendLabel">70% projected + 30% input</span>
                    </div>
                    <button id="testProjectionBtn" class="secondary" disabled>Test Projection</button>
                </div>
            </div>
        </div>

        <div class="main">
            <div id="plot"></div>
            <div class="info-bar" id="infoBar">
                <div class="info-item">
                    <span class="label">Points</span>
                    <span class="value" id="infoPoints">-</span>
                </div>
                <div class="info-item">
                    <span class="label">Kernel Width</span>
                    <span class="value" id="infoBandwidth">-</span>
                </div>
                <div class="info-item">
                    <span class="label">Tree</span>
                    <span class="value" id="infoTree">-</span>
                </div>
                <div class="info-item">
                    <span class="label">SVD Var 1</span>
                    <span class="value" id="infoVar1">-</span>
                </div>
                <div class="info-item">
                    <span class="label">SVD Var 2</span>
                    <span class="value" id="infoVar2">-</span>
                </div>
            </div>
            <div class="status" id="status">
                <span id="statusText">Loading...</span>
                <span class="pyodide-status loading" id="pyodideStatus">Pyodide: pending</span>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // State
        // ============================================================
        let currentData = null;      // Current manifold data
        let originalData = null;     // Original data (before custom projection)
        let activeTreeType = 'mst';  // Currently displayed tree
        let selectedNode = null;     // Currently selected node (for root setting)
        let originalTrees = null;    // Original tree structures (before re-rooting)
        let pyodide = null;          // Pyodide instance (null until loaded)
        let pyodideReady = false;

        // Custom projection state
        let projectionMode = 'svd';
        let axisStartNode = null;
        let axisEndNode = null;

        // ============================================================
        // DOM Elements
        // ============================================================
        const loadingOverlay = document.getElementById('loadingOverlay');
        const loadingText = document.getElementById('loadingText');
        const modeIndicator = document.getElementById('modeIndicator');
        const statusText = document.getElementById('statusText');
        const pyodideStatus = document.getElementById('pyodideStatus');
        const computeBtn = document.getElementById('computeBtn');
        const treeToggle = document.getElementById('treeToggle');

        const datasetSelect = document.getElementById('datasetSelect');
        const customUrlGroup = document.getElementById('customUrlGroup');
        const customUrlInput = document.getElementById('customUrl');
        const loadCustomBtn = document.getElementById('loadCustomBtn');

        const projectionModeSelect = document.getElementById('projectionMode');
        const customProjectionPanel = document.getElementById('customProjectionPanel');
        const axisStartLabel = document.getElementById('axisStartLabel');
        const axisEndLabel = document.getElementById('axisEndLabel');
        const clearAxisBtn = document.getElementById('clearAxisBtn');
        const applyProjectionBtn = document.getElementById('applyProjectionBtn');

        // Root node elements
        const selectedNodeLabel = document.getElementById('selectedNodeLabel');
        const setRootBtn = document.getElementById('setRootBtn');
        const resetRootBtn = document.getElementById('resetRootBtn');

        // Search elements
        const nodeSearchInput = document.getElementById('nodeSearch');
        const searchResultsDiv = document.getElementById('searchResults');
        let highlightedNodeId = null;  // Currently highlighted node on plot

        // Export elements
        const exportMindmapBtn = document.getElementById('exportMindmapBtn');
        const exportFormatSelect = document.getElementById('exportFormat');

        // ML Backend elements
        const mlBackendSelect = document.getElementById('mlBackendSelect');
        const mlBackendStatus = document.getElementById('mlBackendStatus');
        const loadMLBackendBtn = document.getElementById('loadMLBackendBtn');
        const testEmbedBtn = document.getElementById('testEmbedBtn');
        let mlBackend = null;  // Active ML backend instance

        // Projection Model elements
        const projectionModelSource = document.getElementById('projectionModelSource');
        const projectionUrlGroup = document.getElementById('projectionUrlGroup');
        const projectionFileGroup = document.getElementById('projectionFileGroup');
        const projectionModelUrl = document.getElementById('projectionModelUrl');
        const loadProjectionUrlBtn = document.getElementById('loadProjectionUrlBtn');
        const projectionModelFile = document.getElementById('projectionModelFile');
        const projectionModelStatus = document.getElementById('projectionModelStatus');
        const embedBlendSlider = document.getElementById('embedBlend');
        const embedBlendValue = document.getElementById('embedBlendValue');
        const embedBlendLabel = document.getElementById('embedBlendLabel');
        const testProjectionBtn = document.getElementById('testProjectionBtn');
        let projectionSession = null;  // ONNX Runtime session for projection

        const controls = {
            nPoints: document.getElementById('nPoints'),
            bandwidth: document.getElementById('bandwidth'),
            gridSize: document.getElementById('gridSize'),
            showTree: document.getElementById('showTree'),
            showArrows: document.getElementById('showArrows'),
            arrowMode: document.getElementById('arrowMode'),
            maxDepth: document.getElementById('maxDepth'),
            maxBranching: document.getElementById('maxBranching'),
            showPoints: document.getElementById('showPoints'),
            showPeaks: document.getElementById('showPeaks'),
            showContours: document.getElementById('showContours'),
            treeAlgorithm: document.getElementById('treeAlgorithm'),
        };

        const arrowModeGroup = document.getElementById('arrowModeGroup');

        // Tab elements
        const tabButtons = document.querySelectorAll('.tab-btn');
        const tabPanels = document.querySelectorAll('.tab-panel');

        // Embeddings elements - dual selectors for layout and tree
        const layoutEmbeddingSelect = document.getElementById('layoutEmbeddingSelect');
        const treeEmbeddingSelect = document.getElementById('treeEmbeddingSelect');
        const layoutEmbeddingLabel = document.getElementById('layoutEmbeddingLabel');
        const treeEmbeddingLabel = document.getElementById('treeEmbeddingLabel');
        const embeddingLoadingStatus = document.getElementById('embeddingLoadingStatus');

        // Legacy reference for compatibility
        const embeddingSelect = layoutEmbeddingSelect;

        // Dataset configuration with available embeddings
        // Each dataset can have multiple embedding options
        const datasetEmbeddings = {
            'data/physics.json': {
                name: 'Physics (Wikipedia)',
                embeddings: {
                    'nomic': {
                        label: 'Nomic (768D) - Unknown provenance',
                        url: null,  // null = included in main JSON (physics.json has 768D Nomic)
                        dim: 768
                    },
                    'nomic_titles': {
                        label: 'Nomic v1.5 (768D) - Titles',
                        url: 'data/physics_nomic_embeddings.json',
                        dim: 768
                    },
                    'minilm': {
                        label: 'MiniLM (384D) - Titles',
                        url: 'data/physics_minilm_embeddings.json',
                        dim: 384
                    }
                },
                defaultLayout: 'nomic',
                defaultTree: 'nomic'
            }
        };

        // Track current embedding state - separate for layout and tree
        let currentDatasetUrl = 'data/physics.json';
        let layoutEmbeddingType = 'nomic';
        let treeEmbeddingType = 'nomic';
        let layoutEmbeddings = null;  // Embeddings for 2D projection
        let treeEmbeddings = null;    // Embeddings for tree distance calculations

        // Legacy references for compatibility
        let currentEmbeddingType = 'nomic';
        let originalEmbeddings = null;

        const valueDisplays = {
            nPoints: document.getElementById('nPointsValue'),
            bandwidth: document.getElementById('bandwidthValue'),
            gridSize: document.getElementById('gridSizeValue'),
            maxDepth: document.getElementById('maxDepthValue'),
            maxBranching: document.getElementById('maxBranchingValue'),
        };

        // ============================================================
        // Initialization
        // ============================================================
        async function init() {
            // Step 1: Load pre-computed data (fast!)
            try {
                loadingText.textContent = 'Loading pre-computed data...';
                await loadPrecomputedData();
                loadingOverlay.classList.add('hidden');
                setStatus('Ready (static mode)');
            } catch (error) {
                loadingText.textContent = 'Failed to load data. Initializing Pyodide...';
                console.error('Pre-computed data not available:', error);
            }

            // Step 2: Load Pyodide in background (slow, but non-blocking)
            loadPyodideInBackground();

            // Step 3: Set up event listeners
            setupEventListeners();
        }

        async function loadPrecomputedData() {
            // Add cache-busting to ensure fresh data
            const response = await fetch('data/physics.json?v=' + Date.now());
            if (!response.ok) throw new Error('Data not found');
            currentData = await response.json();
            currentDatasetUrl = 'data/physics.json';

            renderPlot();
            updateInfo();
            updateTreeToggle();
            updatePeaksList();
            updateEmbeddingSelector();

            // Sync bandwidth slider with pre-computed data (only on initial load)
            if (currentData.density_grid?.bandwidth) {
                const bw = currentData.density_grid.bandwidth;
                if (bw >= 0.01 && bw <= 1.0) {
                    controls.bandwidth.value = bw;
                    valueDisplays.bandwidth.textContent = bw.toFixed(2);
                }
            }

            // Initialize dual embeddings with optimal defaults:
            // - Layout: MiniLM (better 2D layout, hubs in dense regions)
            // - Tree: Nomic (richer semantic distances for tree edges)
            const config = datasetEmbeddings[currentDatasetUrl];
            const defaultLayout = config?.defaultLayout || 'minilm';
            const defaultTree = config?.defaultTree || 'nomic';

            // Layout embeddings (usually MiniLM - from baked-in data)
            if (currentData.embeddings) {
                layoutEmbeddings = currentData.embeddings;
                layoutEmbeddingType = defaultLayout;
                originalEmbeddings = currentData.embeddings;  // Legacy
            }

            // Tree embeddings (usually Nomic - load from separate file)
            const treeEmbConfig = config?.embeddings?.[defaultTree];
            if (treeEmbConfig?.url) {
                try {
                    const embResponse = await fetch(treeEmbConfig.url);
                    if (embResponse.ok) {
                        const embData = await embResponse.json();
                        if (embData.embeddings?.length === currentData.points.length) {
                            treeEmbeddings = embData.embeddings;
                            treeEmbeddingType = defaultTree;
                            embeddingCache[treeEmbConfig.url] = embData.embeddings;
                            // For Pyodide tree computation, use tree embeddings
                            currentData.embeddings = embData.embeddings;
                        }
                    }
                } catch (e) {
                    console.warn('Failed to load tree embeddings, using layout embeddings:', e);
                    treeEmbeddings = layoutEmbeddings;
                    treeEmbeddingType = layoutEmbeddingType;
                }
            } else {
                // Use same as layout
                treeEmbeddings = layoutEmbeddings;
                treeEmbeddingType = layoutEmbeddingType;
            }

            // Set selector values to match
            if (layoutEmbeddingSelect) layoutEmbeddingSelect.value = layoutEmbeddingType;
            if (treeEmbeddingSelect) treeEmbeddingSelect.value = treeEmbeddingType;

            updateEmbeddingsInfo();
        }

        async function loadPyodideInBackground() {
            pyodideStatus.textContent = 'Pyodide: loading...';
            pyodideStatus.className = 'pyodide-status loading';

            try {
                // Dynamically load Pyodide script
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js';
                script.onload = async () => {
                    try {
                        pyodide = await loadPyodide();
                        await pyodide.loadPackage(['numpy', 'scipy']);
                        await loadDensityCore();

                        pyodideReady = true;
                        await enableInteractiveMode();
                    } catch (error) {
                        console.error('Pyodide init error:', error);
                        pyodideStatus.textContent = 'Pyodide: failed';
                        pyodideStatus.className = 'pyodide-status';
                    }
                };
                document.head.appendChild(script);
            } catch (error) {
                console.error('Failed to load Pyodide:', error);
            }
        }

        async function loadDensityCore() {
            await pyodide.runPythonAsync(`
import numpy as np
from scipy.stats import gaussian_kde
from scipy.sparse.csgraph import minimum_spanning_tree
from scipy.ndimage import maximum_filter

def project_to_2d(embeddings):
    mean = embeddings.mean(axis=0)
    centered = embeddings - mean
    U, S, Vt = np.linalg.svd(centered, full_matrices=False)
    V_2d = Vt[:2].T
    points_2d = centered @ V_2d
    var = S[:2] ** 2
    var_explained = (var / var.sum() * 100).tolist()
    return points_2d, S[:2].tolist(), var_explained

def compute_density_grid(points_2d, bandwidth=None, grid_size=100, padding=0.1):
    x, y = points_2d[:, 0], points_2d[:, 1]
    x_range, y_range = x.max() - x.min(), y.max() - y.min()
    x_min, x_max = x.min() - padding * x_range, x.max() + padding * x_range
    y_min, y_max = y.min() - padding * y_range, y.max() + padding * y_range
    xi, yi = np.linspace(x_min, x_max, grid_size), np.linspace(y_min, y_max, grid_size)
    X, Y = np.meshgrid(xi, yi)
    values = np.vstack([x, y])
    kde = gaussian_kde(values, bw_method=bandwidth) if bandwidth else gaussian_kde(values)
    if not bandwidth: bandwidth = kde.factor
    Z = kde(np.vstack([X.ravel(), Y.ravel()])).reshape(X.shape)
    return {'x_min': float(x_min), 'x_max': float(x_max), 'y_min': float(y_min), 'y_max': float(y_max),
            'grid_size': grid_size, 'values': Z.tolist(), 'bandwidth': float(bandwidth)}

def compute_fisher_entropy(embeddings, k=10):
    """
    Compute Fisher-based entropy for each node using local density.
    Higher density = more general concept = lower entropy
    Lower density = more specific concept = higher entropy
    """
    n = len(embeddings)
    norms = np.linalg.norm(embeddings, axis=1, keepdims=True)
    emb_norm = embeddings / (norms + 1e-8)

    # Compute pairwise distances
    diff = emb_norm[:, np.newaxis, :] - emb_norm[np.newaxis, :, :]
    dist_matrix = np.sqrt((diff ** 2).sum(axis=2))

    # k-NN density: inverse of average distance to k nearest neighbors
    k_actual = min(k, n - 1)
    knn_dists = np.sort(dist_matrix, axis=1)[:, 1:k_actual+1]  # Exclude self
    avg_knn_dist = knn_dists.mean(axis=1)
    density = 1.0 / (avg_knn_dist + 1e-8)

    # Fisher entropy: log(1/density) = -log(density)
    # Normalize to 0-1 range for easier use
    entropy = -np.log(density + 1e-8)
    entropy = (entropy - entropy.min()) / (entropy.max() - entropy.min() + 1e-8)

    return entropy

# Storage for external entropy data (optional)
_external_entropy = None

def set_external_entropy(entropy_dict):
    """Set externally computed entropy/probability data."""
    global _external_entropy
    _external_entropy = entropy_dict
    print(f"Loaded external entropy for {len(entropy_dict)} nodes")

def get_node_entropy(node_id, fisher_entropy):
    """Get entropy for a node, preferring external data if available."""
    global _external_entropy
    if _external_entropy is not None and node_id in _external_entropy:
        return float(_external_entropy[node_id])
    return float(fisher_entropy[node_id])

def build_mst_tree(embeddings, points_2d, titles=None):
    norms = np.linalg.norm(embeddings, axis=1, keepdims=True)
    emb_norm = embeddings / (norms + 1e-8)
    cos_dist = 1 - emb_norm @ emb_norm.T
    np.fill_diagonal(cos_dist, 0)
    mst = minimum_spanning_tree(cos_dist)
    cx = mst.tocoo()
    adj = {}
    for i, j, w in zip(cx.row, cx.col, cx.data):
        i, j = int(i), int(j)
        adj.setdefault(i, []).append((j, w))
        adj.setdefault(j, []).append((i, w))
    degrees = [(len(adj.get(i, [])), i) for i in range(len(embeddings))]
    _, root = max(degrees)
    root = int(root)
    parent, depth, visited, queue = {root: None}, {root: 0}, {root}, [root]
    while queue:
        node = queue.pop(0)
        for neighbor, _ in adj.get(node, []):
            if neighbor not in visited:
                visited.add(neighbor)
                parent[neighbor], depth[neighbor] = node, depth[node] + 1
                queue.append(neighbor)

    # Compute Fisher entropy for each node
    fisher_entropy = compute_fisher_entropy(embeddings)

    nodes, edges = [], []
    for i in range(len(embeddings)):
        p_id = parent.get(i)
        node_ent = get_node_entropy(i, fisher_entropy)
        nodes.append({'id': i, 'title': titles[i] if titles else f"Node {i}",
                      'parent_id': int(p_id) if p_id is not None else None,
                      'depth': int(depth.get(i, 0)), 'x': float(points_2d[i, 0]), 'y': float(points_2d[i, 1]),
                      'entropy': node_ent})
        if p_id is not None:
            edges.append({'source_id': int(p_id), 'target_id': i, 'weight': float(cos_dist[i, p_id])})
    return {'nodes': nodes, 'edges': edges, 'root_id': root, 'tree_type': 'mst'}

def build_j_guided_tree(embeddings, points_2d, titles=None, k_neighbors=10):
    n = len(embeddings)
    norms = np.linalg.norm(embeddings, axis=1, keepdims=True)
    emb_norm = embeddings / (norms + 1e-8)
    diff = emb_norm[:, np.newaxis, :] - emb_norm[np.newaxis, :, :]
    dist_matrix = np.sqrt((diff ** 2).sum(axis=2))
    k = min(k_neighbors, n - 1)
    knn_dists = np.sort(dist_matrix, axis=1)[:, k]
    density = 1.0 / (knn_dists + 1e-8)
    order = np.argsort(-density)
    root = int(order[0])
    parent, depth, placed = {root: None}, {root: 0}, {root}
    for idx in order[1:]:
        idx = int(idx)
        min_dist, best_parent = float('inf'), root
        for placed_node in placed:
            d = dist_matrix[idx, placed_node]
            if d < min_dist: min_dist, best_parent = d, placed_node
        parent[idx], depth[idx] = best_parent, depth[best_parent] + 1
        placed.add(idx)

    # Compute Fisher entropy from density (already computed above)
    # entropy = -log(density), normalized to 0-1
    log_density = np.log(density + 1e-8)
    fisher_entropy = -log_density
    fisher_entropy = (fisher_entropy - fisher_entropy.min()) / (fisher_entropy.max() - fisher_entropy.min() + 1e-8)

    nodes, edges = [], []
    for i in range(n):
        p_id = parent.get(i)
        node_ent = get_node_entropy(i, fisher_entropy)
        nodes.append({'id': i, 'title': titles[i] if titles else f"Node {i}",
                      'parent_id': int(p_id) if p_id is not None else None,
                      'depth': int(depth.get(i, 0)), 'x': float(points_2d[i, 0]), 'y': float(points_2d[i, 1]),
                      'entropy': node_ent})
        if p_id is not None:
            edges.append({'source_id': int(p_id), 'target_id': i, 'weight': float(dist_matrix[i, p_id])})
    return {'nodes': nodes, 'edges': edges, 'root_id': root, 'tree_type': 'j-guided'}

def find_density_peaks(density_grid, points_2d, titles=None, n_peaks=5, min_distance=5):
    Z = np.array(density_grid['values'])
    local_max = maximum_filter(Z, size=min_distance*2+1) == Z
    peak_mask = local_max & (Z > Z.mean())
    peak_indices = np.argwhere(peak_mask)
    if len(peak_indices) == 0: return []
    xi = np.linspace(density_grid['x_min'], density_grid['x_max'], density_grid['grid_size'])
    yi = np.linspace(density_grid['y_min'], density_grid['y_max'], density_grid['grid_size'])
    sorted_idx = np.argsort(-Z[peak_mask])[:n_peaks]
    peaks = []
    for idx in sorted_idx:
        i, j = peak_indices[idx]
        peak_x, peak_y = xi[j], yi[i]
        distances = np.sqrt((points_2d[:, 0] - peak_x)**2 + (points_2d[:, 1] - peak_y)**2)
        nearest_idx = int(np.argmin(distances))
        peaks.append({'x': float(peak_x), 'y': float(peak_y), 'density': float(Z[i, j]),
                      'nearest_node_id': nearest_idx, 'title': titles[nearest_idx] if titles else f"Node {nearest_idx}"})
    return peaks

def compute_density_manifold(embeddings, titles=None, bandwidth=None, grid_size=100, n_peaks=5, tree_embeddings=None):
    """Compute density manifold with optional dual embeddings.

    Args:
        embeddings: Embeddings for 2D projection (layout)
        tree_embeddings: Optional separate embeddings for tree distance calculation.
                        If None, uses same as layout embeddings.
    """
    # Use layout embeddings for 2D projection
    points_2d, singular_values, var_explained = project_to_2d(embeddings)
    density_grid = compute_density_grid(points_2d, bandwidth, grid_size)

    # Use tree embeddings for distance calculations (or fall back to layout)
    tree_emb = tree_embeddings if tree_embeddings is not None else embeddings
    trees = {
        'mst': build_mst_tree(tree_emb, points_2d, titles),
        'j-guided': build_j_guided_tree(tree_emb, points_2d, titles)
    }
    peaks = find_density_peaks(density_grid, points_2d, titles, n_peaks)
    points = [{'id': i, 'title': titles[i] if titles else f"Node {i}",
               'x': float(points_2d[i, 0]), 'y': float(points_2d[i, 1])} for i in range(len(embeddings))]

    # Include embedding info in result
    layout_dim = embeddings.shape[1] if hasattr(embeddings, 'shape') else len(embeddings[0])
    tree_dim = tree_emb.shape[1] if hasattr(tree_emb, 'shape') else len(tree_emb[0])

    return {'points': points, 'density_grid': density_grid, 'tree': trees['mst'], 'trees': trees,
            'peaks': peaks, 'projection': {'variance_explained': var_explained, 'singular_values': singular_values},
            'n_points': int(len(embeddings)), 'layout_dim': layout_dim, 'tree_dim': tree_dim}

def generate_demo_data(n_points=200, n_clusters=5, n_dims=64):
    np.random.seed(42)
    pts_per = n_points // n_clusters
    names = ['Quantum', 'Relativity', 'Thermodynamics', 'Electromagnetism', 'Mechanics']
    embeddings, titles = [], []
    for i in range(n_clusters):
        center = np.random.randn(n_dims) * 3
        embeddings.append(center + np.random.randn(pts_per, n_dims) * 0.5)
        titles.extend([f"{names[i % len(names)]} Concept {j+1}" for j in range(pts_per)])
    return np.vstack(embeddings), titles

# Storage for real embeddings loaded from JSON
_real_embeddings = None
_real_titles = None

# Dual embedding support: separate embeddings for layout (2D) vs tree (distances)
_layout_embeddings = None
_tree_embeddings = None

def set_dual_embeddings(layout_emb, tree_emb, titles):
    """Set separate embeddings for layout (2D projection) and tree (distance calculation)."""
    global _layout_embeddings, _tree_embeddings, _real_titles
    _layout_embeddings = np.array(layout_emb) if layout_emb is not None else None
    _tree_embeddings = np.array(tree_emb) if tree_emb is not None else None
    _real_titles = list(titles) if titles else None
    layout_dim = _layout_embeddings.shape[1] if _layout_embeddings is not None else 0
    tree_dim = _tree_embeddings.shape[1] if _tree_embeddings is not None else 0
    print(f"Loaded dual embeddings: layout={layout_dim}D, tree={tree_dim}D, n={len(titles)}")

def set_real_embeddings(embeddings_list, titles_list):
    """Store real embeddings from JSON for recomputation."""
    global _real_embeddings, _real_titles
    _real_embeddings = np.array(embeddings_list)
    _real_titles = titles_list
    print(f"Loaded {len(_real_titles)} real embeddings ({_real_embeddings.shape[1]}D)")

def get_embeddings(n_points, root_title=None):
    """Get embeddings - real if available, otherwise demo.

    If root_title is provided, selects the n_points nearest neighbors
    to the root node in embedding space (always including the root).
    """
    global _real_embeddings, _real_titles
    if _real_embeddings is not None:
        if root_title is not None:
            # Find root index
            try:
                root_idx = _real_titles.index(root_title)
            except ValueError:
                # Root not found, fall back to first n
                n = min(n_points, len(_real_titles))
                return _real_embeddings[:n], _real_titles[:n]

            # Compute cosine similarity to root
            root_emb = _real_embeddings[root_idx]
            root_norm = np.linalg.norm(root_emb)

            similarities = []
            for i, emb in enumerate(_real_embeddings):
                sim = np.dot(root_emb, emb) / (root_norm * np.linalg.norm(emb) + 1e-8)
                similarities.append((i, sim))

            # Sort by similarity (descending) and take top n
            similarities.sort(key=lambda x: -x[1])
            top_indices = [idx for idx, _ in similarities[:n_points]]

            # Ensure root is included (should be first anyway)
            if root_idx not in top_indices:
                top_indices[-1] = root_idx

            selected_embeddings = _real_embeddings[top_indices]
            selected_titles = [_real_titles[i] for i in top_indices]
            return selected_embeddings, selected_titles
        else:
            n = min(n_points, len(_real_titles))
            return _real_embeddings[:n], _real_titles[:n]
    return generate_demo_data(n_points)

def has_real_embeddings():
    """Check if real embeddings are loaded."""
    return _real_embeddings is not None

def has_dual_embeddings():
    """Check if dual embeddings are loaded."""
    return _layout_embeddings is not None and _tree_embeddings is not None

def get_dual_embeddings(n_points, root_title=None):
    """Get dual embeddings (layout + tree) with optional root-based selection."""
    global _layout_embeddings, _tree_embeddings, _real_titles

    if _layout_embeddings is None or _tree_embeddings is None:
        # Fall back to single embeddings mode
        emb, titles = get_embeddings(n_points, root_title)
        return emb, emb, titles

    if root_title is not None:
        try:
            root_idx = _real_titles.index(root_title)
        except ValueError:
            n = min(n_points, len(_real_titles))
            return _layout_embeddings[:n], _tree_embeddings[:n], _real_titles[:n]

        # Use tree embeddings for similarity (tree defines semantic relationships)
        root_emb = _tree_embeddings[root_idx]
        root_norm = np.linalg.norm(root_emb)

        similarities = []
        for i, emb in enumerate(_tree_embeddings):
            sim = np.dot(root_emb, emb) / (root_norm * np.linalg.norm(emb) + 1e-8)
            similarities.append((i, sim))

        similarities.sort(key=lambda x: -x[1])
        top_indices = [idx for idx, _ in similarities[:n_points]]

        if root_idx not in top_indices:
            top_indices[-1] = root_idx

        layout_sel = _layout_embeddings[top_indices]
        tree_sel = _tree_embeddings[top_indices]
        titles_sel = [_real_titles[i] for i in top_indices]
        return layout_sel, tree_sel, titles_sel
    else:
        n = min(n_points, len(_real_titles))
        return _layout_embeddings[:n], _tree_embeddings[:n], _real_titles[:n]

print("Density core loaded")
            `);
        }

        async function enableInteractiveMode() {
            pyodideStatus.textContent = 'Pyodide: ready';
            pyodideStatus.className = 'pyodide-status ready';
            modeIndicator.textContent = 'Interactive Mode';
            modeIndicator.className = 'mode-indicator interactive';

            // Enable computation controls
            controls.nPoints.disabled = false;
            controls.bandwidth.disabled = false;
            controls.gridSize.disabled = false;
            controls.treeAlgorithm.disabled = false;
            computeBtn.disabled = false;
            computeBtn.textContent = 'Recompute with Pyodide';

            // Load real embeddings into Pyodide if available
            if (currentData && currentData.embeddings) {
                await loadEmbeddingsIntoPyodide();
            }

            setStatus('Ready (interactive mode)');
        }

        async function loadEmbeddingsIntoPyodide() {
            console.log('loadEmbeddingsIntoPyodide called');
            console.log('pyodideReady:', pyodideReady);
            console.log('currentData:', currentData ? 'exists' : 'null');
            console.log('layoutEmbeddings:', layoutEmbeddings ? layoutEmbeddings.length : 'none');
            console.log('treeEmbeddings:', treeEmbeddings ? treeEmbeddings.length : 'none');

            if (!pyodideReady || !currentData?.points) {
                console.log('Skipping - conditions not met');
                return;
            }

            try {
                const titles = currentData.points.map(p => p.title);
                console.log('Titles sample:', titles.slice(0, 3));

                // Use dual embeddings if both are available
                if (layoutEmbeddings && treeEmbeddings) {
                    console.log(`Setting dual embeddings: layout=${layoutEmbeddings[0]?.length}D, tree=${treeEmbeddings[0]?.length}D`);
                    pyodide.globals.set('_js_layout_emb', layoutEmbeddings);
                    pyodide.globals.set('_js_tree_emb', treeEmbeddings);
                    pyodide.globals.set('_js_titles', titles);
                    await pyodide.runPythonAsync(`
set_dual_embeddings(_js_layout_emb.to_py(), _js_tree_emb.to_py(), list(_js_titles))
                    `);
                    console.log('Dual embeddings loaded into Pyodide successfully');
                    setStatus('Ready (dual embeddings loaded)');
                } else if (currentData.embeddings) {
                    // Fallback to single embeddings
                    console.log('Embeddings shape:', currentData.embeddings.length, 'x', currentData.embeddings[0]?.length);
                    pyodide.globals.set('_js_embeddings', currentData.embeddings);
                    pyodide.globals.set('_js_titles', titles);
                    await pyodide.runPythonAsync(`
set_real_embeddings(_js_embeddings.to_py(), list(_js_titles))
                    `);
                    console.log('Single embeddings loaded into Pyodide successfully');
                    setStatus('Ready (real embeddings loaded)');
                }
            } catch (error) {
                console.error('Failed to load embeddings into Pyodide:', error);
                setStatus('Failed to load embeddings: ' + error.message, 'error');
            }
        }

        // ============================================================
        // Event Listeners
        // ============================================================
        function setupEventListeners() {
            // Tab switching
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const tabId = btn.dataset.tab;
                    tabButtons.forEach(b => b.classList.remove('active'));
                    tabPanels.forEach(p => p.classList.remove('active'));
                    btn.classList.add('active');
                    document.getElementById(`tab-${tabId}`).classList.add('active');
                });
            });

            // Value display updates
            for (const [key, input] of Object.entries(controls)) {
                if (input && input.type === 'range' && valueDisplays[key]) {
                    input.addEventListener('input', () => {
                        valueDisplays[key].textContent =
                            key === 'bandwidth' ? parseFloat(input.value).toFixed(2) : input.value;
                        // Sync bandwidth slider with Flask API text input
                        if (key === 'bandwidth') {
                            const flaskBwInput = document.getElementById('flaskBandwidth');
                            if (flaskBwInput) {
                                flaskBwInput.value = parseFloat(input.value).toFixed(2);
                            }
                        }
                    });
                }
            }

            // Sync Flask API bandwidth input with Pyodide slider
            const flaskBwInput = document.getElementById('flaskBandwidth');
            if (flaskBwInput) {
                flaskBwInput.addEventListener('input', () => {
                    const val = parseFloat(flaskBwInput.value);
                    if (!isNaN(val) && val >= 0.01 && val <= 1.0) {
                        controls.bandwidth.value = val;
                        valueDisplays.bandwidth.textContent = val.toFixed(2);
                    }
                });
            }

            // Display toggles (instant, no recomputation)
            ['showTree', 'showPoints', 'showPeaks', 'showContours'].forEach(key => {
                controls[key].addEventListener('change', () => {
                    if (currentData) renderPlot();
                });
            });

            // Max depth slider needs 'input' event for immediate feedback
            controls.maxDepth.addEventListener('input', () => {
                valueDisplays.maxDepth.textContent = controls.maxDepth.value;
                if (currentData) renderPlot();
            });

            // Max branching slider
            controls.maxBranching.addEventListener('input', () => {
                const val = parseInt(controls.maxBranching.value);
                valueDisplays.maxBranching.textContent = val >= 20 ? '∞' : val;
                if (currentData) renderPlot();
            });

            // Arrow controls with mode visibility toggle
            controls.showArrows.addEventListener('change', () => {
                arrowModeGroup.style.display = controls.showArrows.checked ? 'block' : 'none';
                if (currentData) renderPlot();
            });

            controls.arrowMode.addEventListener('change', () => {
                if (currentData) renderPlot();
            });

            // Compute button
            computeBtn.addEventListener('click', recompute);

            // Dataset selector
            datasetSelect.addEventListener('change', handleDatasetChange);
            loadCustomBtn.addEventListener('click', loadCustomUrl);

            // Flask API button
            const loadFlaskBtn = document.getElementById('loadFlaskBtn');
            if (loadFlaskBtn) {
                loadFlaskBtn.addEventListener('click', loadFromFlaskApi);
            }

            // Show/hide layout dataset override based on model + projection mode
            function updateLayoutDatasetVisibility() {
                const model = document.getElementById('flaskModel')?.value;
                const projMode = document.getElementById('flaskProjectionMode')?.value;
                const group = document.getElementById('layoutDatasetGroup');
                const embOption = document.getElementById('embeddingModeOption');
                const hasModel = model && model !== 'None' && model !== '';
                if (group) {
                    // Show when a projection model is selected AND projection mode is embedding
                    group.style.display = (hasModel && projMode === 'embedding') ? 'block' : 'none';
                }
                // Clarify what "Embedding Space" means based on whether a model is active
                if (embOption) {
                    embOption.textContent = hasModel
                        ? 'Projected Embedding Space (model output for layout)'
                        : 'Embedding Space (semantic similarity)';
                }
            }
            document.getElementById('flaskModel')?.addEventListener('change', updateLayoutDatasetVisibility);
            document.getElementById('flaskProjectionMode')?.addEventListener('change', updateLayoutDatasetVisibility);
            updateLayoutDatasetVisibility();

            // Projection mode
            projectionModeSelect.addEventListener('change', handleProjectionModeChange);
            clearAxisBtn.addEventListener('click', clearAxisSelection);
            applyProjectionBtn.addEventListener('click', applyCustomProjection);

            // Embedding selectors (dual: layout and tree)
            layoutEmbeddingSelect.addEventListener('change', handleLayoutEmbeddingChange);
            treeEmbeddingSelect.addEventListener('change', handleTreeEmbeddingChange);

            // Root node controls
            setRootBtn.addEventListener('click', setSelectedAsRoot);
            resetRootBtn.addEventListener('click', resetTreeRoot);

            // Search
            nodeSearchInput.addEventListener('input', handleSearchInput);

            // Export
            exportMindmapBtn.addEventListener('click', exportMindmap);

            // ML Backend
            loadMLBackendBtn.addEventListener('click', loadMLBackend);
            testEmbedBtn.addEventListener('click', testMLEmbedding);

            // Projection Model
            projectionModelSource.addEventListener('change', handleProjectionSourceChange);
            loadProjectionUrlBtn.addEventListener('click', loadProjectionFromUrl);
            projectionModelFile.addEventListener('change', loadProjectionFromFile);
            embedBlendSlider.addEventListener('input', updateBlendLabel);
            testProjectionBtn.addEventListener('click', testProjection);
        }

        // ============================================================
        // ML Backend Functions
        // ============================================================
        async function loadMLBackend() {
            const backendType = mlBackendSelect.value;
            mlBackendStatus.textContent = 'Loading...';
            mlBackendStatus.style.color = '#f39c12';
            loadMLBackendBtn.disabled = true;

            try {
                // Dispose existing backend if any
                if (mlBackend) {
                    mlBackend.dispose();
                    mlBackend = null;
                }

                // Special handling for Pyodide backend
                if (backendType === 'pyodide') {
                    if (!pyodideReady) {
                        throw new Error('Pyodide not ready yet');
                    }
                    mlBackend = await MLBackend.create('pyodide', { pyodide });
                } else {
                    mlBackend = await MLBackend.create(backendType);
                }

                mlBackendStatus.textContent = `${mlBackend.name} ready (${mlBackend.model})`;
                mlBackendStatus.style.color = '#27ae60';
                testEmbedBtn.disabled = (backendType === 'pyodide'); // Pyodide can't embed
                setStatus(`ML Backend loaded: ${mlBackend.name}`);

            } catch (error) {
                console.error('Failed to load ML backend:', error);
                mlBackendStatus.textContent = `Error: ${error.message}`;
                mlBackendStatus.style.color = '#e74c3c';
                testEmbedBtn.disabled = true;
            } finally {
                loadMLBackendBtn.disabled = false;
            }
        }

        async function testMLEmbedding() {
            if (!mlBackend || !mlBackend.ready) {
                setStatus('ML Backend not loaded', 'error');
                return;
            }

            // Get some sample titles from current data
            const sampleTexts = currentData?.points?.slice(0, 5).map(p => p.title) || [
                'Physics', 'Quantum mechanics', 'Thermodynamics'
            ];

            setStatus('Computing embeddings...', 'loading');
            testEmbedBtn.disabled = true;

            try {
                const startTime = performance.now();
                const embeddings = await mlBackend.embed(sampleTexts);
                const elapsed = (performance.now() - startTime).toFixed(0);

                const dim = embeddings[0]?.length || 0;
                setStatus(`Embedded ${sampleTexts.length} texts → ${dim}D in ${elapsed}ms`);

                console.log('Sample embeddings:', embeddings);
                console.log('Texts:', sampleTexts);

            } catch (error) {
                console.error('Embedding failed:', error);
                setStatus(`Embedding failed: ${error.message}`, 'error');
            } finally {
                testEmbedBtn.disabled = false;
            }
        }

        // ============================================================
        // Projection Model Functions
        // ============================================================
        function handleProjectionSourceChange() {
            const source = projectionModelSource.value;
            projectionUrlGroup.style.display = source === 'url' ? 'block' : 'none';
            projectionFileGroup.style.display = source === 'file' ? 'block' : 'none';

            if (source === 'none') {
                // Clear projection model
                projectionSession = null;
                projectionModelStatus.textContent = 'No model loaded';
                projectionModelStatus.style.color = '#94a3b8';
                embedBlendSlider.disabled = true;
                testProjectionBtn.disabled = true;
            }
        }

        async function loadProjectionFromUrl() {
            const url = projectionModelUrl.value.trim();
            if (!url) {
                setStatus('Please enter a URL', 'error');
                return;
            }

            await loadProjectionModel(url, url.split('/').pop());
        }

        async function loadProjectionFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;

            const arrayBuffer = await file.arrayBuffer();
            await loadProjectionModel(arrayBuffer, file.name);
        }

        async function loadProjectionModel(source, name) {
            projectionModelStatus.textContent = 'Loading...';
            projectionModelStatus.style.color = '#f39c12';

            try {
                // Load ONNX Runtime Web if not already loaded
                if (typeof ort === 'undefined') {
                    setStatus('Loading ONNX Runtime...', 'loading');
                    await loadScript('https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.0/dist/ort.min.js');
                }

                // Load model from URL or ArrayBuffer
                let modelData;
                if (typeof source === 'string') {
                    // It's a URL
                    setStatus(`Fetching ${name}...`, 'loading');
                    const response = await fetch(source);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    modelData = await response.arrayBuffer();
                } else {
                    // It's an ArrayBuffer
                    modelData = source;
                }

                // Create ONNX session
                projectionSession = await ort.InferenceSession.create(modelData, {
                    executionProviders: ['wasm']  // Use WASM for broad compatibility
                });

                // Get model info
                const inputNames = projectionSession.inputNames;
                const outputNames = projectionSession.outputNames;

                projectionModelStatus.textContent = `Loaded: ${name}`;
                projectionModelStatus.style.color = '#27ae60';

                // Enable controls
                embedBlendSlider.disabled = false;
                testProjectionBtn.disabled = false;

                setStatus(`Projection model loaded (inputs: ${inputNames.join(', ')})`);
                console.log('ONNX model loaded:', { inputNames, outputNames });

            } catch (error) {
                console.error('Failed to load projection model:', error);
                projectionModelStatus.textContent = `Error: ${error.message}`;
                projectionModelStatus.style.color = '#e74c3c';
                projectionSession = null;
                embedBlendSlider.disabled = true;
                testProjectionBtn.disabled = true;
            }
        }

        function updateBlendLabel() {
            const blend = parseFloat(embedBlendSlider.value);
            embedBlendValue.textContent = blend.toFixed(2);
            const projected = Math.round(blend * 100);
            const input = 100 - projected;
            embedBlendLabel.textContent = `${projected}% projected + ${input}% input`;
        }

        async function testProjection() {
            if (!projectionSession) {
                setStatus('No projection model loaded', 'error');
                return;
            }

            // Use originalEmbeddings if available, otherwise currentData.embeddings
            const sourceEmbeddings = originalEmbeddings || currentData?.embeddings;
            if (!sourceEmbeddings || sourceEmbeddings.length === 0) {
                setStatus('No embeddings available for projection', 'error');
                return;
            }

            testProjectionBtn.disabled = true;
            setStatus('Testing projection...', 'loading');

            try {
                // Get first 5 embeddings as test
                const testEmbeddings = sourceEmbeddings.slice(0, 5);
                const blend = parseFloat(embedBlendSlider.value);

                const startTime = performance.now();
                const blendedResults = [];

                for (const emb of testEmbeddings) {
                    // Create input tensor
                    const inputTensor = new ort.Tensor('float32', new Float32Array(emb), [1, emb.length]);

                    // Run projection
                    const results = await projectionSession.run({ 'query_embedding': inputTensor });
                    const projected = Array.from(results['projected_embedding'].data);

                    // Blend: blend * projected + (1 - blend) * input
                    const blended = emb.map((v, i) => blend * projected[i] + (1 - blend) * v);
                    blendedResults.push(blended);
                }

                const elapsed = (performance.now() - startTime).toFixed(0);
                setStatus(`Projected ${testEmbeddings.length} embeddings in ${elapsed}ms (blend=${blend.toFixed(2)})`);

                console.log('Projection test results:', {
                    inputDim: testEmbeddings[0].length,
                    outputDim: blendedResults[0].length,
                    blend: blend,
                    sample: blendedResults[0].slice(0, 5)
                });

            } catch (error) {
                console.error('Projection failed:', error);
                setStatus(`Projection failed: ${error.message}`, 'error');
            } finally {
                testProjectionBtn.disabled = false;
            }
        }

        async function applyProjectionToEmbeddings(embeddings) {
            /**
             * Apply projection model to embeddings with blending.
             * Returns blended embeddings: blend * projected + (1 - blend) * input
             */
            if (!projectionSession) {
                return embeddings;  // No projection, return as-is
            }

            const blend = parseFloat(embedBlendSlider.value);
            if (blend === 0) {
                return embeddings;  // 100% input, no projection needed
            }

            const blendedEmbeddings = [];

            for (const emb of embeddings) {
                const inputTensor = new ort.Tensor('float32', new Float32Array(emb), [1, emb.length]);
                const results = await projectionSession.run({ 'query_embedding': inputTensor });
                const projected = Array.from(results['projected_embedding'].data);

                // Blend
                const blended = emb.map((v, i) => blend * projected[i] + (1 - blend) * v);
                blendedEmbeddings.push(blended);
            }

            return blendedEmbeddings;
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function getDimLabel(dim) {
            if (dim === 384) return 'MiniLM (384D)';
            if (dim === 768) return 'Nomic (768D)';
            if (dim === 1024) return 'Large (1024D)';
            return `Unknown (${dim}D)`;
        }

        function updateEmbeddingsInfo() {
            // Update layout embedding label
            if (layoutEmbeddings) {
                const dim = layoutEmbeddings[0]?.length || 0;
                layoutEmbeddingLabel.textContent = getDimLabel(dim);
            } else if (currentData?.embeddings) {
                const dim = currentData.embeddings[0]?.length || 0;
                layoutEmbeddingLabel.textContent = getDimLabel(dim);
            } else {
                layoutEmbeddingLabel.textContent = 'None';
            }

            // Update tree embedding label
            if (treeEmbeddings) {
                const dim = treeEmbeddings[0]?.length || 0;
                treeEmbeddingLabel.textContent = getDimLabel(dim);
            } else if (currentData?.embeddings) {
                const dim = currentData.embeddings[0]?.length || 0;
                treeEmbeddingLabel.textContent = getDimLabel(dim);
            } else {
                treeEmbeddingLabel.textContent = 'None';
            }
        }

        function updateEmbeddingSelector() {
            // Populate both selectors
            // Try current dataset config, fall back to physics.json for Flask API mode
            let config = datasetEmbeddings[currentDatasetUrl];
            if (!config && currentDatasetUrl?.startsWith('flask-api:')) {
                config = datasetEmbeddings['data/physics.json'];
            }

            for (const [selector, currentType] of [
                [layoutEmbeddingSelect, layoutEmbeddingType],
                [treeEmbeddingSelect, treeEmbeddingType]
            ]) {
                selector.innerHTML = '';

                if (config) {
                    for (const [key, emb] of Object.entries(config.embeddings)) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = emb.label;
                        if (key === currentType) {
                            option.selected = true;
                        }
                        selector.appendChild(option);
                    }
                } else {
                    const option = document.createElement('option');
                    option.value = 'current';
                    option.textContent = 'Current (from dataset)';
                    selector.appendChild(option);
                }
            }
        }

        // Cache for loaded embeddings by URL
        const embeddingCache = {};

        async function loadEmbeddingsForPurpose(purpose, selected) {
            // purpose is 'layout' or 'tree'
            const selector = purpose === 'layout' ? layoutEmbeddingSelect : treeEmbeddingSelect;

            // Try current dataset config, fall back to physics.json for Flask API mode
            let config = datasetEmbeddings[currentDatasetUrl];
            if (!config && currentDatasetUrl?.startsWith('flask-api:')) {
                // Flask API uses same embeddings as physics.json
                config = datasetEmbeddings['data/physics.json'];
            }

            if (!config || !config.embeddings[selected]) {
                return null;
            }

            const embConfig = config.embeddings[selected];

            // If URL is null, use embeddings from main dataset (the original ones)
            if (embConfig.url === null) {
                // Return the original embeddings (MiniLM baked into physics.json)
                // Note: originalEmbeddings stores the original before we load alternates
                if (originalEmbeddings) {
                    return originalEmbeddings;
                }
                // Fallback to layoutEmbeddings if that's the original
                if (layoutEmbeddings && layoutEmbeddingType === 'minilm') {
                    return layoutEmbeddings;
                }
                return null;
            }

            // Check cache first
            if (embeddingCache[embConfig.url]) {
                return embeddingCache[embConfig.url];
            }

            // Fetch embeddings from URL
            embeddingLoadingStatus.style.display = 'block';
            embeddingLoadingStatus.textContent = `Loading ${embConfig.label}...`;
            setStatus(`Fetching ${embConfig.label}...`, 'loading');

            try {
                const response = await fetch(embConfig.url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const embData = await response.json();

                if (embData.embeddings && embData.embeddings.length === currentData.points.length) {
                    embeddingCache[embConfig.url] = embData.embeddings;
                    return embData.embeddings;
                } else {
                    throw new Error(`Embedding count mismatch: expected ${currentData.points.length}, got ${embData.embeddings?.length || 0}`);
                }
            } catch (error) {
                setStatus(`Failed to load embeddings: ${error.message}`, 'error');
                console.error('Embedding fetch error:', error);
                return null;
            } finally {
                embeddingLoadingStatus.style.display = 'none';
            }
        }

        async function handleLayoutEmbeddingChange() {
            const selected = layoutEmbeddingSelect.value;
            const emb = await loadEmbeddingsForPurpose('layout', selected);
            if (emb) {
                layoutEmbeddings = emb;
                layoutEmbeddingType = selected;
                updateEmbeddingsInfo();

                // Update Pyodide's dual embeddings for recompute
                if (pyodideReady && currentData?.points) {
                    const titles = currentData.points.map(p => p.title);
                    const treeEmb = treeEmbeddings || emb;
                    pyodide.globals.set('_js_layout_emb', emb);
                    pyodide.globals.set('_js_tree_emb', treeEmb);
                    pyodide.globals.set('_js_titles', titles);
                    await pyodide.runPythonAsync(`
set_dual_embeddings(_js_layout_emb.to_py(), _js_tree_emb.to_py(), list(_js_titles))
                    `);
                    console.log(`Updated dual embeddings: layout=${emb[0]?.length}D, tree=${treeEmb[0]?.length}D`);
                }

                // Check if Flask API mode with a model or special projection mode
                // In that case, use the API for consistent projection
                const isFlaskApiMode = currentDatasetUrl?.startsWith('flask-api:');
                const flaskModel = document.getElementById('flaskModel')?.value;
                const flaskProjectionMode = document.getElementById('flaskProjectionMode')?.value;
                const needsApiProjection = isFlaskApiMode && (
                    (flaskModel && flaskModel !== 'None' && flaskModel !== '') ||
                    (flaskProjectionMode && flaskProjectionMode !== 'embedding')
                );

                if (needsApiProjection) {
                    // Flask API mode with a model: sync the layout embedding choice
                    // to the 2D Layout Dataset selector and reload via API.
                    // The Bivector model projects embeddings for tree distances,
                    // but the 2D SVD layout can use raw embeddings from any dataset.
                    const layoutDatasetSelect = document.getElementById('flaskLayoutDataset');
                    if (layoutDatasetSelect) {
                        // Map embedding type to a layout dataset
                        const embeddingToDataset = {
                            'minilm': '',  // MiniLM = same as data subset (original raw embeddings)
                            'nomic': '',   // Nomic = same as data subset
                        };
                        const mapped = embeddingToDataset[selected];
                        if (mapped !== undefined) {
                            layoutDatasetSelect.value = mapped;
                        }
                    }
                    console.log('Using Flask API for projection (model or special mode selected)');
                    await loadFromFlaskApi();
                    return;
                }

                // Re-project the data using the new layout embeddings (SVD)
                if (pyodideReady && currentData?.points) {
                    setStatus('Re-projecting with new layout embeddings...', 'loading');
                    try {
                        // Send layout embeddings to Pyodide for projection and density recalculation
                        // Use current data's bandwidth to preserve consistency, fall back to slider
                        const bandwidth = currentData.density_grid?.bandwidth || parseFloat(controls.bandwidth.value);
                        const gridSize = currentData.density_grid?.grid_size || parseInt(controls.gridSize.value);
                        const titles = currentData.points.map(p => p.title);
                        pyodide.globals.set('_js_layout_emb', emb);
                        pyodide.globals.set('_js_titles', titles);
                        const result = await pyodide.runPythonAsync(`
import json
_layout_arr = np.array(_js_layout_emb.to_py())
_titles = list(_js_titles)
_pts_2d, _sv, _var = project_to_2d(_layout_arr)
# Recompute density grid with new 2D positions
_density_grid = compute_density_grid(_pts_2d, bandwidth=${bandwidth}, grid_size=${gridSize})
# Recompute peaks
_peaks = find_density_peaks(_density_grid, _pts_2d, _titles, n_peaks=5)
json.dumps({
    'points_2d': _pts_2d.tolist(),
    'singular_values': _sv,
    'variance_explained': _var,
    'density_grid': _density_grid,
    'peaks': _peaks
})
                        `);
                        const projection = JSON.parse(result);

                        // Update point coordinates
                        for (let i = 0; i < currentData.points.length; i++) {
                            currentData.points[i].x = projection.points_2d[i][0];
                            currentData.points[i].y = projection.points_2d[i][1];
                        }

                        // Update projection info
                        currentData.projection = {
                            variance_explained: projection.variance_explained,
                            singular_values: projection.singular_values,
                            mode: 'svd'
                        };

                        // Update density grid and peaks
                        currentData.density_grid = projection.density_grid;
                        currentData.peaks = projection.peaks;

                        // Update tree node coordinates too
                        for (const treeType of Object.keys(currentData.trees || {})) {
                            const tree = currentData.trees[treeType];
                            if (tree?.nodes) {
                                for (const node of tree.nodes) {
                                    const point = currentData.points.find(p => p.id === node.id);
                                    if (point) {
                                        node.x = point.x;
                                        node.y = point.y;
                                    }
                                }
                            }
                        }

                        renderPlot();
                        updateInfo();
                        updatePeaksList();
                        setStatus(`Re-projected with ${datasetEmbeddings[currentDatasetUrl]?.embeddings[selected]?.label || selected}`);
                    } catch (error) {
                        console.error('Re-projection failed:', error);
                        setStatus(`Re-projection failed: ${error.message}`, 'error');
                    }
                } else {
                    setStatus(`Layout embeddings: ${datasetEmbeddings[currentDatasetUrl]?.embeddings[selected]?.label || selected}`);
                }
            }
        }

        async function handleTreeEmbeddingChange() {
            const selected = treeEmbeddingSelect.value;
            const emb = await loadEmbeddingsForPurpose('tree', selected);
            if (emb) {
                treeEmbeddings = emb;
                treeEmbeddingType = selected;

                // Update Pyodide with dual embeddings (layout + new tree)
                if (pyodideReady && currentData?.points) {
                    const titles = currentData.points.map(p => p.title);
                    const layoutEmb = layoutEmbeddings || emb;
                    pyodide.globals.set('_js_layout_emb', layoutEmb);
                    pyodide.globals.set('_js_tree_emb', emb);
                    pyodide.globals.set('_js_titles', titles);
                    await pyodide.runPythonAsync(`
set_dual_embeddings(_js_layout_emb.to_py(), _js_tree_emb.to_py(), list(_js_titles))
                    `);
                    console.log(`Updated dual embeddings: layout=${layoutEmb[0]?.length}D, tree=${emb[0]?.length}D`);
                }

                updateEmbeddingsInfo();
                setStatus(`Tree embeddings: ${datasetEmbeddings[currentDatasetUrl]?.embeddings[selected]?.label || selected}`);
            }
        }

        // Legacy handler for compatibility
        async function handleEmbeddingChange() {
            await handleLayoutEmbeddingChange();
        }

        function handleProjectionModeChange() {
            projectionMode = projectionModeSelect.value;
            if (projectionMode === 'custom') {
                customProjectionPanel.style.display = 'block';
                // Store original data for reset
                if (!originalData && currentData) {
                    originalData = JSON.parse(JSON.stringify(currentData));
                }
            } else {
                customProjectionPanel.style.display = 'none';
                // Restore original SVD projection
                if (originalData) {
                    currentData = JSON.parse(JSON.stringify(originalData));
                    renderPlot();
                    updateInfo();
                }
            }
        }

        function handlePlotClick(eventData) {
            if (!eventData.points || eventData.points.length === 0) return;

            const clickedPoint = eventData.points[0];
            let clickedNode = null;

            // Check if this is from the Points trace (has customdata with node info)
            // The points trace has name starting with "Points"
            if (!clickedPoint.data.name || !clickedPoint.data.name.startsWith('Points')) {
                // Try to find nearest point manually
                let minDist = Infinity;
                for (const p of currentData.points) {
                    const dist = Math.sqrt(Math.pow(p.x - clickedPoint.x, 2) + Math.pow(p.y - clickedPoint.y, 2));
                    if (dist < minDist) {
                        minDist = dist;
                        clickedNode = p;
                    }
                }
            } else {
                // Direct point click - use pointIndex
                const pointIndex = clickedPoint.pointIndex;
                clickedNode = currentData.points[pointIndex];
            }

            if (!clickedNode) return;

            // Always update selected node for root feature
            selectNodeForRoot(clickedNode);

            // Handle custom projection mode
            if (projectionMode === 'custom') {
                selectNode(clickedNode);
            }
        }

        function selectNode(node) {
            if (!axisStartNode) {
                axisStartNode = node;
                axisStartLabel.textContent = node.title.substring(0, 25);
            } else if (!axisEndNode && node.id !== axisStartNode.id) {
                axisEndNode = node;
                axisEndLabel.textContent = node.title.substring(0, 25);
                applyProjectionBtn.disabled = !pyodideReady;
            }
        }

        // ============================================================
        // Root Node Functions
        // ============================================================
        function selectNodeForRoot(node) {
            selectedNode = node;
            selectedNodeLabel.textContent = node.title;
            selectedNodeLabel.title = node.title;  // Tooltip for long names
            setRootBtn.disabled = false;
        }

        function setSelectedAsRoot() {
            if (!selectedNode || !currentData) return;

            // If data came from Flask API, rebuild tree server-side with proper root
            if (currentDatasetUrl && currentDatasetUrl.startsWith('flask-api:')) {
                setStatus(`Rebuilding tree from "${selectedNode.title}"...`, 'loading');
                loadFromFlaskApi(selectedNode.title);  // Pass title, not ID (IDs may change)
                return;
            }

            // For non-API datasets, do client-side re-root (best effort)
            if (!originalTrees && currentData.trees) {
                originalTrees = JSON.parse(JSON.stringify(currentData.trees));
            } else if (!originalTrees && currentData.tree) {
                originalTrees = { [activeTreeType]: JSON.parse(JSON.stringify(currentData.tree)) };
            }

            if (currentData.trees) {
                for (const [treeType, tree] of Object.entries(currentData.trees)) {
                    rerootTree(tree, selectedNode.id);
                }
            } else if (currentData.tree) {
                rerootTree(currentData.tree, selectedNode.id);
            }

            renderPlot();
            setStatus(`Tree re-rooted at "${selectedNode.title}"`);
        }

        function rerootTree(tree, newRootId) {
            // Re-root tree by traversing existing edges from new root via BFS.
            // Preserves the tree's edge topology (built with proper distance metrics)
            // while changing which node is considered the root.

            const nodes = tree.nodes;
            const nodeById = {};
            for (const node of nodes) {
                nodeById[node.id] = node;
            }

            if (!nodeById[newRootId]) return;

            // Build undirected adjacency from existing edges (preserving weights)
            const adj = {};
            const edgeWeight = {};
            for (const edge of tree.edges) {
                const s = edge.source_id, t = edge.target_id;
                if (!adj[s]) adj[s] = [];
                if (!adj[t]) adj[t] = [];
                adj[s].push(t);
                adj[t].push(s);
                // Store weight keyed by sorted pair
                const key = Math.min(s, t) + ',' + Math.max(s, t);
                edgeWeight[key] = edge.weight;
            }

            // BFS from new root through undirected adjacency
            const newParent = { [newRootId]: null };
            const newDepth = { [newRootId]: 0 };
            const visited = new Set([newRootId]);
            const queue = [newRootId];

            while (queue.length > 0) {
                const nodeId = queue.shift();
                const neighbors = adj[nodeId] || [];
                for (const nbId of neighbors) {
                    if (!visited.has(nbId)) {
                        visited.add(nbId);
                        newParent[nbId] = nodeId;
                        newDepth[nbId] = newDepth[nodeId] + 1;
                        queue.push(nbId);
                    }
                }
            }

            // Update nodes with new parent/depth
            for (const node of nodes) {
                node.parent_id = newParent[node.id] !== undefined ? newParent[node.id] : null;
                node.depth = newDepth[node.id] !== undefined ? newDepth[node.id] : 0;
            }

            // Rebuild directed edges from new parent relationships
            tree.edges = [];
            for (const node of nodes) {
                if (node.parent_id !== null) {
                    const key = Math.min(node.id, node.parent_id) + ',' + Math.max(node.id, node.parent_id);
                    tree.edges.push({
                        source_id: node.parent_id,
                        target_id: node.id,
                        weight: edgeWeight[key] || 0
                    });
                }
            }

            tree.root_id = newRootId;
        }

        function resetTreeRoot() {
            if (originalTrees) {
                if (currentData.trees) {
                    currentData.trees = JSON.parse(JSON.stringify(originalTrees));
                } else if (currentData.tree) {
                    currentData.tree = JSON.parse(JSON.stringify(originalTrees[activeTreeType]));
                }
                originalTrees = null;
                renderPlot();
                setStatus('Tree root reset to original');
            }

            // Clear selection
            selectedNode = null;
            selectedNodeLabel.textContent = 'None selected';
            setRootBtn.disabled = true;
        }

        // ============================================================
        // Search Functions
        // ============================================================
        function handleSearchInput() {
            const query = nodeSearchInput.value.trim().toLowerCase();
            searchResultsDiv.innerHTML = '';

            if (!query || !currentData || !currentData.points) {
                highlightedNodeId = null;
                renderPlot();  // Remove highlight
                return;
            }

            // Find matching nodes
            const matches = currentData.points.filter(p =>
                p.title.toLowerCase().includes(query)
            ).slice(0, 10);  // Limit to 10 results

            if (matches.length === 0) {
                searchResultsDiv.innerHTML = '<div class="search-no-results">No matches found</div>';
                highlightedNodeId = null;
                renderPlot();
                return;
            }

            // Create result items
            matches.forEach(node => {
                const div = document.createElement('div');
                div.className = 'search-result';
                div.textContent = node.title;
                div.title = node.title;  // Tooltip
                div.addEventListener('click', () => selectSearchResult(node));
                div.addEventListener('mouseenter', () => highlightNode(node.id));
                searchResultsDiv.appendChild(div);
            });

            // Highlight first match
            if (matches.length > 0) {
                highlightNode(matches[0].id);
            }
        }

        function selectSearchResult(node) {
            // Select for root
            selectNodeForRoot(node);

            // Highlight on plot
            highlightNode(node.id);

            // Center view on node
            centerOnNode(node);

            // Clear search
            nodeSearchInput.value = '';
            searchResultsDiv.innerHTML = '';
        }

        function highlightNode(nodeId) {
            highlightedNodeId = nodeId;
            renderPlot();
        }

        function centerOnNode(node) {
            // Get current plot layout
            const plotDiv = document.getElementById('plot');
            const currentLayout = plotDiv.layout || {};

            // Calculate new range centered on node with some padding
            const padding = 0.05;  // 5% of current range
            const xRange = currentLayout.xaxis?.range || [node.x - 0.5, node.x + 0.5];
            const yRange = currentLayout.yaxis?.range || [node.y - 0.5, node.y + 0.5];

            const xSpan = (xRange[1] - xRange[0]) / 2;
            const ySpan = (yRange[1] - yRange[0]) / 2;

            // Animate to center on node
            Plotly.relayout('plot', {
                'xaxis.range': [node.x - xSpan, node.x + xSpan],
                'yaxis.range': [node.y - ySpan, node.y + ySpan]
            });
        }

        function clearAxisSelection() {
            axisStartNode = null;
            axisEndNode = null;
            axisStartLabel.textContent = '-';
            axisEndLabel.textContent = '-';
            applyProjectionBtn.disabled = true;
        }

        async function applyCustomProjection() {
            if (!pyodideReady || !axisStartNode || !axisEndNode) return;

            setStatus('Computing custom projection...', 'loading');
            applyProjectionBtn.disabled = true;

            try {
                const result = await pyodide.runPythonAsync(`
import json
import numpy as np

# Get the original data
data = json.loads('''${JSON.stringify(originalData || currentData)}''')

# We need embeddings - for now use 2D points as proxy
# In a real implementation, you'd store/reload the original embeddings
points = np.array([[p['x'], p['y']] for p in data['points']])

# Define custom axis
start_idx = ${axisStartNode.id}
end_idx = ${axisEndNode.id}

# Direction vector (in current 2D space as demo)
direction = points[end_idx] - points[start_idx]
direction = direction / (np.linalg.norm(direction) + 1e-8)

# Orthogonal direction (90 degrees)
ortho = np.array([-direction[1], direction[0]])

# Project all points
x_new = (points - points[start_idx]) @ direction
y_new = (points - points[start_idx]) @ ortho

# Update point coordinates
for i, p in enumerate(data['points']):
    p['x'] = float(x_new[i])
    p['y'] = float(y_new[i])

# Update tree node coordinates
if data.get('trees'):
    for tree_name, tree in data['trees'].items():
        for node in tree['nodes']:
            node['x'] = float(x_new[node['id']])
            node['y'] = float(y_new[node['id']])

if data.get('tree'):
    for node in data['tree']['nodes']:
        node['x'] = float(x_new[node['id']])
        node['y'] = float(y_new[node['id']])

# Update peaks
if data.get('peaks'):
    for peak in data['peaks']:
        idx = peak['nearest_node_id']
        peak['x'] = float(x_new[idx])
        peak['y'] = float(y_new[idx])

# Update density grid bounds
xs, ys = x_new, y_new
padding = 0.1
x_range, y_range = xs.max() - xs.min(), ys.max() - ys.min()
data['density_grid']['x_min'] = float(xs.min() - padding * x_range)
data['density_grid']['x_max'] = float(xs.max() + padding * x_range)
data['density_grid']['y_min'] = float(ys.min() - padding * y_range)
data['density_grid']['y_max'] = float(ys.max() + padding * y_range)

# Update projection info
data['projection']['variance_explained'] = [50.0, 50.0]  # Custom projection

json.dumps(data)
                `);

                currentData = JSON.parse(result);
                currentData.projection.custom_axis = {
                    start: axisStartNode.title,
                    end: axisEndNode.title
                };
                renderPlot();
                updateInfo();
                setStatus('Custom projection applied');

            } catch (error) {
                setStatus(`Projection error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                applyProjectionBtn.disabled = false;
            }
        }

        function handleDatasetChange() {
            const value = datasetSelect.value;

            // Hide all conditional groups first
            customUrlGroup.style.display = 'none';
            const flaskApiGroup = document.getElementById('flaskApiGroup');
            if (flaskApiGroup) flaskApiGroup.style.display = 'none';

            // Handle embedding selector visibility for Flask API mode
            const embeddingsFlaskNote = document.getElementById('embeddingsFlaskNote');
            const isFlaskApi = value === 'flask-api';
            if (embeddingsFlaskNote) {
                embeddingsFlaskNote.style.display = isFlaskApi ? 'block' : 'none';
            }

            if (value === 'custom') {
                customUrlGroup.style.display = 'block';
            } else if (value === 'flask-api') {
                if (flaskApiGroup) flaskApiGroup.style.display = 'block';
            } else if (value === 'demo') {
                if (pyodideReady) {
                    recompute();
                } else {
                    setStatus('Pyodide not ready yet', 'error');
                }
            } else {
                loadDatasetUrl(value);
            }
        }

        // Flask API integration
        async function loadFromFlaskApi(rootId) {
            // Filter out click Event objects (from addEventListener)
            if (rootId instanceof Event) rootId = undefined;
            // Use current tree root or selected node if no explicit rootId provided
            // Pass title (string) since IDs may change between API calls
            if (rootId === undefined) {
                // First try the current tree's root (preserves user's root setting)
                const currentTree = currentData?.tree || currentData?.trees?.[activeTreeType];
                if (currentTree?.root_id != null && currentData?.points) {
                    const rootNode = currentData.points.find(p => p.id === currentTree.root_id);
                    if (rootNode) {
                        rootId = rootNode.title;  // Pass title, not ID
                    }
                } else if (selectedNode) {
                    // Fall back to selected node's title
                    rootId = selectedNode.title;
                }
            }
            const apiUrl = document.getElementById('flaskApiUrl').value;
            const dataset = document.getElementById('flaskDataset').value;
            const model = document.getElementById('flaskModel').value;
            const projectionMode = document.getElementById('flaskProjectionMode').value;
            const layoutDataset = document.getElementById('flaskLayoutDataset')?.value || '';
            const treeMetric = document.getElementById('flaskTreeMetric').value;
            const treeType = document.getElementById('flaskTreeType').value;
            const topK = parseInt(document.getElementById('flaskTopK').value) || 200;
            const statusEl = document.getElementById('flaskApiStatus');

            statusEl.textContent = 'Loading...';
            statusEl.style.color = '#f39c12';
            setStatus('Fetching from Flask API...', 'loading');

            try {
                // Read branching slider (value 20 = unlimited → don't send)
                const branchingVal = parseInt(controls.maxBranching.value);
                const maxBranching = branchingVal >= 20 ? null : branchingVal;

                // Read bandwidth: Flask input > Pyodide slider > auto
                const bwInput = document.getElementById('flaskBandwidth').value.trim();
                let bandwidth = bwInput ? parseFloat(bwInput) : null;
                // Fall back to Pyodide slider value if Flask input is empty
                if (bandwidth === null && controls.bandwidth.value) {
                    bandwidth = parseFloat(controls.bandwidth.value);
                }

                // Check if we have custom dual embeddings loaded
                // Skip dual embedding path when a projection model is selected,
                // because the model needs to transform the server-side dataset embeddings
                const hasProjectionModel = model && model !== 'None' && model !== '';
                const hasDualEmbeddings = !hasProjectionModel &&
                    layoutEmbeddings && treeEmbeddings &&
                    layoutEmbeddings !== treeEmbeddings &&
                    currentData?.points?.length > 0;

                console.log('Dual embedding check:', {
                    hasLayout: !!layoutEmbeddings,
                    hasTree: !!treeEmbeddings,
                    areDifferent: layoutEmbeddings !== treeEmbeddings,
                    hasPoints: currentData?.points?.length > 0,
                    layoutDim: layoutEmbeddings?.[0]?.length,
                    treeDim: treeEmbeddings?.[0]?.length,
                    hasProjectionModel,
                    hasDualEmbeddings
                });

                let response;

                if (hasDualEmbeddings) {
                    // Use /api/compute/from-embeddings with dual embeddings
                    const titles = currentData.points.map(p => p.title);
                    console.log('Using DUAL EMBEDDINGS path:', {
                        layoutShape: [layoutEmbeddings.length, layoutEmbeddings[0]?.length],
                        treeShape: [treeEmbeddings.length, treeEmbeddings[0]?.length],
                        titlesCount: titles.length
                    });

                    const requestBody = {
                        embeddings: layoutEmbeddings,
                        tree_embeddings: treeEmbeddings,
                        titles: titles,
                        include_tree: true,
                        include_peaks: true,
                        tree_type: treeType,
                        tree_distance_metric: treeMetric,
                        projection_mode: projectionMode
                    };

                    if (bandwidth !== null && !isNaN(bandwidth) && bandwidth > 0) {
                        requestBody.bandwidth = bandwidth;
                    }
                    if (maxBranching !== null) {
                        requestBody.max_branching = maxBranching;
                    }

                    setStatus('Sending dual embeddings to Flask API...', 'loading');
                    console.log('Calling /api/compute/from-embeddings');
                    response = await fetch(`${apiUrl}/api/compute/from-embeddings`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                } else {
                    // Use standard /api/compute with dataset
                    const requestBody = {
                        dataset: dataset,
                        top_k: topK,
                        include_tree: true,
                        include_peaks: true,
                        tree_type: treeType,
                        tree_distance_metric: treeMetric,
                        projection_mode: projectionMode
                    };

                    if (bandwidth !== null && !isNaN(bandwidth) && bandwidth > 0) {
                        requestBody.bandwidth = bandwidth;
                    }

                    if (maxBranching !== null) {
                        requestBody.max_branching = maxBranching;
                    }

                    if (rootId != null) {
                        requestBody.root_id = rootId;
                    }

                    if (model) {
                        requestBody.model = model;
                    }

                    // Layout dataset override: use different embeddings for 2D SVD layout
                    if (layoutDataset && model && projectionMode === 'embedding') {
                        requestBody.layout_dataset = layoutDataset;
                    }

                    response = await fetch(`${apiUrl}/api/compute`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody)
                    });
                }

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || `HTTP ${response.status}`);
                }

                currentData = await response.json();
                currentDatasetUrl = `flask-api:${dataset}`;
                originalData = null;
                clearAxisSelection();

                // Set tree type
                if (currentData.tree) {
                    currentData.trees = { [currentData.tree.tree_type]: currentData.tree };
                    activeTreeType = currentData.tree.tree_type;
                }

                // Preserve selected node across reloads
                if (selectedNode) {
                    const newNode = currentData.points.find(p => p.title === selectedNode.title);
                    if (newNode) {
                        selectedNode = newNode;
                        if (rootId != null) {
                            setStatus(`Loaded with root: "${selectedNode.title}"`);
                        }
                    }
                }

                renderPlot();
                updateInfo();
                updateTreeToggle();
                updateEmbeddingSelector();
                updateEmbeddingsInfo();

                // Show the actual bandwidth used as placeholder hint
                if (currentData.density_grid && currentData.density_grid.bandwidth != null) {
                    const bwEl = document.getElementById('flaskBandwidth');
                    if (!bwEl.value) {
                        bwEl.placeholder = `auto: ${currentData.density_grid.bandwidth.toFixed(4)}`;
                    }
                }

                const modeLabels = { 'embedding': 'Embedding', 'weights': 'Weight', 'learned': 'Learned Metric' };
                const treeLabels = { 'embedding': 'semantic', 'weights': 'hierarchical', 'learned': 'organizational' };
                const modeLabel = modeLabels[projectionMode] || projectionMode;
                const treeLabel = treeLabels[treeMetric] || treeMetric;
                statusEl.textContent = `Loaded ${currentData.n_points} pts (${modeLabel}, ${treeLabel})`;
                statusEl.style.color = '#27ae60';
                setStatus(`Loaded from API: ${currentData.n_points} points, ${modeLabel} space, ${treeLabel} tree`);

            } catch (error) {
                statusEl.textContent = `Error: ${error.message}`;
                statusEl.style.color = '#e74c3c';
                setStatus(`Flask API error: ${error.message}`, 'error');
                console.error('Flask API error:', error);
            }
        }

        async function loadDatasetUrl(url) {
            setStatus('Loading dataset...', 'loading');
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                currentData = await response.json();
                currentDatasetUrl = url;
                originalData = null;  // Clear original data for new dataset
                clearAxisSelection();
                activeTreeType = currentData.trees ? Object.keys(currentData.trees)[0] : 'mst';

                // Store original embeddings and determine type
                if (currentData.embeddings) {
                    originalEmbeddings = currentData.embeddings;
                    const dim = currentData.embeddings[0]?.length || 0;
                    currentEmbeddingType = dim === 384 ? 'minilm' : dim === 768 ? 'nomic' : 'current';
                } else {
                    originalEmbeddings = null;
                    currentEmbeddingType = 'none';
                }

                renderPlot();
                updateInfo();
                updateTreeToggle();
                updatePeaksList();
                updateEmbeddingsInfo();
                updateEmbeddingSelector();

                // Load embeddings into Pyodide if available
                if (pyodideReady && currentData.embeddings) {
                    await loadEmbeddingsIntoPyodide();
                    setStatus(`Dataset loaded (${currentData.embeddings.length} embeddings)`);
                } else {
                    setStatus('Dataset loaded' + (currentData.embeddings ? '' : ' (no embeddings)'));
                }
            } catch (error) {
                setStatus(`Failed to load: ${error.message}`, 'error');
                console.error(error);
            }
        }

        async function loadCustomUrl() {
            const url = customUrlInput.value.trim();
            if (!url) {
                setStatus('Please enter a URL', 'error');
                return;
            }
            await loadDatasetUrl(url);
        }

        // ============================================================
        // Tree Toggle
        // ============================================================
        function updateTreeToggle() {
            if (!currentData || !currentData.trees) return;

            treeToggle.innerHTML = '';
            for (const treeType of Object.keys(currentData.trees)) {
                const btn = document.createElement('button');
                btn.textContent = treeType.toUpperCase();
                btn.className = treeType === activeTreeType ? 'active' : '';
                btn.onclick = () => selectTree(treeType);
                treeToggle.appendChild(btn);
            }
        }

        function selectTree(treeType) {
            activeTreeType = treeType;
            updateTreeToggle();
            renderPlot();
            document.getElementById('infoTree').textContent = treeType;
        }

        // ============================================================
        // Export Functions
        // ============================================================
        function exportMindmap() {
            if (!currentData) {
                setStatus('No data to export', 'error');
                return;
            }

            // Get the current tree
            const tree = currentData.trees?.[activeTreeType] || currentData.tree;
            if (!tree || !tree.nodes || tree.nodes.length === 0) {
                setStatus('No tree data to export', 'error');
                return;
            }

            // Filter by max depth
            const maxDepth = parseInt(controls.maxDepth.value);
            const branchingVal = parseInt(controls.maxBranching.value);
            const maxBranching = branchingVal >= 20 ? Infinity : branchingVal;

            const depthFiltered = new Set(
                tree.nodes.filter(n => n.depth <= maxDepth).map(n => n.id)
            );

            // Filter edges by depth, then apply branching limit per parent
            const depthEdges = tree.edges.filter(e =>
                depthFiltered.has(e.source_id) && depthFiltered.has(e.target_id)
            );

            // Group by parent, sort by weight, keep maxBranching closest
            const edgesByParent = {};
            for (const e of depthEdges) {
                if (!edgesByParent[e.source_id]) edgesByParent[e.source_id] = [];
                edgesByParent[e.source_id].push(e);
            }
            const keptEdges = [];
            for (const children of Object.values(edgesByParent)) {
                children.sort((a, b) => a.weight - b.weight);
                keptEdges.push(...children.slice(0, maxBranching));
            }

            // Find reachable nodes from root through kept edges
            const adjMap = {};
            for (const e of keptEdges) {
                if (!adjMap[e.source_id]) adjMap[e.source_id] = [];
                adjMap[e.source_id].push(e.target_id);
            }
            const reachable = new Set([tree.root_id]);
            const queue = [tree.root_id];
            let qi = 0;
            while (qi < queue.length) {
                const node = queue[qi++];
                for (const child of (adjMap[node] || [])) {
                    if (!reachable.has(child)) {
                        reachable.add(child);
                        queue.push(child);
                    }
                }
            }

            const filteredNodes = tree.nodes.filter(n => reachable.has(n.id));
            const filteredEdges = keptEdges.filter(e =>
                reachable.has(e.source_id) && reachable.has(e.target_id)
            );

            // Get export format
            const format = exportFormatSelect.value;

            // Generate filename
            const rootNode = filteredNodes.find(n => n.id === tree.root_id);
            const rootName = rootNode?.title || 'density_tree';
            const sanitizedName = rootName.replace(/[<>:"/\\|?*]/g, '').replace(/\s+/g, '_').slice(0, 50);
            const timestamp = new Date().toISOString().slice(0, 10);

            switch (format) {
                case 'vue':
                    exportVUE(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'mm':
                    exportFreeMind(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'mermaid':
                    exportMermaid(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'opml':
                    exportOPML(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'graphml':
                    exportGraphML(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'smmx':
                    exportSMMX(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
                case 'json':
                    exportJSON(filteredNodes, filteredEdges, tree.root_id, sanitizedName, timestamp);
                    break;
            }
        }

        function exportVUE(nodes, edges, rootId, name, timestamp) {
            // VUE format is an XML format used by Visual Understanding Environment
            // Build a simple VUE document with nodes and links

            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            // Scale coordinates for VUE (use x,y from projection, scale up)
            const scale = 200;
            const offsetX = 500;
            const offsetY = 400;

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<!-- VUE Concept Map - Visual Understanding Environment -->\n';
            xml += '<!-- Generated by Density Manifold Explorer -->\n';
            xml += `<LW-MAP xmlns="urn:lw" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" ID="1" label="${escapeXml(name)}" created="${timestamp}">\n`;

            // Add nodes as child elements
            nodes.forEach((node, i) => {
                const x = Math.round((node.x * scale) + offsetX);
                const y = Math.round((node.y * scale) + offsetY);
                const isRoot = node.id === rootId;

                xml += `  <node ID="${node.id}" label="${escapeXml(node.title)}" x="${x}" y="${y}"`;
                if (isRoot) {
                    xml += ' shape="roundRect" strokeWidth="2"';
                } else {
                    xml += ' shape="ellipse"';
                }
                xml += `/>\n`;
            });

            // Add edges as links
            edges.forEach((edge, i) => {
                xml += `  <link ID="link_${i}" ID1="${edge.source_id}" ID2="${edge.target_id}"/>\n`;
            });

            xml += '</LW-MAP>\n';

            // Download as .vue file
            downloadFile(xml, `${name}_${timestamp}.vue`, 'application/xml');
            setStatus(`Exported ${nodes.length} nodes as VUE`);
        }

        async function exportSMMX(nodes, edges, rootId, name, timestamp) {
            // SimpleMind format: ZIP containing document/mindmap.xml
            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            // Build XML
            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<!DOCTYPE simplemind-mindmaps>\n';
            xml += '<simplemind-mindmaps generator="DensityExplorer" gen-version="1.0.0" doc-version="3">\n';
            xml += '  <mindmap>\n';
            xml += '    <meta>\n';
            xml += `      <guid guid="${generateGuid()}"/>\n`;
            xml += `      <title text="${escapeXml(name)}"/>\n`;
            xml += '      <style key="system.soft-palette"/>\n';
            xml += '      <auto-numbering style="disabled"/>\n';
            xml += '      <scrollstate zoom="50" x="0" y="0"/>\n';
            xml += `      <main-centraltheme id="${rootId}"/>\n`;
            xml += '    </meta>\n';
            xml += '    <topics>\n';

            // Scale coordinates
            const scale = 150;

            // Helper to create Wikipedia URL from title
            function titleToWikipediaUrl(title) {
                const encoded = encodeURIComponent(title.replace(/ /g, '_'));
                return `https://en.wikipedia.org/wiki/${encoded}`;
            }

            // Add topics
            nodes.forEach(node => {
                const x = (node.x * scale).toFixed(2);
                const y = (node.y * scale).toFixed(2);
                const isRoot = node.id === rootId;
                const parentId = node.parent_id !== null ? node.parent_id : -1;
                const palette = (node.depth % 8) + 1;
                const wikiUrl = titleToWikipediaUrl(node.title);

                xml += `      <topic id="${node.id}" parent="${parentId}" guid="${generateGuid()}" `;
                xml += `x="${x}" y="${y}" palette="${palette}" colorinfo="${palette}" `;
                xml += `text="${escapeXml(node.title)}">\n`;

                // Add arrow based on entropy: flows from general (low entropy) to specific (high entropy)
                if (!isRoot && parentId !== -1) {
                    const parentNode = nodeMap[parentId];
                    const childEntropy = node.entropy || 0;
                    const parentEntropy = parentNode?.entropy || 0;

                    xml += `        <parent-relation guid="${generateGuid()}">\n`;
                    if (parentEntropy < childEntropy) {
                        // Parent is more general → arrow points to child (target-arrow)
                        xml += '          <style target-arrow="filledArrow"/>\n';
                    } else {
                        // Child is more general → arrow points to parent (source-arrow)
                        xml += '          <style source-arrow="filledArrow"/>\n';
                    }
                    xml += '        </parent-relation>\n';
                }

                // Add Wikipedia link
                xml += `        <link urllink="${escapeXml(wikiUrl)}"/>\n`;

                if (isRoot) {
                    xml += '        <layout mode="radial" direction="auto" flow="default"/>\n';
                    xml += '        <style>\n';
                    xml += '          <font bold="True" scale="2.0"/>\n';
                    xml += '        </style>\n';
                }
                xml += '      </topic>\n';
            });

            xml += '    </topics>\n';
            xml += '    <relations/>\n';
            xml += '  </mindmap>\n';
            xml += '</simplemind-mindmaps>\n';

            // Create ZIP
            const zip = new JSZip();
            zip.file('document/mindmap.xml', xml);

            const blob = await zip.generateAsync({ type: 'blob' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}_${timestamp}.smmx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            setStatus(`Exported ${nodes.length} nodes as SimpleMind`);
        }

        function exportJSON(nodes, edges, rootId, name, timestamp) {
            const data = {
                name: name,
                created: timestamp,
                tree_type: activeTreeType,
                root_id: rootId,
                nodes: nodes.map(n => ({
                    id: n.id,
                    title: n.title,
                    x: n.x,
                    y: n.y,
                    depth: n.depth,
                    parent_id: n.parent_id
                })),
                edges: edges.map(e => ({
                    source_id: e.source_id,
                    target_id: e.target_id,
                    weight: e.weight
                }))
            };

            downloadFile(JSON.stringify(data, null, 2), `${name}_${timestamp}.json`, 'application/json');
            setStatus(`Exported ${nodes.length} nodes as JSON`);
        }

        function exportFreeMind(nodes, edges, rootId, name, timestamp) {
            // FreeMind/Freeplane format - hierarchical XML
            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            // Build children map
            const children = {};
            nodes.forEach(n => { children[n.id] = []; });
            nodes.forEach(n => {
                if (n.parent_id !== null && children[n.parent_id]) {
                    children[n.parent_id].push(n);
                }
            });

            const rootNode = nodeMap[rootId];

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<map version="1.0.1">\n';
            xml += '<!-- Exported from Density Manifold Explorer -->\n';

            function writeNode(node, indent, isFirst) {
                const spaces = '  '.repeat(indent);
                let position = '';
                if (indent === 1) {
                    position = isFirst ? ' POSITION="right"' : ' POSITION="left"';
                }
                xml += `${spaces}<node TEXT="${escapeXml(node.title)}"${position}>\n`;

                const nodeChildren = children[node.id] || [];
                nodeChildren.forEach((child, i) => {
                    writeNode(child, indent + 1, i < nodeChildren.length / 2);
                });

                xml += `${spaces}</node>\n`;
            }

            writeNode(rootNode, 0, true);
            xml += '</map>\n';

            downloadFile(xml, `${name}_${timestamp}.mm`, 'application/xml');
            setStatus(`Exported ${nodes.length} nodes as FreeMind`);
        }

        function exportMermaid(nodes, edges, rootId, name, timestamp) {
            // Mermaid flowchart format for GitHub/GitLab/Obsidian
            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            // Build children map
            const children = {};
            nodes.forEach(n => { children[n.id] = []; });
            nodes.forEach(n => {
                if (n.parent_id !== null && children[n.parent_id]) {
                    children[n.parent_id].push(n);
                }
            });

            // Escape text for Mermaid (avoid special chars)
            function escapeMermaid(text) {
                return String(text)
                    .replace(/"/g, "'")
                    .replace(/\[/g, '(')
                    .replace(/\]/g, ')')
                    .replace(/</g, '(')
                    .replace(/>/g, ')')
                    .replace(/#/g, '')
                    .replace(/\n/g, ' ');
            }

            let md = `# ${name}\n\n`;
            md += `Generated: ${timestamp}\n\n`;
            md += '```mermaid\nflowchart TD\n';

            // Define root node with rounded shape
            const rootNode = nodeMap[rootId];
            md += `    ${rootId}(["${escapeMermaid(rootNode.title)}"])\n`;

            // Define other nodes and connections
            function writeNodes(node, depth) {
                const nodeChildren = children[node.id] || [];
                nodeChildren.forEach(child => {
                    // Different shapes based on depth
                    let shape;
                    if (depth === 1) {
                        shape = `[["${escapeMermaid(child.title)}"]]`; // Square
                    } else if (depth === 2) {
                        shape = `{{"${escapeMermaid(child.title)}"}}`; // Hexagon
                    } else {
                        shape = `["${escapeMermaid(child.title)}"]`; // Default
                    }
                    md += `    ${child.id}${shape}\n`;
                    md += `    ${node.id} --> ${child.id}\n`;
                    writeNodes(child, depth + 1);
                });
            }

            writeNodes(rootNode, 1);
            md += '```\n';

            downloadFile(md, `${name}_${timestamp}.md`, 'text/markdown');
            setStatus(`Exported ${nodes.length} nodes as Mermaid`);
        }

        function exportOPML(nodes, edges, rootId, name, timestamp) {
            // OPML - Outline Processor Markup Language
            const nodeMap = {};
            nodes.forEach(n => { nodeMap[n.id] = n; });

            // Build children map
            const children = {};
            nodes.forEach(n => { children[n.id] = []; });
            nodes.forEach(n => {
                if (n.parent_id !== null && children[n.parent_id]) {
                    children[n.parent_id].push(n);
                }
            });

            const rootNode = nodeMap[rootId];

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<opml version="2.0">\n';
            xml += '  <head>\n';
            xml += `    <title>${escapeXml(name)}</title>\n`;
            xml += '    <expansionState>0</expansionState>\n';
            xml += '  </head>\n';
            xml += '  <body>\n';

            function writeOutline(node, indent) {
                const spaces = '  '.repeat(indent);
                const nodeChildren = children[node.id] || [];

                if (nodeChildren.length > 0) {
                    xml += `${spaces}<outline text="${escapeXml(node.title)}">\n`;
                    nodeChildren.forEach(child => writeOutline(child, indent + 1));
                    xml += `${spaces}</outline>\n`;
                } else {
                    xml += `${spaces}<outline text="${escapeXml(node.title)}"/>\n`;
                }
            }

            writeOutline(rootNode, 2);
            xml += '  </body>\n';
            xml += '</opml>\n';

            downloadFile(xml, `${name}_${timestamp}.opml`, 'application/xml');
            setStatus(`Exported ${nodes.length} nodes as OPML`);
        }

        function exportGraphML(nodes, edges, rootId, name, timestamp) {
            // GraphML - yEd compatible
            const scale = 100;
            const fillColors = [
                "#E8E8E8", "#FFD6D6", "#FFE8D6", "#FFFFD6",
                "#D6FFD6", "#D6FFFF", "#D6D6FF", "#FFD6FF"
            ];

            let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
            xml += '<graphml xmlns="http://graphml.graphdrawing.org/xmlns"\n';
            xml += '         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n';
            xml += '         xmlns:y="http://www.yworks.com/xml/graphml"\n';
            xml += '         xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://www.yworks.com/xml/schema/graphml/1.1/ygraphml.xsd">\n';
            xml += '  <key for="node" id="d0" yfiles.type="nodegraphics"/>\n';
            xml += '  <key for="edge" id="d1" yfiles.type="edgegraphics"/>\n';
            xml += `  <graph id="${escapeXml(name)}" edgedefault="directed">\n`;

            // Write nodes
            nodes.forEach(node => {
                const fill = fillColors[node.depth % fillColors.length];
                const width = Math.max(80, node.title.length * 7 + 20);
                const height = 30;
                const x = node.x * scale;
                const y = node.y * scale;

                xml += `    <node id="n${node.id}">\n`;
                xml += '      <data key="d0">\n';
                xml += '        <y:ShapeNode>\n';
                xml += `          <y:Geometry x="${x.toFixed(1)}" y="${y.toFixed(1)}" width="${width.toFixed(1)}" height="${height.toFixed(1)}"/>\n`;
                xml += `          <y:Fill color="${fill}" transparent="false"/>\n`;
                xml += '          <y:BorderStyle type="line" width="1.0" color="#000000"/>\n';
                xml += `          <y:NodeLabel>${escapeXml(node.title)}</y:NodeLabel>\n`;
                xml += '          <y:Shape type="roundrectangle"/>\n';
                xml += '        </y:ShapeNode>\n';
                xml += '      </data>\n';
                xml += '    </node>\n';
            });

            // Write edges
            edges.forEach((edge, i) => {
                xml += `    <edge id="e${i}" source="n${edge.source_id}" target="n${edge.target_id}">\n`;
                xml += '      <data key="d1">\n';
                xml += '        <y:PolyLineEdge>\n';
                xml += '          <y:LineStyle type="line" width="1.0" color="#000000"/>\n';
                xml += '          <y:Arrows source="none" target="standard"/>\n';
                xml += '        </y:PolyLineEdge>\n';
                xml += '      </data>\n';
                xml += '    </edge>\n';
            });

            xml += '  </graph>\n';
            xml += '</graphml>\n';

            downloadFile(xml, `${name}_${timestamp}.graphml`, 'application/xml');
            setStatus(`Exported ${nodes.length} nodes as GraphML`);
        }

        function escapeXml(str) {
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function generateGuid() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            }).toUpperCase();
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ============================================================
        // Rendering
        // ============================================================
        function renderPlot() {
            if (!currentData) return;

            const traces = [];
            const grid = currentData.density_grid;

            // Grid coordinates
            const xi = linspace(grid.x_min, grid.x_max, grid.grid_size);
            const yi = linspace(grid.y_min, grid.y_max, grid.grid_size);

            // Heatmap
            traces.push({
                type: 'heatmap', z: grid.values, x: xi, y: yi,
                colorscale: 'Viridis', showscale: true,
                colorbar: { title: 'Density' }, hoverinfo: 'skip', opacity: 0.8
            });

            // Contours
            if (controls.showContours.checked) {
                traces.push({
                    type: 'contour', z: grid.values, x: xi, y: yi,
                    showscale: false, contours: { coloring: 'lines', showlabels: false },
                    line: { width: 1, color: 'white' }, opacity: 0.5, hoverinfo: 'skip'
                });
            }

            // Tree
            const tree = currentData.trees ? currentData.trees[activeTreeType] : currentData.tree;
            if (controls.showTree.checked && tree) {
                const maxDepth = parseInt(controls.maxDepth.value);
                const maxBranchingRaw = parseInt(controls.maxBranching.value);
                const maxBranching = maxBranchingRaw >= 20 ? Infinity : maxBranchingRaw;
                const nodeMap = {};
                tree.nodes.forEach(n => nodeMap[n.id] = n);

                // Build reachable node set via BFS from root with depth+branching limits
                // This prevents orphan subtrees from appearing when branching prunes parent edges
                const childCount = {};
                const reachable = new Set([tree.root_id]);

                // Group edges by source, sorted by weight (closest first)
                const edgesBySource = {};
                for (const edge of tree.edges) {
                    if (!edgesBySource[edge.source_id]) edgesBySource[edge.source_id] = [];
                    edgesBySource[edge.source_id].push(edge);
                }
                for (const sid in edgesBySource) {
                    edgesBySource[sid].sort((a, b) => a.weight - b.weight);
                }

                // BFS: only follow edges where target depth ≤ maxDepth and parent has room
                const bfsQueue = [tree.root_id];
                const keptEdges = [];
                while (bfsQueue.length > 0) {
                    const nodeId = bfsQueue.shift();
                    const edges = edgesBySource[nodeId] || [];
                    for (const edge of edges) {
                        const target = nodeMap[edge.target_id];
                        if (!target || reachable.has(edge.target_id)) continue;
                        if (target.depth > maxDepth) continue;
                        const pc = childCount[nodeId] || 0;
                        if (pc >= maxBranching) continue;
                        childCount[nodeId] = pc + 1;
                        reachable.add(edge.target_id);
                        keptEdges.push(edge);
                        bfsQueue.push(edge.target_id);
                    }
                }

                // Collect arrow positions and angles
                const arrowX = [];
                const arrowY = [];
                const arrowAngles = [];

                for (const edge of keptEdges) {
                    const source = nodeMap[edge.source_id];
                    const target = nodeMap[edge.target_id];

                    traces.push({
                        type: 'scatter', x: [source.x, target.x], y: [source.y, target.y],
                        mode: 'lines', line: { color: 'cyan', width: 1 },
                        opacity: 0.6, hoverinfo: 'skip', showlegend: false
                    });

                    // Calculate arrow position and angle based on mode
                    if (controls.showArrows.checked) {
                        const mode = controls.arrowMode.value;
                        const t = 0.7;  // Position along edge
                        const ax = source.x + t * (target.x - source.x);
                        const ay = source.y + t * (target.y - source.y);

                        let angle;
                        if (mode === 'radial') {
                            // Point away from root position
                            const root = nodeMap[tree.root_id];
                            angle = Math.atan2(ay - root.y, ax - root.x) * 180 / Math.PI;
                        } else {
                            // Hierarchical: point from parent to child (general → specific)
                            angle = Math.atan2(target.y - source.y, target.x - source.x) * 180 / Math.PI;
                        }

                        arrowX.push(ax);
                        arrowY.push(ay);
                        arrowAngles.push(angle);
                    }
                }

                // Add arrowheads as a single trace
                if (controls.showArrows.checked && arrowX.length > 0) {
                    traces.push({
                        type: 'scatter',
                        x: arrowX,
                        y: arrowY,
                        mode: 'markers',
                        marker: {
                            size: 8,
                            color: 'cyan',
                            symbol: arrowAngles.map(a => `triangle-right`),
                            angle: arrowAngles,
                            opacity: 0.8
                        },
                        hoverinfo: 'skip',
                        showlegend: false
                    });
                }

                // Root
                const root = nodeMap[tree.root_id];
                traces.push({
                    type: 'scatter', x: [root.x], y: [root.y],
                    mode: 'markers', marker: { size: 15, color: 'cyan', symbol: 'square' },
                    name: `Root: ${root.title.substring(0, 25)}`,
                    hoverinfo: 'text', hovertext: root.title
                });
            }

            // Points
            if (controls.showPoints.checked) {
                traces.push({
                    type: 'scatter',
                    x: currentData.points.map(p => p.x),
                    y: currentData.points.map(p => p.y),
                    mode: 'markers', marker: { size: 6, color: 'red', opacity: 0.7 },
                    name: `Points (n=${currentData.n_points})`,
                    hoverinfo: 'text', hovertext: currentData.points.map(p => p.title)
                });
            }

            // Highlighted node (from search)
            if (highlightedNodeId !== null) {
                const highlightedNode = currentData.points.find(p => p.id === highlightedNodeId);
                if (highlightedNode) {
                    traces.push({
                        type: 'scatter',
                        x: [highlightedNode.x],
                        y: [highlightedNode.y],
                        mode: 'markers+text',
                        marker: { size: 16, color: '#00ff00', symbol: 'circle', line: { width: 2, color: 'white' } },
                        text: [highlightedNode.title],
                        textposition: 'top center',
                        textfont: { size: 11, color: '#00ff00' },
                        name: 'Selected',
                        hoverinfo: 'text',
                        hovertext: [highlightedNode.title],
                        showlegend: false
                    });
                }
            }

            // Peaks
            if (controls.showPeaks.checked && currentData.peaks) {
                traces.push({
                    type: 'scatter',
                    x: currentData.peaks.map(p => p.x),
                    y: currentData.peaks.map(p => p.y),
                    mode: 'markers+text',
                    marker: { size: 12, color: 'yellow', symbol: 'star' },
                    text: currentData.peaks.map(p => p.title.substring(0, 20)),
                    textposition: 'top center',
                    textfont: { size: 10, color: 'white' },
                    name: 'Density Peaks',
                    hoverinfo: 'text',
                    hovertext: currentData.peaks.map(p => `${p.title} (density: ${p.density.toFixed(2)})`)
                });
            }

            const layout = {
                title: `Density Manifold (${currentData.n_points} points)`,
                xaxis: { title: `${currentData.projection.mode && currentData.projection.mode.includes('mds') ? 'MDS' : 'SVD'} 1 (${currentData.projection.variance_explained[0].toFixed(1)}%)`, scaleanchor: 'y' },
                yaxis: { title: `${currentData.projection.mode && currentData.projection.mode.includes('mds') ? 'MDS' : 'SVD'} 2 (${currentData.projection.variance_explained[1].toFixed(1)}%)` },
                showlegend: true, legend: { yanchor: 'top', y: 0.99, xanchor: 'right', x: 0.99 },
                paper_bgcolor: '#1a1a2e', plot_bgcolor: '#1a1a2e', font: { color: '#eee' },
                uirevision: 'preserve'  // Preserves zoom/pan across updates
            };

            Plotly.react('plot', traces, layout, { responsive: true });

            // Attach click handler for custom projection mode
            document.getElementById('plot').removeAllListeners?.('plotly_click');
            document.getElementById('plot').on('plotly_click', handlePlotClick);
        }

        function linspace(start, end, num) {
            const arr = [], step = (end - start) / (num - 1);
            for (let i = 0; i < num; i++) arr.push(start + step * i);
            return arr;
        }

        // ============================================================
        // Info & Status
        // ============================================================
        function updateInfo() {
            if (!currentData) return;
            document.getElementById('infoPoints').textContent = currentData.n_points;
            document.getElementById('infoBandwidth').textContent = currentData.density_grid.bandwidth.toFixed(3);
            document.getElementById('infoTree').textContent = activeTreeType;

            if (currentData.projection.custom_axis) {
                document.getElementById('infoVar1').textContent = 'Custom';
                document.getElementById('infoVar2').textContent = 'Axis';
            } else {
                document.getElementById('infoVar1').textContent = currentData.projection.variance_explained[0].toFixed(1) + '%';
                document.getElementById('infoVar2').textContent = currentData.projection.variance_explained[1].toFixed(1) + '%';
            }
        }

        function updatePeaksList() {
            const list = document.getElementById('peaksList');
            if (!currentData?.peaks?.length) { list.innerHTML = ''; return; }
            list.innerHTML = '<h2>Peaks</h2>' + currentData.peaks.map((p, i) => `
                <div class="peak-item" onclick="focusPeak(${i})">
                    <span class="name">${i + 1}. ${p.title}</span>
                    <span class="density">density: ${p.density.toFixed(3)}</span>
                </div>
            `).join('');
        }

        function focusPeak(index) {
            const peak = currentData.peaks[index];
            // Could zoom to peak location
            console.log('Focus peak:', peak);
        }

        function setStatus(text, type = '') {
            statusText.textContent = text;
            document.getElementById('status').className = 'status ' + type;
        }

        // ============================================================
        // Recompute (Pyodide)
        // ============================================================
        async function recompute() {
            if (!pyodideReady) return;

            computeBtn.disabled = true;
            setStatus('Computing...', 'loading');

            try {
                const nPoints = parseInt(controls.nPoints.value);
                const bandwidth = parseFloat(controls.bandwidth.value);
                const gridSize = parseInt(controls.gridSize.value);

                // Pass root title if one is selected
                const rootTitle = selectedNode ? selectedNode.title : null;
                const rootArg = rootTitle ? `"${rootTitle.replace(/"/g, '\\"')}"` : 'None';

                // Check if we should apply projection blending
                const blend = parseFloat(embedBlendSlider.value);
                // Use originalEmbeddings if available, otherwise currentData.embeddings
                const sourceEmbeddings = originalEmbeddings || currentData?.embeddings;
                const useProjection = projectionSession && blend > 0 && sourceEmbeddings;

                if (useProjection) {
                    setStatus('Applying projection blend...', 'loading');
                    const blendedEmbeddings = await applyProjectionToEmbeddings(sourceEmbeddings);
                    const titles = currentData.points.map(p => p.title);

                    // Send blended embeddings to Pyodide
                    pyodide.globals.set('_js_embeddings', blendedEmbeddings);
                    pyodide.globals.set('_js_titles', titles);
                    await pyodide.runPythonAsync(`
set_real_embeddings(_js_embeddings.to_py(), list(_js_titles))
                    `);
                    console.log(`Loaded ${blendedEmbeddings.length} blended embeddings (blend=${blend})`);
                    setStatus('Computing with blended embeddings...', 'loading');
                }

                const result = await pyodide.runPythonAsync(`
import json
# Check for dual embeddings (separate layout vs tree)
if has_dual_embeddings():
    layout_emb, tree_emb, titles = get_dual_embeddings(${nPoints}, root_title=${rootArg})
    _used_real = True
    data = compute_density_manifold(layout_emb, titles, bandwidth=${bandwidth}, grid_size=${gridSize}, n_peaks=5, tree_embeddings=tree_emb)
else:
    embeddings, titles = get_embeddings(${nPoints}, root_title=${rootArg})
    _used_real = has_real_embeddings()
    data = compute_density_manifold(embeddings, titles, bandwidth=${bandwidth}, grid_size=${gridSize}, n_peaks=5)
json.dumps({'data': data, 'used_real': _used_real})
                `);

                const parsed = JSON.parse(result);
                currentData = parsed.data;
                const usedReal = parsed.used_real;

                // Restore original embeddings so projection can be tested again
                if (originalEmbeddings) {
                    currentData.embeddings = originalEmbeddings;
                }

                // Clear original trees since we have fresh ones
                originalTrees = null;

                // Re-apply custom root if one was selected
                if (selectedNode) {
                    // Find the node in new data (might have different index)
                    const newNode = currentData.points.find(p => p.title === selectedNode.title);
                    if (newNode) {
                        // Store originals before re-rooting
                        if (currentData.trees) {
                            originalTrees = JSON.parse(JSON.stringify(currentData.trees));
                            for (const tree of Object.values(currentData.trees)) {
                                rerootTree(tree, newNode.id);
                            }
                        } else if (currentData.tree) {
                            originalTrees = { [activeTreeType]: JSON.parse(JSON.stringify(currentData.tree)) };
                            rerootTree(currentData.tree, newNode.id);
                        }
                        // Update selectedNode to new reference
                        selectedNode = newNode;
                        selectNodeForRoot(newNode);
                    }
                }

                renderPlot();
                updateInfo();
                updateTreeToggle();
                updatePeaksList();
                const rootMsg = selectedNode ? ` centered on "${selectedNode.title}"` : '';
                const blendMsg = useProjection ? `, blend=${blend.toFixed(2)}` : '';
                setStatus(`Recomputed ${nPoints} points (${usedReal ? 'real' : 'demo'}${blendMsg})${rootMsg}`);

            } catch (error) {
                setStatus(`Error: ${error.message}`, 'error');
                console.error(error);
            } finally {
                computeBtn.disabled = false;
            }
        }

        // ============================================================
        // Start
        // ============================================================
        init();
    </script>
</body>
</html>
