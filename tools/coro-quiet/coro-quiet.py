#!/usr/bin/env python3
"""coro-quiet: Clean output wrapper for coro-code CLI

Filters coro output to reduce noise:
- Collapses multiple blank lines into one
- Accumulates token/cost info and shows summary at end
- Preserves ANSI colors and markdown formatting

Generated by UnifyWeaver from quiet_module.pl
"""

import subprocess
import sys
import re
import os
from collections import defaultdict

# Token/cost patterns to capture (generated from Prolog)
TOKEN_PATTERNS = [
    r'Tokens:\s*(\d+)\s+input\s+\+\s*(\d+)\s+output\s+=\s*(\d+)\s+total',
    r'Duration:\s*([\d.]+)s',
    r'Executed\s+(\d+)\s+steps',
    r'^Cost:\s*\$'
]

MAX_CONSECUTIVE_BLANKS = 1

def main():
    args = sys.argv[1:]

    # Pass through help (but not interactive mode)
    if args and args[0] in ['-h', '--help']:
        print("coro-quiet: Clean output wrapper for coro-code")
        print()
        print("Usage: coro-quiet [coro args...]")
        print()
        print("Examples:")
        print("  coro-quiet \"explain this code\"")
        print("  coro-quiet -p \"review changes\"")
        print("  coro-quiet --model sonnet \"fix the bug\"")
        print()
        print("Passes all arguments to coro, filters output to:")
        print("  - Collapse consecutive blank lines")
        print("  - Show token/cost summary at end")
        print()
        if args:
            # Also show coro help
            os.execvp('coro', ['coro'] + args)
        return 0

    # Run coro with all arguments
    try:
        proc = subprocess.Popen(
            ['coro'] + args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )
    except FileNotFoundError:
        print("Error: 'coro' command not found. Is coro-code installed?", file=sys.stderr)
        return 1

    blank_count = 0
    stats = defaultdict(list)

    try:
        for line in proc.stdout:
            # Check for token/cost lines
            if is_stats_line(line):
                capture_stats(line, stats)
                continue  # Don't print stats lines

            # Handle blank lines - collapse multiples
            if line.strip() == '':
                blank_count += 1
                if blank_count <= MAX_CONSECUTIVE_BLANKS:
                    print(line, end='', flush=True)
                continue

            blank_count = 0
            print(line, end='', flush=True)
    except KeyboardInterrupt:
        proc.terminate()
        return 130

    proc.wait()

    # Print stats summary at end
    if stats:
        print()
        print("--- Session Summary ---")
        for key in ['Input', 'Output', 'Total']:
            if key in stats:
                total = sum(stats[key])
                print(f"{key}: {total:,} tokens")
        if 'Steps' in stats:
            total_steps = sum(stats['Steps'])
            print(f"Steps: {total_steps}")
        if 'Duration' in stats:
            total_duration = sum(stats['Duration'])
            print(f"Duration: {total_duration:.2f}s")
        if 'Cost' in stats:
            total_cost = sum(stats['Cost'])
            print(f"Cost: ${total_cost:.4f}")

    return proc.returncode

def is_stats_line(line):
    """Check if line contains token/cost info to capture."""
    return any(re.search(p, line) for p in TOKEN_PATTERNS)

def capture_stats(line, stats):
    """Extract and accumulate stats from line."""
    # Coro token format: Tokens: 7779 input + 344 output = 8123 total
    match = re.search(r'Tokens:\s*(\d+)\s+input\s+\+\s*(\d+)\s+output\s+=\s*(\d+)\s+total', line)
    if match:
        stats['Input'].append(int(match.group(1)))
        stats['Output'].append(int(match.group(2)))
        stats['Total'].append(int(match.group(3)))
        return

    # Duration: 6.74s
    match = re.search(r'Duration:\s*([\d.]+)s', line)
    if match:
        stats['Duration'].append(float(match.group(1)))
        return

    # Executed N steps
    match = re.search(r'Executed\s+(\d+)\s+steps', line)
    if match:
        stats['Steps'].append(int(match.group(1)))
        return

    # Cost
    match = re.search(r'Cost:\s*\$([\d.]+)', line)
    if match:
        stats['Cost'].append(float(match.group(1)))

if __name__ == '__main__':
    sys.exit(main())
