:- module(quiet_module, [generate_all/0]).

/** <module> coro-quiet - Clean coro-code Output Wrapper

Generates a Python wrapper that filters coro-code CLI output:
- Collapses multiple consecutive blank lines into one
- Accumulates token usage and shows summary at end
- Preserves ANSI colors and markdown formatting

Usage:
  swipl -g "consult('quiet_module.pl'), quiet_module:generate_all" -t halt

@author UnifyWeaver
*/

%% Configuration

% Token usage patterns to capture and summarize (coro-code format)
token_pattern("Tokens:\\s*(\\d+)\\s+input\\s+\\+\\s*(\\d+)\\s+output\\s+=\\s*(\\d+)\\s+total").
token_pattern("Duration:\\s*([\\d.]+)s").
token_pattern("Executed\\s+(\\d+)\\s+steps").
token_pattern("^Cost:\\s*\\$").

% Output settings
config(max_consecutive_blanks, 1).
config(show_token_summary, true).
config(preserve_ansi, true).

%% Code Generation

generate_all :-
    format('Generating coro-quiet...~n~n'),

    generate_python(PyCode),
    open('coro-quiet.py', write, S1),
    write(S1, PyCode),
    close(S1),
    format('  Created: coro-quiet.py~n'),

    generate_readme(Readme),
    open('README.md', write, S2),
    write(S2, Readme),
    close(S2),
    format('  Created: README.md~n'),

    format('~nDone!~n'),
    format('  chmod +x coro-quiet.py~n'),
    format('  ./coro-quiet.py [coro args]~n').

%% Python Generator

generate_python(Code) :-
    findall(P, token_pattern(P), Patterns),
    patterns_to_python_list(Patterns, PatternList),
    config(max_consecutive_blanks, MaxBlanks),
    format(string(Code),
'#!/usr/bin/env python3
"""coro-quiet: Clean output wrapper for coro-code CLI

Filters coro output to reduce noise:
- Collapses multiple blank lines into one
- Accumulates token/cost info and shows summary at end
- Preserves ANSI colors and markdown formatting

Generated by UnifyWeaver from quiet_module.pl
"""

import subprocess
import sys
import re
import os
from collections import defaultdict

# Token/cost patterns to capture (generated from Prolog)
TOKEN_PATTERNS = [
~w
]

MAX_CONSECUTIVE_BLANKS = ~d

def main():
    args = sys.argv[1:]

    # Pass through help (but not interactive mode)
    if args and args[0] in [\'-h\', \'--help\']:
        print("coro-quiet: Clean output wrapper for coro-code")
        print()
        print("Usage: coro-quiet [coro args...]")
        print()
        print("Examples:")
        print("  coro-quiet \\"explain this code\\"")
        print("  coro-quiet -p \\"review changes\\"")
        print("  coro-quiet --model sonnet \\"fix the bug\\"")
        print()
        print("Passes all arguments to coro, filters output to:")
        print("  - Collapse consecutive blank lines")
        print("  - Show token/cost summary at end")
        print()
        if args:
            # Also show coro help
            os.execvp(\'coro\', [\'coro\'] + args)
        return 0

    # Run coro with all arguments
    try:
        proc = subprocess.Popen(
            [\'coro\'] + args,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            text=True,
            bufsize=1
        )
    except FileNotFoundError:
        print("Error: \'coro\' command not found. Is coro-code installed?", file=sys.stderr)
        return 1

    blank_count = 0
    stats = defaultdict(list)

    try:
        for line in proc.stdout:
            # Check for token/cost lines
            if is_stats_line(line):
                capture_stats(line, stats)
                continue  # Don\'t print stats lines

            # Handle blank lines - collapse multiples
            if line.strip() == \'\':
                blank_count += 1
                if blank_count <= MAX_CONSECUTIVE_BLANKS:
                    print(line, end=\'\', flush=True)
                continue

            blank_count = 0
            print(line, end=\'\', flush=True)
    except KeyboardInterrupt:
        proc.terminate()
        return 130

    proc.wait()

    # Print stats summary at end
    if stats:
        print()
        print("--- Session Summary ---")
        for key in [\'Input\', \'Output\', \'Total\']:
            if key in stats:
                total = sum(stats[key])
                print(f"{key}: {total:,} tokens")
        if \'Steps\' in stats:
            total_steps = sum(stats[\'Steps\'])
            print(f"Steps: {total_steps}")
        if \'Duration\' in stats:
            total_duration = sum(stats[\'Duration\'])
            print(f"Duration: {total_duration:.2f}s")
        if \'Cost\' in stats:
            total_cost = sum(stats[\'Cost\'])
            print(f"Cost: ${total_cost:.4f}")

    return proc.returncode

def is_stats_line(line):
    """Check if line contains token/cost info to capture."""
    return any(re.search(p, line) for p in TOKEN_PATTERNS)

def capture_stats(line, stats):
    """Extract and accumulate stats from line."""
    # Coro token format: Tokens: 7779 input + 344 output = 8123 total
    match = re.search(r\'Tokens:\\s*(\\d+)\\s+input\\s+\\+\\s*(\\d+)\\s+output\\s+=\\s*(\\d+)\\s+total\', line)
    if match:
        stats[\'Input\'].append(int(match.group(1)))
        stats[\'Output\'].append(int(match.group(2)))
        stats[\'Total\'].append(int(match.group(3)))
        return

    # Duration: 6.74s
    match = re.search(r\'Duration:\\s*([\\d.]+)s\', line)
    if match:
        stats[\'Duration\'].append(float(match.group(1)))
        return

    # Executed N steps
    match = re.search(r\'Executed\\s+(\\d+)\\s+steps\', line)
    if match:
        stats[\'Steps\'].append(int(match.group(1)))
        return

    # Cost
    match = re.search(r\'Cost:\\s*\\$([\\d.]+)\', line)
    if match:
        stats[\'Cost\'].append(float(match.group(1)))

if __name__ == \'__main__\':
    sys.exit(main())
', [PatternList, MaxBlanks]).

patterns_to_python_list([], "").
patterns_to_python_list([P], Line) :-
    format(string(Line), '    r\'~w\'', [P]).
patterns_to_python_list([P|Rest], Lines) :-
    Rest \= [],
    format(string(First), '    r\'~w\',~n', [P]),
    patterns_to_python_list(Rest, RestLines),
    string_concat(First, RestLines, Lines).

%% README Generator

generate_readme(Code) :-
    format(string(Code),
'# coro-quiet

Clean output wrapper for coro-code CLI.

**Generated** from `quiet_module.pl` - do not edit directly.

## Features

- Collapses multiple consecutive blank lines into one
- Captures token usage and cost, shows summary at end
- Preserves ANSI colors and markdown formatting
- Passes all arguments through to `coro`

## Generate

```bash
cd tools/coro-quiet
swipl -g "consult(\'quiet_module.pl\'), quiet_module:generate_all" -t halt
```

## Install

```bash
chmod +x coro-quiet.py

# Option 1: Symlink to PATH
ln -s $(pwd)/coro-quiet.py ~~/.local/bin/coro-quiet

# Option 2: Alias
echo "alias coro-quiet=\'$(pwd)/coro-quiet.py\'" >> ~~/.bashrc
```

## Usage

```bash
# Single-task mode (recommended)
coro-quiet "explain this code"
coro-quiet --verbose "fix the bug"  # captures token stats

# Interactive mode (limited filtering - TUI uses cursor control)
coro-quiet

# Help
coro-quiet --help
```

## Example Output

Before (coro):
```
[blank line]
[blank line]
Input: 1,234 tokens
Output: 567 tokens
[blank line]
Here is the response...
[blank line]
[blank line]
[blank line]
Input: 890 tokens
Output: 123 tokens
```

After (coro-quiet):
```

Here is the response...

--- Session Summary ---
Input: 2,124 tokens
Output: 690 tokens
```

## Configuration

Edit `quiet_module.pl` to customize:

- `token_pattern/1` - Patterns to capture and summarize
- `config(max_consecutive_blanks, N)` - Max blank lines to keep
- `config(show_token_summary, Bool)` - Show/hide summary

Then regenerate.
', []).
