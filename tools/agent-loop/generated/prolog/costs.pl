%% costs — Token cost tracking
%% Auto-generated by agent_loop_module.pl
%% DO NOT EDIT — regenerate with:
%%   swipl -g "generate_all(prolog), halt" agent_loop_module.pl

:- module(costs, [
    model_pricing/3,
    cost_tracker_init/1,
    cost_tracker_add/4,
    cost_tracker_total/2,
    cost_tracker_format/2
]).

%% model_pricing(+Model, +InputPricePerMTok, +OutputPricePerMTok)
model_pricing("claude-opus-4-20250514", 15.0, 75.0).
model_pricing("claude-sonnet-4-20250514", 3.0, 15.0).
model_pricing("claude-haiku-3-5-20241022", 0.8, 4.0).
model_pricing("opus", 15.0, 75.0).
model_pricing("sonnet", 3.0, 15.0).
model_pricing("haiku", 0.8, 4.0).
model_pricing("gpt-4o", 2.5, 10.0).
model_pricing("gpt-4o-mini", 0.15, 0.6).
model_pricing("gpt-4-turbo", 10.0, 30.0).
model_pricing("gpt-4", 30.0, 60.0).
model_pricing("gpt-3.5-turbo", 0.5, 1.5).
model_pricing("gemini-2.5-flash", 0.075, 0.3).
model_pricing("gemini-2.5-pro", 1.25, 5.0).
model_pricing("llama3", 0.0, 0.0).
model_pricing("codellama", 0.0, 0.0).
model_pricing("mistral", 0.0, 0.0).

%% Cost tracker using dynamic state
:- dynamic cost_state/3.  %% cost_state(TrackerID, TotalInputTokens, TotalOutputTokens)

cost_tracker_init(ID) :-
    retractall(cost_state(ID, _, _)),
    assert(cost_state(ID, 0, 0)).

cost_tracker_add(ID, Model, InputTokens, OutputTokens) :-
    retract(cost_state(ID, OldIn, OldOut)),
    NewIn is OldIn + InputTokens,
    NewOut is OldOut + OutputTokens,
    assert(cost_state(ID, NewIn, NewOut)),
    (model_pricing(Model, InPrice, OutPrice) ->
        Cost is (InputTokens * InPrice + OutputTokens * OutPrice) / 1000000,
        format("  [cost: $~4f (~w in, ~w out)]~n", [Cost, InputTokens, OutputTokens])
    ; true).

cost_tracker_total(ID, Total) :-
    cost_state(ID, TotalIn, TotalOut),
    Total = tokens(TotalIn, TotalOut).

cost_tracker_format(ID, Formatted) :-
    cost_state(ID, TotalIn, TotalOut),
    format(atom(Formatted), "~w input, ~w output tokens", [TotalIn, TotalOut]).
