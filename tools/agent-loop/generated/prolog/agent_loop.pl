%% agent_loop — Main agent loop REPL
%% Auto-generated by agent_loop_module.pl
%% DO NOT EDIT — regenerate with:
%%   swipl -g "generate_all(prolog), halt" agent_loop_module.pl

:- module(agent_loop, [
    agent_loop/1,
    agent_loop/0
]).

:- use_module(config).
:- use_module(tools).
:- use_module(backends).
:- use_module(commands).
:- use_module(security).
:- use_module(costs).

:- dynamic conversation/1.
conversation([]).

%% Entry point with default options
agent_loop :- agent_loop([]).

%% Entry point with CLI args
agent_loop(Args) :-
    parse_cli_args(Args, Options),
    (member(backend(BName), Options), BName \= none ->
        true
    ; BName = coro),
    create_backend(BName, Options, Backend),
    (member(security_profile(Prof), Options), Prof \= none ->
        set_security_profile(Prof)
    ; true),
    cost_tracker_init(main),
    format("uwsal — Prolog agent loop (backend: ~w)~n", [BName]),
    write("Type /help for commands, /exit to quit."), nl,
    repl_loop(Backend).

%% Main read-eval-print loop
repl_loop(Backend) :-
    write("> "),
    flush_output,
    read_line_to_string(user_input, Input),
    (Input = end_of_file -> write("Goodbye."), nl
    ; Input = "" -> repl_loop(Backend)
    ; process_input(Input, Backend) -> repl_loop(Backend)
    ; repl_loop(Backend)).

%% Process user input: slash command or LLM request
process_input(Input, Backend) :-
    (atom_concat('/', _, Input) ->
        %% Slash command
        atom_string(InputAtom, Input),
        handle_slash_command(InputAtom, "", Action),
        handle_action(Action, Backend)
    ;
        %% LLM request
        conversation(History),
        UserMsg = _{role: "user", content: Input},
        append(History, [UserMsg], Messages),
        %% Build tool specs
        findall(ToolSpec, (
            tool_spec(TName, TProps),
            member(description(TDesc), TProps),
            ToolSpec = _{name: TName, description: TDesc}
        ), ToolSpecs),
        send_request(Backend, Messages, ToolSpecs, Response),
        handle_response(Backend, Response, Messages)
    ).

%% Handle LLM response, including tool calls
handle_response(Backend, Response, Messages) :-
    (get_dict(content, Response, Content), Content \= "" ->
        write(Content), nl
    ; true),
    (get_dict(tool_calls, Response, ToolCalls), ToolCalls \= [] ->
        handle_tool_calls(Backend, ToolCalls, Messages, Response)
    ;
        AsstMsg = _{role: "assistant", content: Content},
        append(Messages, [AsstMsg], NewMsgs),
        retractall(conversation(_)),
        assert(conversation(NewMsgs))
    ).

%% Execute tool calls and continue conversation
handle_tool_calls(Backend, ToolCalls, Messages, _AsstResponse) :-
    AsstMsg = _{role: "assistant", content: "", tool_calls: ToolCalls},
    append(Messages, [AsstMsg], Msgs1),
    execute_tool_calls(Backend, ToolCalls, ToolResults),
    append(Msgs1, ToolResults, Msgs2),
    findall(TS, (tool_spec(TN, TP), member(description(TD), TP),
        TS = _{name: TN, description: TD}), TSList),
    send_request(Backend, Msgs2, TSList, NextResponse),
    handle_response(Backend, NextResponse, Msgs2).

%% Execute a list of tool calls, collecting results
execute_tool_calls(_Backend, [], []).
execute_tool_calls(Backend, [TC|Rest], [Result|Results]) :-
    get_dict(name, TC, ToolName),
    get_dict(arguments, TC, Params),
    atom_string(ToolAtom, ToolName),
    describe_tool_call(Backend, ToolAtom, Params, Desc),
    format("[tool] ~w~n", [Desc]),
    (confirm_destructive(ToolAtom, true) ->
        execute_tool(ToolAtom, Params, ToolResult),
        (ToolResult = ok(Output) -> Content = Output ; ToolResult = error(Err) -> Content = Err),
        (get_dict(id, TC, TCID) -> true ; TCID = ""),
        Result = _{role: "tool", content: Content, tool_call_id: TCID}
    ;
        Result = _{role: "tool", content: "Execution denied by user", tool_call_id: ""}
    ),
    execute_tool_calls(Backend, Rest, Results).

%% Handle slash command actions
handle_action(exit, _) :- write("Goodbye."), nl, halt.
handle_action(clear, _) :-
    retractall(conversation(_)),
    assert(conversation([])),
    write("Context cleared."), nl.
handle_action(help, _) :-
    write("Available commands:"), nl,
    forall(slash_command(Name, _Match, _Opts, Help), (
        format("  /~w — ~w~n", [Name, Help])
    )).
handle_action(status, Backend) :-
    get_dict(name, Backend, BName),
    conversation(Msgs),
    length(Msgs, MsgCount),
    cost_tracker_format(main, CostStr),
    format("Backend: ~w~nMessages: ~w~nTokens: ~w~n", [BName, MsgCount, CostStr]).
handle_action(not_a_command, _) :- write("Unknown command."), nl.
handle_action(unknown(Cmd), _) :- format("Unknown command: /~w~n", [Cmd]).
handle_action(call_handler(Handler, _Args), _) :-
    format("Handler ~w not yet implemented in Prolog target.~n", [Handler]).
