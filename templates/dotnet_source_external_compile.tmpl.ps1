# {{pred}} - .NET external compilation source
# Generated by UnifyWeaver - External C# compilation via dotnet build
# Namespace: {{namespace}}
# Class: {{class_name}}
# Method: {{method_name}}

function {{pred}} {
    param([Parameter(ValueFromPipeline=$true)]$InputData)

    begin {
        $projectName = "{{pred}}_{{class_name}}"
        $projectDir = Join-Path $PSScriptRoot "tmp/$projectName"
        $csFile = Join-Path $projectDir "{{class_name}}.cs"
        $csprojFile = Join-Path $projectDir "$projectName.csproj"
        $outputDir = Join-Path $projectDir "bin/Debug/net8.0"
        $compiledDll = Join-Path $outputDir "$projectName.dll"

        # Create project directory
        if (-not (Test-Path $projectDir)) {
            New-Item -ItemType Directory -Path $projectDir -Force | Out-Null
        }

        # Write C# source code
        $csharpCode = @'
{{csharp_code}}
'@
        Set-Content -Path $csFile -Value $csharpCode

        # Write .csproj file
        $csprojContent = @'
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <EnableDynamicLoading>true</EnableDynamicLoading>
    <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
    <OutputPath>$(MSBuildProjectDirectory)/bin/Debug/net8.0</OutputPath>
  </PropertyGroup>

  <ItemGroup>
{{package_references}}
  </ItemGroup>
  <ItemGroup>
{{assembly_references}}
  </ItemGroup>

</Project>
'@
        Set-Content -Path $csprojFile -Value $csprojContent

        Write-Verbose "[{{pred}}] Building C# project '$projectName'..."
        # Run dotnet restore
        $restoreResult = dotnet restore $projectDir
        if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet restore failed for '$projectName': $restoreResult"
            throw "dotnet restore failed"
        }

        # Run dotnet build
        $buildResult = dotnet build $projectDir --no-restore
        if ($LASTEXITCODE -ne 0) {
            Write-Error "dotnet build failed for '$projectName': $buildResult"
            throw "dotnet build failed"
        }

        # Load the compiled DLL
        if (-not (Test-Path $compiledDll)) {
            Write-Error "Compiled DLL not found at $compiledDll"
            throw "Compiled DLL not found"
        }

        try {
            Add-Type -Path $compiledDll -ErrorAction Stop
            Write-Verbose "[{{pred}}] Loaded compiled assembly from '$compiledDll'"
        } catch {
            Write-Error "Failed to load compiled DLL: $_"
            throw
        }

        # Create instance of the class
        $handler = New-Object {{namespace}}.{{class_name}}
    }

    process {
        try {
            # Call the method with input data
            if ($InputData) {
                $result = $handler.{{method_name}}($InputData)
            } else {
                $result = $handler.{{method_name}}()
            }

            # Output result
            Write-Output $result
        } catch {
            Write-Error "Error executing {{method_name}}: $_"
        }
    }

    end {
        # Cleanup if needed
        $handler = $null
    }
}

function {{pred}}_stream {
    $input | {{pred}}
}

# Auto-execute when run directly (not when dot-sourced)
if ($MyInvocation.InvocationName -ne '.') {
    {{pred}} @args
}
