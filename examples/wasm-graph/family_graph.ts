// Generated by UnifyWeaver LLVM Target - TypeScript String Bindings

interface WasmExports extends WebAssembly.Exports {
  memory: WebAssembly.Memory;
  alloc(size: number): number;
  dealloc(ptr: number, size: number): void;
  addEdge(fromPtr: number, fromLen: number, toPtr: number, toLen: number): void;
  getEdgeCount(): number;
  getEdge(idx: number): number;
}

export class GraphWasm {
  private exports: WasmExports;
  private memory: WebAssembly.Memory;
  private encoder = new TextEncoder();
  private decoder = new TextDecoder();

  private constructor(instance: WebAssembly.Instance) {
    this.exports = instance.exports as WasmExports;
    this.memory = this.exports.memory;
  }

  static async load(wasmPath: string): Promise<GraphWasm> {
    const response = await fetch(wasmPath);
    const bytes = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(bytes);
    return new GraphWasm(instance);
  }

  private encodeString(str: string): [number, number] {
    const bytes = this.encoder.encode(str);
    const ptr = this.exports.alloc(bytes.length + 1);
    const view = new Uint8Array(this.memory.buffer, ptr, bytes.length + 1);
    view.set(bytes);
    view[bytes.length] = 0; // Null terminator
    return [ptr, bytes.length];
  }

  private decodeString(ptr: number, len: number): string {
    const view = new Uint8Array(this.memory.buffer, ptr, len);
    return this.decoder.decode(view);
  }

  addEdge(from: string, to: string): void {
    const [fromPtr, fromLen] = this.encodeString(from);
    const [toPtr, toLen] = this.encodeString(to);
    this.exports.addEdge(fromPtr, fromLen, toPtr, toLen);
  }

  getEdgeCount(): number {
    return this.exports.getEdgeCount();
  }

  getEdges(): [string, string][] {
    const count = this.getEdgeCount();
    const edges: [string, string][] = [];
    const memory = new Int32Array(this.memory.buffer);
    
    for (let i = 0; i < count; i++) {
      const basePtr = this.exports.getEdge(i);
      const base = basePtr / 4; // Convert to i32 index
      const fromPtr = memory[base];
      const fromLen = memory[base + 1];
      const toPtr = memory[base + 2];
      const toLen = memory[base + 3];
      
      edges.push([
        this.decodeString(fromPtr, fromLen),
        this.decodeString(toPtr, toLen)
      ]);
    }
    return edges;
  }

  ancestor(node: string): string[] {
    const [ptr, len] = this.encodeString(node);
    const resultCount = this.exports.ancestor(ptr, len);
    // Collect results (simplified)
    return [];
  }
}
