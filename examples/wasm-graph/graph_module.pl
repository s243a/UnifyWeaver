% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% graph_module.pl - Graph Visualization Module
%
% Generates complete graph visualization app from Prolog specifications.
% Uses Cytoscape.js for browser-based graph rendering.
%
% Pipeline: Prolog -> HTML + JavaScript (Cytoscape.js)
%
% Usage:
%   swipl -g "consult('graph_module.pl'), graph_module:generate_all" -t halt

:- encoding(utf8).

:- module(graph_module, [
    % Graph definition
    node/2,                    % node(+Id, +Properties)
    edge/3,                    % edge(+From, +To, +Properties)
    graph_config/1,            % graph_config(-Config)

    % Code generation
    generate_html/1,           % generate_html(-HTMLCode)
    generate_ts_bindings/1,    % generate_ts_bindings(-TSCode)
    generate_all/0             % generate_all - writes all files
]).

:- use_module(library(lists)).

%% ============================================
%% GRAPH DEFINITION - Family Tree Example
%% ============================================

% Graph configuration
graph_config([
    title("Family Tree"),
    description("Biblical family relationships"),
    layout(cose),
    theme(dark),
    node_color('#7c3aed'),
    edge_color('#00d4ff'),
    selected_color('#ffd700')
]).

% Nodes with properties
node(abraham, [label("Abraham"), type(person), generation(1)]).
node(sarah, [label("Sarah"), type(person), generation(1)]).
node(hagar, [label("Hagar"), type(person), generation(1)]).
node(ishmael, [label("Ishmael"), type(person), generation(2)]).
node(isaac, [label("Isaac"), type(person), generation(2)]).
node(rebekah, [label("Rebekah"), type(person), generation(2)]).
node(esau, [label("Esau"), type(person), generation(3)]).
node(jacob, [label("Jacob"), type(person), generation(3)]).

% Edges with properties (parent relationships)
edge(abraham, ishmael, [relation(parent), via(hagar)]).
edge(hagar, ishmael, [relation(parent)]).
edge(abraham, isaac, [relation(parent), via(sarah)]).
edge(sarah, isaac, [relation(parent)]).
edge(isaac, esau, [relation(parent)]).
edge(isaac, jacob, [relation(parent)]).
edge(rebekah, esau, [relation(parent)]).
edge(rebekah, jacob, [relation(parent)]).

%% ============================================
%% QUERY HELPERS
%% ============================================

%% all_nodes(-Nodes)
all_nodes(Nodes) :-
    findall(node(Id, Props), node(Id, Props), Nodes).

%% all_edges(-Edges)
all_edges(Edges) :-
    findall(edge(From, To, Props), edge(From, To, Props), Edges).

%% node_to_json(+Node, -JSON)
node_to_json(node(Id, Props), JSON) :-
    atom_string(Id, IdStr),
    (member(label(Label), Props) -> true ; Label = IdStr),
    format(string(JSON), '      { data: { id: "~w", label: "~w" } }', [IdStr, Label]).

%% edge_to_json(+Edge, +Index, -JSON)
edge_to_json(edge(From, To, _Props), Idx, JSON) :-
    atom_string(From, FromStr),
    atom_string(To, ToStr),
    format(string(JSON), '      { data: { id: "e~w", source: "~w", target: "~w" } }', [Idx, FromStr, ToStr]).

%% ============================================
%% MAIN GENERATION
%% ============================================

generate_all :-
    format('Generating graph visualization files...~n~n'),

    % Generate HTML
    generate_html(HTMLCode),
    open('index.html', write, S1),
    write(S1, HTMLCode),
    close(S1),
    format('  Created: index.html~n'),

    % Generate TypeScript bindings
    generate_ts_bindings(TSCode),
    open('graph_wasm.ts', write, S2),
    write(S2, TSCode),
    close(S2),
    format('  Created: graph_wasm.ts~n'),

    format('~nDone! Open index.html in a browser to view.~n'),
    format('Or run: python3 -m http.server 8080~n').

%% ============================================
%% HTML GENERATION
%% ============================================

generate_html(Code) :-
    generate_html_css(CSS),
    generate_html_body(Body),
    generate_html_javascript(JS),
    format(string(Code),
"<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
  <title>WASM Graph Visualization - UnifyWeaver</title>
  <!-- Generated by UnifyWeaver graph_module.pl -->
  <style>
~w
  </style>
</head>
<body>
~w
  <script src=\"https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js\"></script>
  <script type=\"module\">
~w
  </script>
</body>
</html>
", [CSS, Body, JS]).

%% generate_html_css(-CSS)
generate_html_css(CSS) :-
    CSS = "    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh;
    }
    header {
      padding: 1.5rem 2rem;
      background: rgba(255,255,255,0.05);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle { color: #888; font-size: 0.9rem; margin-top: 0.25rem; }
    main {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: calc(100vh - 80px);
    }
    .sidebar {
      padding: 1.5rem;
      background: rgba(0,0,0,0.2);
      border-right: 1px solid rgba(255,255,255,0.1);
      overflow-y: auto;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #888;
      margin-bottom: 1rem;
    }
    .controls { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem; }
    .input-group { display: flex; gap: 0.5rem; }
    input, select {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      font-size: 0.9rem;
    }
    input::placeholder { color: #666; }
    button {
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
    }
    button:hover { opacity: 0.9; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.secondary { background: rgba(255,255,255,0.1); }
    button.danger { background: linear-gradient(135deg, #ff6b6b, #ee5a5a); }
    .node-list, .edge-list { margin-top: 1rem; }
    .item {
      padding: 0.5rem 0.75rem;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .item .name { color: #00d4ff; font-weight: 500; }
    .item .relation { font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; color: #aaa; }
    .item button { padding: 0.25rem 0.5rem; font-size: 0.75rem; }
    #graph { width: 100%; height: 100%; }
    .status {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(0,0,0,0.7);
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .status.loading { color: #ffd700; }
    .status.ready { color: #00ff00; }
    .info-panel {
      padding: 1rem;
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      margin-top: 1rem;
    }
    .info-panel h3 { font-size: 0.9rem; margin-bottom: 0.5rem; color: #00d4ff; }
    .info-panel p { font-size: 0.85rem; color: #aaa; }
    .layout-buttons { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .layout-buttons button { flex: 1; min-width: 80px; }".

%% generate_html_body(-Body)
generate_html_body(Body) :-
    graph_config(Config),
    (member(title(Title), Config) -> true ; Title = "Graph"),
    (member(description(Desc), Config) -> true ; Desc = "Generated by UnifyWeaver"),
    format(string(Body),
"  <header>
    <h1>~w</h1>
    <div class=\"subtitle\">~w</div>
  </header>
  <main>
    <div class=\"sidebar\">
      <h2>Layout</h2>
      <div class=\"layout-buttons\">
        <button onclick=\"setLayout('cose')\">Force</button>
        <button onclick=\"setLayout('circle')\">Circle</button>
        <button onclick=\"setLayout('grid')\">Grid</button>
        <button onclick=\"setLayout('breadthfirst')\">Tree</button>
      </div>

      <h2 style=\"margin-top: 1.5rem\">Add Edge</h2>
      <div class=\"controls\">
        <div class=\"input-group\">
          <input type=\"text\" id=\"fromNode\" placeholder=\"From node\">
          <input type=\"text\" id=\"toNode\" placeholder=\"To node\">
        </div>
        <button onclick=\"addEdge()\">Add Edge</button>
      </div>

      <div class=\"controls\">
        <button class=\"secondary\" onclick=\"loadSampleData()\">Load Sample Data</button>
        <button class=\"secondary\" onclick=\"fitGraph()\">Fit to View</button>
        <button class=\"danger\" onclick=\"clearGraph()\">Clear All</button>
      </div>

      <div id=\"selectedInfo\" class=\"info-panel\" style=\"display: none;\">
        <h3>Selected Node</h3>
        <p id=\"selectedNodeInfo\"></p>
      </div>

      <div class=\"edge-list\">
        <h2>Edges (<span id=\"edgeCount\">0</span>)</h2>
        <div id=\"edges\"></div>
      </div>
    </div>
    <div id=\"graph\"></div>
  </main>
  <div id=\"status\" class=\"status loading\">Initializing...</div>", [Title, Desc]).

%% generate_html_javascript(-JS)
generate_html_javascript(JS) :-
    graph_config(Config),
    (member(node_color(NodeColor), Config) -> true ; NodeColor = '#7c3aed'),
    (member(edge_color(EdgeColor), Config) -> true ; EdgeColor = '#00d4ff'),
    (member(selected_color(SelectedColor), Config) -> true ; SelectedColor = '#ffd700'),
    (member(layout(DefaultLayout), Config) -> true ; DefaultLayout = cose),

    % Generate initial graph data from Prolog definitions
    generate_graph_data_js(GraphDataJS),

    format(string(JS),
"    // Graph Visualization - Generated by UnifyWeaver
    let cy;
    const nodeColor = '~w';
    const edgeColor = '~w';
    const selectedColor = '~w';

    // Initial graph data from Prolog
~w

    function init() {
      cy = cytoscape({
        container: document.getElementById('graph'),
        elements: initialData,
        style: [
          {
            selector: 'node',
            style: {
              'background-color': nodeColor,
              'label': 'data(label)',
              'color': '#fff',
              'text-valign': 'center',
              'text-halign': 'center',
              'font-size': '12px',
              'width': '50px',
              'height': '50px',
              'border-width': '2px',
              'border-color': nodeColor
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 2,
              'line-color': edgeColor,
              'target-arrow-color': edgeColor,
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier'
            }
          },
          {
            selector: 'node:selected',
            style: {
              'border-width': '4px',
              'border-color': selectedColor
            }
          }
        ],
        layout: { name: '~w', animate: true }
      });

      cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        document.getElementById('selectedInfo').style.display = 'block';
        document.getElementById('selectedNodeInfo').textContent =
          `ID: $${node.id()}, Label: $${node.data('label')}`;
      });

      cy.on('tap', function(evt) {
        if (evt.target === cy) {
          document.getElementById('selectedInfo').style.display = 'none';
        }
      });

      updateEdgeList();
      document.getElementById('status').textContent = 'Ready';
      document.getElementById('status').className = 'status ready';
    }

    window.setLayout = function(name) {
      cy.layout({ name, animate: true }).run();
    };

    window.addEdge = function() {
      const from = document.getElementById('fromNode').value.trim();
      const to = document.getElementById('toNode').value.trim();
      if (!from || !to) return;

      // Add nodes if they don't exist
      if (!cy.$(`#$${from}`).length) {
        cy.add({ data: { id: from, label: from } });
      }
      if (!cy.$(`#$${to}`).length) {
        cy.add({ data: { id: to, label: to } });
      }

      // Add edge
      const edgeId = `e_$${from}_$${to}`;
      if (!cy.$(`#$${edgeId}`).length) {
        cy.add({ data: { id: edgeId, source: from, target: to } });
      }

      cy.layout({ name: 'cose', animate: true }).run();
      updateEdgeList();

      document.getElementById('fromNode').value = '';
      document.getElementById('toNode').value = '';
    };

    window.loadSampleData = function() {
      cy.elements().remove();
      cy.add(initialData);
      cy.layout({ name: 'cose', animate: true }).run();
      updateEdgeList();
    };

    window.fitGraph = function() {
      cy.fit();
    };

    window.clearGraph = function() {
      cy.elements().remove();
      updateEdgeList();
      document.getElementById('selectedInfo').style.display = 'none';
    };

    window.removeEdge = function(edgeId) {
      cy.$(`#$${edgeId}`).remove();
      // Remove orphan nodes
      cy.nodes().forEach(node => {
        if (node.degree() === 0) node.remove();
      });
      updateEdgeList();
    };

    function updateEdgeList() {
      const edges = cy.edges();
      document.getElementById('edgeCount').textContent = edges.length;
      document.getElementById('edges').innerHTML = edges.map(e =>
        `<div class=\"item\">
          <span class=\"relation\"><span class=\"name\">$${e.source().id()}</span> → <span class=\"name\">$${e.target().id()}</span></span>
          <button class=\"danger\" onclick=\"removeEdge('$${e.id()}')\">×</button>
        </div>`
      ).join('');
    }

    init();", [NodeColor, EdgeColor, SelectedColor, GraphDataJS, DefaultLayout]).

%% generate_graph_data_js(-JS)
%  Generate JavaScript array of initial graph data from Prolog definitions
generate_graph_data_js(JS) :-
    all_nodes(Nodes),
    all_edges(Edges),

    % Generate node JSON
    findall(NodeJSON, (
        member(Node, Nodes),
        node_to_json(Node, NodeJSON)
    ), NodeJSONs),
    atomic_list_concat(NodeJSONs, ',\n', NodesSection),

    % Generate edge JSON with indices
    findall(EdgeJSON, (
        nth0(Idx, Edges, Edge),
        edge_to_json(Edge, Idx, EdgeJSON)
    ), EdgeJSONs),
    atomic_list_concat(EdgeJSONs, ',\n', EdgesSection),

    format(string(JS),
"    const initialData = [
      // Nodes
~w,
      // Edges
~w
    ];", [NodesSection, EdgesSection]).

%% ============================================
%% TYPESCRIPT BINDINGS GENERATION
%% ============================================

generate_ts_bindings(Code) :-
    Code = "// Generated by UnifyWeaver - Graph WASM TypeScript Bindings
// This provides a TypeScript class for interacting with graph WASM modules

interface WasmExports extends WebAssembly.Exports {
  memory: WebAssembly.Memory;
  alloc(size: number): number;
  dealloc(ptr: number, size: number): void;
  addEdge(fromPtr: number, fromLen: number, toPtr: number, toLen: number): void;
  removeEdge(fromPtr: number, fromLen: number, toPtr: number, toLen: number): void;
  getEdgeCount(): number;
  getEdge(idx: number): number;
  hasPath(fromPtr: number, fromLen: number, toPtr: number, toLen: number): number;
}

export interface GraphNode {
  id: string;
  label: string;
  properties?: Record<string, unknown>;
}

export interface GraphEdge {
  source: string;
  target: string;
  properties?: Record<string, unknown>;
}

export class GraphWasm {
  private exports: WasmExports | null = null;
  private memory: WebAssembly.Memory | null = null;
  private encoder = new TextEncoder();
  private decoder = new TextDecoder();

  // Fallback in-memory storage when WASM not available
  private nodes: Map<string, GraphNode> = new Map();
  private edges: GraphEdge[] = [];
  private useWasm = false;

  private constructor() {}

  static async load(wasmPath?: string): Promise<GraphWasm> {
    const instance = new GraphWasm();

    if (wasmPath) {
      try {
        const response = await fetch(wasmPath);
        if (response.ok) {
          const bytes = await response.arrayBuffer();
          const { instance: wasmInstance } = await WebAssembly.instantiate(bytes);
          instance.exports = wasmInstance.exports as WasmExports;
          instance.memory = instance.exports.memory;
          instance.useWasm = true;
          console.log('GraphWasm: Using WASM backend');
        }
      } catch (e) {
        console.log('GraphWasm: WASM not available, using JS fallback');
      }
    }

    return instance;
  }

  private encodeString(str: string): [number, number] {
    if (!this.exports || !this.memory) throw new Error('WASM not loaded');
    const bytes = this.encoder.encode(str);
    const ptr = this.exports.alloc(bytes.length + 1);
    const view = new Uint8Array(this.memory.buffer, ptr, bytes.length + 1);
    view.set(bytes);
    view[bytes.length] = 0;
    return [ptr, bytes.length];
  }

  private decodeString(ptr: number, len: number): string {
    if (!this.memory) throw new Error('WASM not loaded');
    const view = new Uint8Array(this.memory.buffer, ptr, len);
    return this.decoder.decode(view);
  }

  addNode(id: string, label?: string): void {
    this.nodes.set(id, { id, label: label || id });
  }

  addEdge(from: string, to: string): void {
    if (this.useWasm && this.exports) {
      const [fromPtr, fromLen] = this.encodeString(from);
      const [toPtr, toLen] = this.encodeString(to);
      this.exports.addEdge(fromPtr, fromLen, toPtr, toLen);
    } else {
      // Ensure nodes exist
      if (!this.nodes.has(from)) this.addNode(from);
      if (!this.nodes.has(to)) this.addNode(to);
      this.edges.push({ source: from, target: to });
    }
  }

  removeEdge(from: string, to: string): void {
    if (this.useWasm && this.exports) {
      const [fromPtr, fromLen] = this.encodeString(from);
      const [toPtr, toLen] = this.encodeString(to);
      this.exports.removeEdge(fromPtr, fromLen, toPtr, toLen);
    } else {
      this.edges = this.edges.filter(e => !(e.source === from && e.target === to));
    }
  }

  getNodes(): GraphNode[] {
    return Array.from(this.nodes.values());
  }

  getEdges(): GraphEdge[] {
    if (this.useWasm && this.exports && this.memory) {
      const count = this.exports.getEdgeCount();
      const edges: GraphEdge[] = [];
      const memory = new Int32Array(this.memory.buffer);

      for (let i = 0; i < count; i++) {
        const basePtr = this.exports.getEdge(i);
        const base = basePtr / 4;
        const fromPtr = memory[base];
        const fromLen = memory[base + 1];
        const toPtr = memory[base + 2];
        const toLen = memory[base + 3];

        edges.push({
          source: this.decodeString(fromPtr, fromLen),
          target: this.decodeString(toPtr, toLen)
        });
      }
      return edges;
    }
    return this.edges;
  }

  getEdgeCount(): number {
    if (this.useWasm && this.exports) {
      return this.exports.getEdgeCount();
    }
    return this.edges.length;
  }

  clear(): void {
    this.nodes.clear();
    this.edges = [];
  }

  // Convert to Cytoscape.js format
  toCytoscapeElements(): object[] {
    const nodes = this.getNodes().map(n => ({
      data: { id: n.id, label: n.label }
    }));
    const edges = this.getEdges().map((e, i) => ({
      data: { id: `e${i}`, source: e.source, target: e.target }
    }));
    return [...nodes, ...edges];
  }
}

export default GraphWasm;
".

% Run with: swipl -g "consult('graph_module.pl'), graph_module:generate_all" -t halt
