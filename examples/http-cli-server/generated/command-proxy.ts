/**
 * command-proxy.ts - Command Interception and Validation Proxy
 * Generated by UnifyWeaver command_proxy_generator.pl
 * DO NOT EDIT - regenerate from spec
 */

import { spawn, SpawnOptions } from 'child_process';
import * as path from 'path';

// Types
export enum Risk {
  SAFE = 'safe',
  MODERATE = 'moderate',
  HIGH = 'high',
  BLOCKED = 'blocked'
}

export interface ExecutionContext {
  role?: string;
  cwd?: string;
  confirmed?: boolean;
  timeout?: number;
}

export interface ValidationResult {
  ok: boolean;
  reason?: string;
  warning?: string;
  risk?: Risk;
  requiresConfirmation?: boolean;
  description?: string;
}

export interface ExecutionResult {
  success: boolean;
  code?: number;
  stdout?: string;
  stderr?: string;
  error?: string;
  warning?: string;
}

export interface CommandDefinition {
  risk: Risk;
  description: string;
  validate: (args: string[], ctx: ExecutionContext) => ValidationResult;
  transform: (args: string[]) => string[];
  requiresConfirmation?: boolean;
}

export interface CommandInfo {
  name: string;
  risk: Risk;
  description: string;
  requiresConfirmation: boolean;
}

// Configuration
const HOME = process.env.HOME || '/home/user';
export const SANDBOX_ROOT = process.env.SANDBOX_ROOT || `${HOME}/sandbox`;

// Helpers
const isSensitivePath = (p: string): boolean => {
  const sensitive = ['/etc/shadow', '/etc/passwd', '/root', '.ssh/id_', '.env', 'credentials'];
  return sensitive.some(s => p.includes(s));
};

const isOutsideSandbox = (p: string): boolean => {
  return p.startsWith('/') && !p.startsWith(SANDBOX_ROOT);
};

// Command Registry
const commandRegistry: Record<string, CommandDefinition> = {
  'ls': {
    risk: Risk.SAFE,
    description: 'List directory contents',
    validate: () => ({ ok: true }),
    transform: (args) => ['ls', '--color=auto', ...args]
  },
  'cat': {
    risk: Risk.MODERATE,
    description: 'Display file contents',
    validate: (args) => {
      if (args.some(a => isSensitivePath(a))) return { ok: false, reason: 'Access to sensitive paths blocked' };
      return { ok: true };
    },
    transform: (args) => ['cat', ...args]
  },
  'head': {
    risk: Risk.SAFE,
    description: 'Display first lines',
    validate: () => ({ ok: true }),
    transform: (args) => ['head', ...args]
  },
  'tail': {
    risk: Risk.SAFE,
    description: 'Display last lines',
    validate: () => ({ ok: true }),
    transform: (args) => ['tail', ...args]
  },
  'pwd': {
    risk: Risk.SAFE,
    description: 'Print working directory',
    validate: () => ({ ok: true }),
    transform: (args) => ['pwd', ...args]
  },
  'cd': {
    risk: Risk.SAFE,
    description: 'Change directory',
    validate: () => ({ ok: true }),
    transform: (args) => ['cd', ...args]
  },
  'grep': {
    risk: Risk.SAFE,
    description: 'Search file contents',
    validate: () => ({ ok: true }),
    transform: (args) => ['grep', '--color=auto', ...args]
  },
  'find': {
    risk: Risk.SAFE,
    description: 'Find files',
    validate: (args) => {
      const execIdx = args.indexOf('-exec');
      if (execIdx !== -1 && /rm|chmod|chown/.test(args.slice(execIdx + 1).join(' '))) return { ok: false, reason: 'Destructive -exec blocked' };
      return { ok: true };
    },
    transform: (args) => ['find', ...args]
  },
  'cp': {
    risk: Risk.MODERATE,
    description: 'Copy files',
    validate: (args) => {
      if (args.some(a => isOutsideSandbox(a))) return { ok: false, reason: 'Operation must stay within sandbox' };
      return { ok: true };
    },
    transform: (args) => ['cp', ...args]
  },
  'mv': {
    risk: Risk.MODERATE,
    description: 'Move/rename files',
    validate: (args) => {
      if (args.some(a => isOutsideSandbox(a))) return { ok: false, reason: 'Operation must stay within sandbox' };
      return { ok: true };
    },
    transform: (args) => ['mv', ...args]
  },
  'mkdir': {
    risk: Risk.SAFE,
    description: 'Create directory',
    validate: (args) => {
      if (args.some(a => isOutsideSandbox(a))) return { ok: false, reason: 'Operation must stay within sandbox' };
      return { ok: true };
    },
    transform: (args) => ['mkdir', '-p', ...args]
  },
  'rm': {
    risk: Risk.HIGH,
    description: 'Remove files',
    validate: (args) => {
      if (args.some(a => isOutsideSandbox(a))) return { ok: false, reason: 'Operation must stay within sandbox' };
      return { ok: true };
    },
    transform: (args) => ['rm', ...args],
    requiresConfirmation: true
  },
  'touch': {
    risk: Risk.SAFE,
    description: 'Create empty file',
    validate: () => ({ ok: true }),
    transform: (args) => ['touch', ...args]
  },
  'echo': {
    risk: Risk.SAFE,
    description: 'Print text',
    validate: () => ({ ok: true }),
    transform: (args) => ['echo', ...args]
  },
  'wc': {
    risk: Risk.SAFE,
    description: 'Word count',
    validate: () => ({ ok: true }),
    transform: (args) => ['wc', ...args]
  },
  'sort': {
    risk: Risk.SAFE,
    description: 'Sort lines',
    validate: () => ({ ok: true }),
    transform: (args) => ['sort', ...args]
  },
  'uniq': {
    risk: Risk.SAFE,
    description: 'Filter unique lines',
    validate: () => ({ ok: true }),
    transform: (args) => ['uniq', ...args]
  },
  'date': {
    risk: Risk.SAFE,
    description: 'Show date/time',
    validate: () => ({ ok: true }),
    transform: (args) => ['date', ...args]
  },
  'whoami': {
    risk: Risk.SAFE,
    description: 'Show current user',
    validate: () => ({ ok: true }),
    transform: (args) => ['whoami', ...args]
  },
  'uname': {
    risk: Risk.SAFE,
    description: 'System information',
    validate: () => ({ ok: true }),
    transform: (args) => ['uname', ...args]
  },
  'df': {
    risk: Risk.SAFE,
    description: 'Disk usage',
    validate: () => ({ ok: true }),
    transform: (args) => ['df', '-h', ...args]
  },
  'du': {
    risk: Risk.SAFE,
    description: 'Directory size',
    validate: () => ({ ok: true }),
    transform: (args) => ['du', '-h', ...args]
  },
  'git': {
    risk: Risk.MODERATE,
    description: 'Git version control',
    validate: (args) => {
      if (args.includes('push') && (args.includes('--force') || args.includes('-f'))) return { ok: false, reason: 'Force push blocked' };
      return { ok: true };
    },
    transform: (args) => ['git', ...args]
  },
  'node': {
    risk: Risk.MODERATE,
    description: 'Run Node.js',
    validate: (args) => {
      if (args.includes('-e') || args.includes('--eval') || args.includes('-c')) return { ok: false, reason: 'Eval blocked' };
      return { ok: true };
    },
    transform: (args) => ['node', ...args]
  },
  'npm': {
    risk: Risk.MODERATE,
    description: 'Node package manager',
    validate: (args) => {
      if (args.includes('-g') || args.includes('--global')) return { ok: false, reason: 'Global operations blocked' };
      return { ok: true };
    },
    transform: (args) => ['npm', ...args]
  },
  'python': {
    risk: Risk.MODERATE,
    description: 'Run Python',
    validate: (args) => {
      if (args.includes('-e') || args.includes('--eval') || args.includes('-c')) return { ok: false, reason: 'Eval blocked' };
      return { ok: true };
    },
    transform: (args) => ['python3', ...args]
  },
  'python3': {
    risk: Risk.MODERATE,
    description: 'Run Python 3',
    validate: (args) => {
      if (args.includes('-e') || args.includes('--eval') || args.includes('-c')) return { ok: false, reason: 'Eval blocked' };
      return { ok: true };
    },
    transform: (args) => ['python3', ...args]
  },
  'pip': {
    risk: Risk.MODERATE,
    description: 'Python package manager',
    validate: () => ({ ok: true }),
    transform: (args) => ['pip', ...args]
  },
  'curl': {
    risk: Risk.MODERATE,
    description: 'HTTP client',
    validate: () => ({ ok: true }),
    transform: (args) => ['curl', ...args]
  },
  'wget': {
    risk: Risk.MODERATE,
    description: 'Download files',
    validate: () => ({ ok: true }),
    transform: (args) => ['wget', ...args]
  },
  'sudo': {
    risk: Risk.BLOCKED,
    description: 'Superuser do',
    validate: () => ({ ok: false, reason: 'sudo is not available in sandbox' }),
    transform: (args) => ['sudo', ...args]
  },
  'su': {
    risk: Risk.BLOCKED,
    description: 'Switch user',
    validate: () => ({ ok: false, reason: 'su is not available in sandbox' }),
    transform: (args) => ['su', ...args]
  },
  'chown': {
    risk: Risk.BLOCKED,
    description: 'Change ownership',
    validate: () => ({ ok: false, reason: 'chown not available in sandbox' }),
    transform: (args) => ['chown', ...args]
  },
  'chmod': {
    risk: Risk.HIGH,
    description: 'Change permissions',
    validate: () => ({ ok: true }),
    transform: (args) => ['chmod', ...args],
    requiresConfirmation: true
  }
};

// Functions
export function parseCommand(cmdString: string): { cmd: string; args: string[] } {
  const parts = cmdString.trim().split(/\s+/);
  return { cmd: parts[0], args: parts.slice(1) };
}

export function validateCommand(cmd: string, args: string[], ctx: ExecutionContext = {}): ValidationResult {
  const def = commandRegistry[cmd];
  if (!def) return { ok: false, reason: `Unknown command: ${cmd}` };
  if (def.risk === Risk.BLOCKED) return { ok: false, reason: `${cmd} is blocked` };
  const result = def.validate(args, ctx);
  return { ...result, risk: def.risk, requiresConfirmation: def.requiresConfirmation || false, description: def.description };
}

export function executeCommand(cmd: string, args: string[], options: ExecutionContext = {}): Promise<ExecutionResult> {
  return new Promise((resolve) => {
    const def = commandRegistry[cmd];
    if (!def) { resolve({ success: false, error: `Unknown command: ${cmd}` }); return; }
    const transformedArgs = def.transform(args);
    const executable = transformedArgs[0];
    const execArgs = transformedArgs.slice(1);
    const proc = spawn(executable, execArgs, {
      cwd: options.cwd || SANDBOX_ROOT,
      timeout: options.timeout || 30000,
      shell: true
    } as SpawnOptions);
    let stdout = '';
    let stderr = '';
    proc.stdout?.on('data', (data: Buffer) => { stdout += data.toString(); });
    proc.stderr?.on('data', (data: Buffer) => { stderr += data.toString(); });
    proc.on('close', (code: number | null) => { resolve({ success: code === 0, code: code ?? undefined, stdout, stderr }); });
    proc.on('error', (err: Error) => { resolve({ success: false, error: err.message }); });
  });
}

export async function execute(cmdString: string, ctx: ExecutionContext = {}): Promise<ExecutionResult> {
  const { cmd, args } = parseCommand(cmdString);
  console.log(`[command-proxy] ${cmd} ${args.join(' ')}`);
  const validation = validateCommand(cmd, args, ctx);
  if (!validation.ok) return { success: false, error: validation.reason };
  if (validation.requiresConfirmation && !ctx.confirmed) return { success: false, error: 'Requires confirmation', warning: validation.warning };
  try {
    const result = await executeCommand(cmd, args, ctx);
    return { ...result, warning: validation.warning };
  } catch (err) {
    return { success: false, error: (err as Error).message };
  }
}

export function listCommands(): CommandInfo[] {
  return Object.entries(commandRegistry).map(([name, def]) => ({
    name, risk: def.risk, description: def.description, requiresConfirmation: def.requiresConfirmation || false
  }));
}

export default { execute, validateCommand, listCommands, Risk, SANDBOX_ROOT };
