#!/usr/bin/env ts-node
/**
 * http_cli - HTTP/HTTPS Server
 * Generated by UnifyWeaver http_server_generator.pl
 * DO NOT EDIT - regenerate from spec
 */

import * as http from 'http';
import * as url from 'url';
import * as path from 'path';
import * as fs from 'fs';
import { execSync, spawn, ChildProcessWithoutNullStreams } from 'child_process';
import * as https from 'https';
import WebSocket, { WebSocketServer } from 'ws';
import {
  login,
  verifyToken,
  getUserFromToken,
  hasRole,
  TokenPayload,
  Role
} from './auth';
import {
  execute,
  validateCommand,
  listCommands,
  Risk,
  SANDBOX_ROOT
} from './command-proxy';

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_PORT = 3001;
const MAX_BODY_SIZE = 1024 * 1024; // 1MB
const ALLOWED_ORIGINS = ['*'];

// Authentication: set AUTH_REQUIRED=true to require login
const AUTH_REQUIRED = process.env.AUTH_REQUIRED === 'true';

// Commands allowed for search operations
const SEARCH_COMMANDS = ['grep', 'find', 'cat', 'head', 'tail', 'ls', 'wc', 'pwd'];

// Browse roots
const PROJECT_ROOT = process.env.PROJECT_ROOT || path.resolve(__dirname, '../../..');
const HOME_ROOT = process.env.HOME || '/data/data/com.termux/files/home';

// Feedback log file
const FEEDBACK_FILE = process.env.FEEDBACK_FILE || path.join(SANDBOX_ROOT, 'comet-feedback.log');

// ============================================================================
// Types
// ============================================================================

interface APIResponse {
  success: boolean;
  data?: unknown;
  error?: string;
  warning?: string;
}

interface RequestBody {
  [key: string]: unknown;
}

interface FileEntry {
  name: string;
  type: 'file' | 'directory';
  size?: number;
  modified?: string;
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Get the base directory for a given root type
 */
function getRootDir(root?: string): string {
  switch (root) {
    case 'project':
      return PROJECT_ROOT;
    case 'home':
      return HOME_ROOT;
    case 'sandbox':
    default:
      return SANDBOX_ROOT;
  }
}

/**
 * Resolve a working directory relative to the specified root
 */
function resolveWorkingDir(cwd?: string, root?: string): string {
  const rootDir = getRootDir(root);
  if (!cwd || cwd === '.') return rootDir;
  const resolved = path.resolve(rootDir, cwd);
  if (!resolved.startsWith(rootDir)) return rootDir;
  if (!fs.existsSync(resolved) || !fs.statSync(resolved).isDirectory()) return rootDir;
  return resolved;
}

function expandGlobs(args: string[], cwd: string): string[] {
  const expanded: string[] = [];
  for (const arg of args) {
    if (arg.includes('*') || arg.includes('?')) {
      try {
        const result = execSync(`printf '%s\\n' ${arg}`, {
          cwd,
          encoding: 'utf-8',
          timeout: 5000,
          shell: '/bin/sh'
        }).trim();
        if (result && result !== arg) {
          expanded.push(...result.split('\n').filter(Boolean));
        } else {
          expanded.push(arg);
        }
      } catch {
        expanded.push(arg);
      }
    } else {
      expanded.push(arg);
    }
  }
  return expanded;
}

/**
 * GET /health - health endpoint
 */
async function handle_health(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  sendJSON(res, 200, {
    success: true,
    data: {
      status: 'ok',
      sandboxRoot: SANDBOX_ROOT,
      timestamp: new Date().toISOString()
    }
  });
}

/**
 * GET /auth/status - auth_status endpoint
 */
async function handle_auth_status(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  sendJSON(res, 200, {
    success: true,
    data: {
      authRequired: AUTH_REQUIRED,
      authenticated: user !== null,
      user: user ? { id: user.sub, email: user.email, roles: user.roles } : null
    }
  });
}

/**
 * POST /auth/login - auth_login endpoint
 */
async function handle_auth_login(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  const { email, password } = body as any;

  if (!email || !password) {
    return sendJSON(res, 400, { success: false, error: 'Email and password required' });
  }

  const result = login(email, password);

  if (!result.success) {
    return sendJSON(res, 401, { success: false, error: result.error || 'Login failed' });
  }

  sendJSON(res, 200, {
    success: true,
    data: { token: result.token, user: result.user }
  });
}

/**
 * GET /auth/me - auth_me endpoint
 */
async function handle_auth_me(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  if (!user) {
    return sendJSON(res, 401, { success: false, error: 'Not authenticated' });
  }

  sendJSON(res, 200, {
    success: true,
    data: {
      id: user.sub,
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
  });
}

/**
 * GET /commands - commands endpoint
 */
async function handle_commands(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const commands = listCommands().filter(c => SEARCH_COMMANDS.includes(c.name) || c.risk === Risk.SAFE);
  sendJSON(res, 200, {
    success: true,
    data: { commands, searchCommands: SEARCH_COMMANDS }
  });
}

/**
 * POST /exec - exec endpoint
 */
async function handle_exec(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const { command, args = [], cwd, root } = body as any;

  if (!command) {
    return sendJSON(res, 400, { success: false, error: 'Missing command' });
  }

  if (!SEARCH_COMMANDS.includes(command)) {
    return sendJSON(res, 403, { success: false, error: `Command not allowed. Allowed: ${SEARCH_COMMANDS.join(', ')}` });
  }

  const workingDir = resolveWorkingDir(cwd, root);
  const expandedArgs = expandGlobs(args, workingDir);
  const validation = validateCommand(command, expandedArgs, { role: 'user' });

  if (!validation.ok) {
    return sendJSON(res, 403, { success: false, error: validation.reason || 'Validation failed' });
  }

  const cmdString = [command, ...expandedArgs].join(' ');
  const result = await execute(cmdString, { role: 'user', cwd: workingDir });

  if (!result.success) {
    return sendJSON(res, 400, { success: false, error: result.error, warning: result.warning });
  }

  sendJSON(res, 200, {
    success: true,
    data: { stdout: result.stdout, stderr: result.stderr, code: result.code },
    warning: result.warning
  });
}

/**
 * POST /grep - grep endpoint
 */
async function handle_grep(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const { pattern, path: searchPath = '.', options = [], cwd, root } = body as any;

  if (!pattern) {
    return sendJSON(res, 400, { success: false, error: 'Missing pattern' });
  }

  const workingDir = resolveWorkingDir(cwd, root);
  const args = ['-r', '-n', '--color=never', ...options, pattern, searchPath];
  const cmdString = ['grep', ...args].join(' ');
  const result = await execute(cmdString, { role: 'user', cwd: workingDir });

  sendJSON(res, 200, {
    success: true,
    data: {
      matches: result.stdout?.split('\n').filter(Boolean) || [],
      count: result.stdout?.split('\n').filter(Boolean).length || 0,
      stderr: result.stderr
    },
    warning: result.warning
  });
}

/**
 * POST /find - find endpoint
 */
async function handle_find(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const { pattern, path: searchPath = '.', options = [], cwd, root } = body as any;

  const workingDir = resolveWorkingDir(cwd, root);
  const args = [searchPath];
  if (pattern) args.push('-name', pattern);
  args.push(...options);

  const cmdString = ['find', ...args].join(' ');
  const result = await execute(cmdString, { role: 'user', cwd: workingDir });

  sendJSON(res, 200, {
    success: true,
    data: {
      files: result.stdout?.split('\n').filter(Boolean) || [],
      count: result.stdout?.split('\n').filter(Boolean).length || 0
    },
    warning: result.warning
  });
}

/**
 * POST /cat - cat endpoint
 */
async function handle_cat(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const { path: filePath, options = [], cwd, root } = body as any;

  if (!filePath) {
    return sendJSON(res, 400, { success: false, error: 'Missing path' });
  }

  const workingDir = resolveWorkingDir(cwd, root);
  const cmdString = ['cat', ...options, filePath].join(' ');
  const result = await execute(cmdString, { role: 'user', cwd: workingDir });

  if (!result.success) {
    return sendJSON(res, 400, { success: false, error: result.error });
  }

  sendJSON(res, 200, {
    success: true,
    data: {
      content: result.stdout,
      lines: result.stdout?.split('\n').length || 0
    }
  });
}

/**
 * POST /browse - browse endpoint
 */
async function handle_browse(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r as Role));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  const { path: browsePath = '.', root = 'sandbox' } = body as any;

  // Determine root directory based on selection
  let rootDir: string;
  switch (root) {
    case 'project':
      rootDir = PROJECT_ROOT;
      break;
    case 'home':
      rootDir = HOME_ROOT;
      break;
    case 'sandbox':
    default:
      rootDir = SANDBOX_ROOT;
      break;
  }

  const targetPath = path.resolve(rootDir, browsePath);
  if (!targetPath.startsWith(rootDir)) {
    return sendJSON(res, 403, { success: false, error: 'Path outside root' });
  }

  if (!fs.existsSync(targetPath)) {
    return sendJSON(res, 404, { success: false, error: 'Path not found' });
  }

  const stats = fs.statSync(targetPath);
  if (!stats.isDirectory()) {
    return sendJSON(res, 400, { success: false, error: 'Not a directory' });
  }

  const items = fs.readdirSync(targetPath);
  const entries: FileEntry[] = [];

  for (const name of items) {
    if (name.startsWith('.') && browsePath !== '.') continue;
    try {
      const itemPath = path.join(targetPath, name);
      const itemStats = fs.statSync(itemPath);
      entries.push({
        name,
        type: itemStats.isDirectory() ? 'directory' : 'file',
        size: itemStats.isFile() ? itemStats.size : undefined,
        modified: itemStats.mtime.toISOString()
      });
    } catch { continue; }
  }

  entries.sort((a, b) => {
    if (a.type !== b.type) return a.type === 'directory' ? -1 : 1;
    return a.name.localeCompare(b.name);
  });

  const relativePath = path.relative(rootDir, targetPath) || '.';

  sendJSON(res, 200, {
    success: true,
    data: {
      path: relativePath,
      absolutePath: targetPath,
      root,
      rootDir,
      parent: relativePath !== '.' ? path.dirname(relativePath) || '.' : null,
      entries,
      count: entries.length
    }
  });
}

function getHTMLInterface(): string {
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>UnifyWeaver CLI Search</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://unpkg.com/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/xterm@5.3.0/css/xterm.css">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, monospace;
      background: #1a1a2e;
      color: #eee;
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1200px; margin: 0 auto; }
    h1 { color: #e94560; margin-bottom: 20px; }
    h2 { color: #e94560; margin-bottom: 15px; }
    a { color: #e94560; text-decoration: none; }
    a:hover { text-decoration: underline; }

    .tabs {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-bottom: 20px;
    }
    .tab {
      padding: 10px 20px;
      background: #16213e;
      border: none;
      color: #94a3b8;
      cursor: pointer;
      border-radius: 5px 5px 0 0;
    }
    .tab.active { background: #0f3460; color: #e94560; }
    .tab:hover { background: #0f3460; }
    .panel {
      background: #16213e;
      padding: 20px;
      border-radius: 0 5px 5px 5px;
    }
    .form-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; color: #94a3b8; }
    input, textarea, select {
      width: 100%;
      padding: 10px;
      background: #0f3460;
      border: 1px solid #1a1a2e;
      color: #eee;
      border-radius: 5px;
      font-family: monospace;
    }
    input:focus, textarea:focus, select:focus {
      outline: none;
      border-color: #e94560;
    }
    button {
      padding: 10px 20px;
      background: #e94560;
      border: none;
      color: #fff;
      cursor: pointer;
      border-radius: 5px;
      font-weight: bold;
    }
    button:hover { background: #ff6b6b; }
    button:disabled { background: #444; cursor: not-allowed; }
    .results {
      margin-top: 20px;
      background: #0f3460;
      padding: 15px;
      border-radius: 5px;
      max-height: 500px;
      overflow: auto;
    }
    .results pre {
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 13px;
      line-height: 1.5;
    }
    .error { color: #ff6b6b; }
    .success { color: #4ade80; }
    .warning { color: #fbbf24; }
    .count { color: #94a3b8; font-size: 14px; margin-bottom: 10px; }
    .login-container {
      max-width: 400px;
      margin: 50px auto;
      padding: 30px;
      background: #16213e;
      border-radius: 10px;
    }
    .login-container h2 {
      color: #e94560;
      margin-bottom: 20px;
      text-align: center;
    }
    .user-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: #0f3460;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      flex-wrap: wrap;
      gap: 10px;
    }
    .user-info {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .user-email { color: #4ade80; font-weight: bold; }
    .user-roles {
      display: flex;
      gap: 5px;
    }
    .role-badge {
      padding: 2px 8px;
      background: #1a1a2e;
      border-radius: 3px;
      font-size: 11px;
      color: #94a3b8;
    }
    .role-badge.shell { background: #e94560; color: #fff; }
    .role-badge.admin { background: #3b82f6; color: #fff; }
    .working-dir-bar {
      background: #0f3460;
      padding: 10px 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    code {
      background: #1a1a2e;
      padding: 4px 8px;
      border-radius: 3px;
      font-family: monospace;
    }
    .file-entry {
      padding: 10px;
      background: #0f3460;
      margin: 3px 0;
      border-radius: 5px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-entry:hover { background: #1a3a5e; }
    .terminal {
      background: #000;
      padding: 15px;
      border-radius: 5px;
      font-family: monospace;
      min-height: 300px;
      max-height: 500px;
      overflow-y: auto;
    }
    .terminal pre {
      color: #0f0;
      margin: 0;
      white-space: pre-wrap;
    }
    .shell-input {
      flex: 1;
      background: transparent;
      border: none;
      color: #0f0;
      font-family: monospace;
    }
    .shell-input:focus { outline: none; }
    .prompt { color: #4ade80; font-family: monospace; }

    /* Navbar styles */
    .navbar {
      display: flex;
      gap: 8px;
      padding: 6px 12px;
      background: #0f3460;
      align-items: center;
      margin-bottom: 10px;
      border-radius: 4px;
      font-size: 12px;
    }
    .navbar .spacer { flex: 1; }
    .navbar .user-email { color: #4ade80; }
    .navbar .role-badge {
      padding: 1px 6px;
      background: #1a1a2e;
      border-radius: 3px;
      font-size: 10px;
      color: #94a3b8;
    }
    .navbar .role-badge.shell { background: #a855f7; color: #fff; }
    .navbar .role-badge.admin { background: #3b82f6; color: #fff; }
    .navbar button {
      padding: 4px 10px;
      background: #e94560;
      color: white;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      font-size: 11px;
    }
    .navbar button:hover { background: #ff6b6b; }

  </style>
</head>
<body>
  <div id="app" class="container">

    <template v-if="(authRequired) && (!user)">
<div style="background: #fff; padding: 30px; border-radius: 8px; box-shadow: 0 3px 6px rgba(0,0,0,0.15)">
  <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
    <h2>Login Required</h2>
    <div class="form-group">
      <label>Email</label>
      <input type="email" v-model="loginEmail" placeholder="e.g., shell@local" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
    </div>
    <div class="form-group">
      <label>Password</label>
      <input type="password" v-model="loginPassword" placeholder="Password" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
    </div>
    <button @click="doLogin" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Logging in...' : 'Login' }}</button>
    <template v-if="loginError">
      <span style="error">{{ loginError }}</span>
    </template>
    <span style="muted">Default users: shell@local/shell, admin@local/admin, user@local/user</span>
  </div>
</div>

    </template>
    <template v-if="(!authRequired) || (user)">
<!-- Navbar -->
<nav class="navbar">
  <template v-if="user">
    <span class="user-email">{{ user.email }}</span>
    <span v-for="role in user.roles" :key="role" class="role-badge" :class="role">{{ role }}</span>
    <span class="spacer"></span>
    <button @click="doLogout">Logout</button>
  </template>
  <template v-else-if="authRequired">
    <span style="color: #f38ba8;">Login required</span>
    <span class="spacer"></span>
  </template>
  <template v-else>
    <span style="color: #94a3b8; font-size: 12px;">Guest mode</span>
    <span class="spacer"></span>
  </template>
</nav>

<div class="working_dir_bar" style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap; padding: 8px 12px; background: #0f3460; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">
  <span style="color: #94a3b8;">Root:</span>
  <select v-model="browseRoot" @change="onRootChange" style="padding: 4px 8px; background: #1a1a2e; border: 1px solid #16213e; color: #cdd6f4; border-radius: 3px; font-size: 12px;">
    <option value="sandbox">Sandbox</option>
    <option value="project">Project</option>
    <option value="home">Home</option>
  </select>
  <span style="color: #94a3b8;">Path:</span>
  <code style="color: #4ade80;">{{ workingDir }}</code>
  <template v-if="workingDir !== '.'">
    <button @click="resetWorkingDir" style="padding: 4px 10px; background: #16213e; border: none; color: #fff; cursor: pointer; border-radius: 3px; font-size: 11px;">Reset</button>
  </template>
</div>

<div class="tabs">
  <div style="display: flex; flex-direction: row; gap: 5px; justify-content: flex-start; align-items: stretch; flex-wrap: wrap; ">
    <button class="tab" :class="{ active: tab === 'browse' }" @click="tab = 'browse'" v-if="!authRequired || user?.roles?.includes('user') || user?.roles?.includes('admin') || user?.roles?.includes('shell')">üìÅ Browse</button>
    <button class="tab" :class="{ active: tab === 'grep' }" @click="tab = 'grep'" v-if="!authRequired || user?.roles?.includes('user') || user?.roles?.includes('admin') || user?.roles?.includes('shell')">üîç Grep</button>
    <button class="tab" :class="{ active: tab === 'find' }" @click="tab = 'find'" v-if="!authRequired || user?.roles?.includes('user') || user?.roles?.includes('admin') || user?.roles?.includes('shell')">üìÇ Find</button>
    <button class="tab" :class="{ active: tab === 'cat' }" @click="tab = 'cat'" v-if="!authRequired || user?.roles?.includes('user') || user?.roles?.includes('admin') || user?.roles?.includes('shell')">üìÑ Cat</button>
    <button class="tab" :class="{ active: tab === 'exec' }" @click="tab = 'exec'" v-if="!authRequired || user?.roles?.includes('admin') || user?.roles?.includes('shell')">‚ö° Custom</button>
    <button class="tab" :class="{ active: tab === 'feedback' }" @click="tab = 'feedback'" v-if="!authRequired || user?.roles?.includes('user') || user?.roles?.includes('admin') || user?.roles?.includes('shell')">üí¨ Feedback</button>
    <button class="tab" :class="{ active: tab === 'shell' }" @click="tab = 'shell'" v-if="!authRequired || user?.roles?.includes('shell')" style="background: #a855f7;">üîê Shell</button>
  </div>
</div>

<!-- Container: outlet -->
<div>
  <div v-if="tab === 'browse'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div style="display: flex; flex-direction: row; gap: 10px; justify-content: flex-start; align-items: center; flex-wrap: wrap; ">
          <template v-if="browse.parent">
            <button @click="navigateUp" style="padding: 10px 20px; background: #16213e; border: none; color: #fff; cursor: pointer; border-radius: 5px">‚¨ÜÔ∏è Up</button>
          </template>
          <span style="icon">üìÅ </span>
          <code>{{ browse.path }}</code>
          <button @click="workingDir = browse.path" :disabled="workingDir === browse.path" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px">üìå Set as Working Dir</button>
        </div>
        <template v-if="browse.entries">
          <span></span>
        </template>
        <!-- Container: scroll -->
        <div>
          <div v-for="entry in browse.entries" :key="entry">
          <div class="file_entry" @click="handleEntryClick(entry)">
            <div style="display: flex; flex-direction: row; ; justify-content: space-between; align-items: center; ; ">
              <div style="display: flex; flex-direction: row; gap: 8px; justify-content: flex-start; align-items: stretch; ; ">
                <span style="font-size: 24px;"></span>
                <span>{{ entry.name }}</span>
              </div>
              <span style="muted">{{ formatSize(entry.size) }}</span>
            </div>
          </div>
          </div>
        </div>
        <template v-if="(browse.entries.length === 0 && !loading)">
          <span style="muted">Empty directory</span>
        </template>
        <template v-if="browse.selected">
          <div class="selected_file">
            <div style="display: flex; flex-direction: column; gap: 10px; align-items: stretch; ">
              <span style="muted">Selected file:</span>
              <code>{{ browse.selected }}</code>
              <div style="display: flex; flex-direction: row; gap: 10px; justify-content: flex-start; align-items: stretch; ; ">
                <button @click="viewFile" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">View Contents</button>
                <button @click="searchHere" style="padding: 10px 20px; background: #16213e; border: none; color: #fff; cursor: pointer; border-radius: 5px">Search Here</button>
              </div>
            </div>
          </div>
        </template>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'grep'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div class="form-group">
          <label>Search Pattern (regex)</label>
          <input type="text" v-model="grep.pattern" placeholder="e.g., function.*export" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <div class="form-group">
          <label>Path (relative to sandbox)</label>
          <input type="text" v-model="grep.path" placeholder="e.g., src/ or ." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <div class="form-group">
          <label>Options (space-separated)</label>
          <input type="text" v-model="grep.options" placeholder="e.g., -i --include=*.ts" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <button @click="doGrep" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Searching...' : 'Search' }}</button>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'find'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div class="form-group">
          <label>File Pattern</label>
          <input type="text" v-model="find.pattern" placeholder="e.g., *.ts or index.*" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <div class="form-group">
          <label>Search Path</label>
          <input type="text" v-model="find.path" placeholder="e.g., src/ or ." style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <div class="form-group">
          <label>Options (space-separated)</label>
          <input type="text" v-model="find.options" placeholder="e.g., -type f -maxdepth 3" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <button @click="doFind" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Finding...' : 'Find Files' }}</button>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'cat'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div class="form-group">
          <label>File Path</label>
          <input type="text" v-model="cat.path" placeholder="e.g., src/index.ts" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <button @click="doCat" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Reading...' : 'Read File' }}</button>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'exec'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div class="form-group">
          <label>Command (as you'd type in shell)</label>
          <input type="text" v-model="exec.commandLine" @keydown.enter="doExec" placeholder="e.g., ls -la src/ or wc -l *.ts" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
        </div>
        <button @click="doExec" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Running...' : 'Execute' }}</button>
        <span style="color: #94a3b8; font-size: 12px;">Allowed: grep, find, cat, head, tail, ls, wc, pwd</span>
        <template v-if="exec.result">
          <div class="results">
            <pre style="white-space: pre-wrap; word-wrap: break-word; font-size: 13px; line-height: 1.5; color: #cdd6f4;">{{ exec.result }}</pre>
          </div>
        </template>
        <template v-if="exec.error">
          <div class="results" style="border-left: 3px solid #f38ba8;">
            <pre style="white-space: pre-wrap; word-wrap: break-word; font-size: 13px; color: #f38ba8;">{{ exec.error }}</pre>
          </div>
        </template>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'feedback'" class="panel">
    <div class="panel">
      <div style="display: flex; flex-direction: column; gap: 15px; align-items: stretch; ">
        <div class="form-group">
          <label>Feedback Type</label>
          <select v-model="feedback.type" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;">
            <option value="" disabled>Select...</option>
            <option value="info">Info</option><option value="success">Success</option><option value="suggestion">Suggestion</option><option value="warning">Warning</option><option value="error">Error</option>
          </select>
        </div>
        <div class="form-group">
          <label>Message</label>
          <textarea v-model="feedback.message" placeholder="Enter your feedback, notes, or observations..." rows="4" style="width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 5px;"></textarea>
        </div>
        <button @click="doFeedback" :disabled="loading" style="padding: 10px 20px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-weight: bold">{{ loading ? 'Submitting...' : 'Submit Feedback' }}</button>
      </div>
    </div>
  </div>
  <div v-else-if="tab === 'shell'" class="panel">
    <div class="panel" style="padding: 0;">
      <div style="display: flex; flex-direction: column; align-items: stretch;">
        <div style="display: flex; flex-direction: row; gap: 8px; justify-content: space-between; align-items: center; flex-wrap: wrap; padding: 10px; background: #0f3460;">
          <span style="color: #a855f7; font-weight: bold;">üîê Shell</span>
          <div style="display: flex; flex-direction: row; gap: 8px; justify-content: flex-start; align-items: center; flex-wrap: wrap;">
            <template v-if="shell.connected">
              <span style="color: #4ade80; font-size: 12px;">‚óè Connected</span>
            </template>
            <template v-if="!shell.connected">
              <span style="color: #ff6b6b; font-size: 12px;">‚óè Disconnected</span>
            </template>
            <button @click="toggleTextMode" :style="{ padding: '5px 10px', background: shellTextMode ? '#89b4fa' : '#16213e', border: 'none', color: shellTextMode ? '#1a1a2e' : '#fff', cursor: 'pointer', borderRadius: '5px', fontSize: '12px' }">{{ shellTextMode ? 'Terminal' : 'Text Mode' }}</button>
            <button @click="clearShell" style="padding: 5px 10px; background: #16213e; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-size: 12px;">Clear</button>
            <button @click="connectShell" :disabled="shell.connected" style="padding: 5px 10px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-size: 12px;">Connect</button>
            <button @click="disconnectShell" :disabled="!shell.connected" style="padding: 5px 10px; background: #16213e; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-size: 12px;">Disconnect</button>
          </div>
        </div>
        <!-- Terminal mode (xterm.js) -->
        <div v-show="!shellTextMode" id="xterm_container" style="height: 400px; background: #1a1a2e;"></div>
        <!-- Text mode (native selection for copying) -->
        <div v-show="shellTextMode" style="display: flex; flex-direction: column; height: 400px; background: #1a1a2e;">
          <pre style="flex: 1; margin: 0; padding: 15px; color: #cdd6f4; font-family: monospace; font-size: 14px; line-height: 1.5; overflow-y: auto; white-space: pre-wrap; word-break: break-word; user-select: text; -webkit-user-select: text;">{{ shell.textOutput }}</pre>
          <div style="display: flex; align-items: center; padding: 8px 15px; background: #0f3460; border-top: 1px solid #1a1a2e; gap: 8px;">
            <span style="color: #4ade80; font-family: monospace;">$</span>
            <input type="text" v-model="shell.textInput" @keydown.enter="sendTextCommand" placeholder="Type command..." style="flex: 1; background: #1a1a2e; border: 1px solid #0f3460; border-radius: 4px; padding: 8px; color: #cdd6f4; font-family: monospace; font-size: 14px;">
            <button @click="sendTextCommand" style="padding: 8px 15px; background: #e94560; border: none; color: #fff; cursor: pointer; border-radius: 5px; font-size: 12px;">Send</button>
          </div>
        </div>
        <div style="padding: 5px 10px; background: #0f3460; font-size: 11px; color: #94a3b8;">
          {{ shellTextMode ? 'Text mode: Select and copy text freely' : 'Terminal mode: Full interactive shell' }}
        </div>
      </div>
    </div>
  </div></div>

    </template>
  </div>
  <script>
const { createApp, ref, reactive, computed, onMounted, watch } = Vue;

const app = createApp({
  setup() {
    // Auth state
    const authRequired = ref(false);
    const user = ref(null);
    const loginEmail = ref("");
    const loginPassword = ref("");
    const loginError = ref("");
    const loading = ref(false);
    const token = ref(localStorage.getItem("token") || "");

    // UI state
    const tab = ref("browse");
    const workingDir = ref(".");
    const browseRoot = ref("sandbox");
    const results = ref("");
    const resultCount = ref(0);

    // Tab-specific state
    const browse = reactive({
      path: ".",
      entries: [],
      selected: null,
      parent: null
    });

    const grep = reactive({ pattern: "", path: ".", options: ""});
    const find = reactive({ pattern: "", path: ".", options: ""});
    const cat = reactive({ path: ""});
    const exec = reactive({ commandLine: "", result: "", error: "" });
    const feedback = reactive({ type: "info", message: ""});
    const shell = reactive({
      connected: false,
      ws: null,
      textOutput: "UnifyWeaver Shell\\nClick 'Connect' to start a session\\n\\n",
      textInput: ""
    });
    const shellTextMode = ref(false);  // false = terminal mode, true = text mode

    // API helpers
    const apiCall = async (endpoint, method = "GET", body = null) => {
      const headers = { "Content-Type": "application/json" };
      if (token.value) headers["Authorization"] = \`Bearer \${token.value}\`;
      const opts = { method, headers };
      if (body) opts.body = JSON.stringify(body);
      const res = await fetch(endpoint, opts);
      return res.json();
    };

    // Auth methods
    const checkAuth = async () => {
      const res = await apiCall("/auth/status");
      authRequired.value = res.data?.authRequired || false;
      if (token.value) {
        const me = await apiCall("/auth/me");
        if (me.success) user.value = me.data;
      }
    };

    const doLogin = async () => {
      loading.value = true;
      loginError.value = "";
      try {
        const res = await apiCall("/auth/login", "POST", {
          email: loginEmail.value,
          password: loginPassword.value
        });
        if (res.success) {
          token.value = res.data.token;
          user.value = res.data.user;
          localStorage.setItem("token", res.data.token);
        } else {
          loginError.value = res.error || "Login failed";
        }
      } catch (e) {
        loginError.value = e.message;
      }
      loading.value = false;
    };

    const doLogout = () => {
      token.value = "";
      user.value = null;
      localStorage.removeItem("token");
    };

    // Root/directory methods
    const onRootChange = () => {
      workingDir.value = ".";
      loadBrowse(".");
    };

    const resetWorkingDir = () => {
      workingDir.value = ".";
    };

    // Browse methods
    const loadBrowse = async (path = browse.path) => {
      loading.value = true;
      const res = await apiCall("/browse", "POST", { path, root: browseRoot.value });
      if (res.success) {
        browse.path = res.data.path;
        browse.entries = res.data.entries || [];
        browse.parent = res.data.parent;
        browse.selected = null;
      } else {
        results.value = res.error;
      }
      loading.value = false;
    };

    const navigateTo = (path) => loadBrowse(path);
    const navigateUp = () => {
      if (browse.parent) loadBrowse(browse.parent);
    };
    const selectFile = (path) => { browse.selected = path; };
    const handleEntryClick = (entry) => {
      if (entry.type === 'directory') {
        const newPath = browse.path === '.' ? entry.name : \`\${browse.path}/\${entry.name}\`;
        loadBrowse(newPath);
      } else {
        const filePath = browse.path === '.' ? entry.name : \`\${browse.path}/\${entry.name}\`;
        browse.selected = filePath;
      }
    };
    const viewFile = async () => {
      if (!browse.selected) return;
      cat.path = browse.selected;
      tab.value = 'cat';
      await doCat();
    };
    const searchHere = () => {
      grep.path = browse.path;
      tab.value = 'grep';
    };

    // Search methods
    const doGrep = async () => {
      loading.value = true;
      const res = await apiCall("/grep", "POST", {
        pattern: grep.pattern,
        path: grep.path || workingDir.value,
        options: grep.options,
        root: browseRoot.value
      });
      results.value = res.success ? res.data.output : res.error;
      resultCount.value = res.data?.count || 0;
      loading.value = false;
    };

    const doFind = async () => {
      loading.value = true;
      const res = await apiCall("/find", "POST", {
        pattern: find.pattern,
        path: find.path || workingDir.value,
        options: find.options,
        root: browseRoot.value
      });
      results.value = res.success ? res.data.output : res.error;
      resultCount.value = res.data?.count || 0;
      loading.value = false;
    };

    const doCat = async () => {
      loading.value = true;
      const res = await apiCall("/cat", "POST", {
        path: cat.path,
        cwd: workingDir.value,
        root: browseRoot.value
      });
      results.value = res.success ? res.data.content : res.error;
      loading.value = false;
    };

    const doExec = async () => {
      loading.value = true;
      exec.result = "";
      exec.error = "";

      // Parse command line into command and args
      const parts = exec.commandLine.trim().split(/\\s+/);
      const command = parts[0];
      const args = parts.slice(1);

      const res = await apiCall("/exec", "POST", {
        command,
        args,
        cwd: workingDir.value,
        root: browseRoot.value
      });

      if (res.success) {
        exec.result = res.data.stdout || "(no output)";
        if (res.data.stderr) exec.error = res.data.stderr;
      } else {
        exec.error = res.error || "Command failed";
      }
      loading.value = false;
    };

    const doFeedback = async () => {
      loading.value = true;
      const res = await apiCall("/feedback", "POST", {
        type: feedback.type,
        message: feedback.message
      });
      if (res.success) {
        feedback.message = "";
        results.value = "Feedback submitted. Thank you!";
      } else {
        results.value = res.error;
      }
      loading.value = false;
    };

    // Shell methods using xterm.js
    let terminal = null;
    let fitAddon = null;

    const initTerminal = () => {
      const container = document.getElementById("xterm_container");
      if (!container || terminal) return;

      terminal = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        fontFamily: 'Menlo, Monaco, "Courier New", monospace',
        theme: {
          background: '#1a1a2e',
          foreground: '#cdd6f4',
          cursor: '#e94560',
          cursorAccent: '#1a1a2e',
          selectionBackground: '#585b70',
        }
      });

      fitAddon = new FitAddon.FitAddon();
      terminal.loadAddon(fitAddon);
      terminal.open(container);
      fitAddon.fit();

      terminal.writeln('\\x1b[1;35m‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
      terminal.writeln('‚ïë     UnifyWeaver Shell                ‚ïë');
      terminal.writeln('‚ïë  Click "Connect" to start session    ‚ïë');
      terminal.writeln('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\\x1b[0m');
      terminal.writeln('');

      // Send input to WebSocket
      terminal.onData((data) => {
        if (shell.ws && shell.ws.readyState === WebSocket.OPEN) {
          shell.ws.send(JSON.stringify({ type: "input", data }));
        }
      });

      window.addEventListener("resize", () => fitAddon?.fit());
    };

    const connectShell = () => {
      if (!terminal) initTerminal();

      const protocol = location.protocol === "https:" ? "wss:" : "ws:";
      const wsUrl = \`\${protocol}//\${location.host}/shell?token=\${token.value}&root=\${browseRoot.value}\`;

      terminal.writeln(\`\\x1b[33mConnecting (root: \${browseRoot.value})...\\x1b[0m\`);
      shell.ws = new WebSocket(wsUrl);

      shell.ws.onopen = () => {
        shell.connected = true;
        terminal.writeln('\\x1b[32mConnected!\\x1b[0m');
      };

      shell.ws.onmessage = (e) => {
        try {
          const msg = JSON.parse(e.data);
          if (msg.type === "output" || msg.type === "error") {
            terminal.write(msg.data);
            // Strip ANSI codes for text mode and normalize line endings
            const plainText = msg.data
              .replace(/\\x1b\\[[0-9;]*m/g, '')
              .replace(/\\r\\n/g, '\\n')
              .replace(/\\r/g, '');
            if (plainText) shell.textOutput += plainText;
          } else if (msg.type === "prompt") {
            terminal.write(\`\\x1b[32m\${browseRoot.value}\\x1b[0m:\\x1b[34m~\\x1b[0m$ \`);
            shell.textOutput += \`\${browseRoot.value}:~$ \`;
          }
        } catch {
          terminal.write(e.data);
          shell.textOutput += e.data;
        }
      };

      shell.ws.onclose = () => {
        shell.connected = false;
        terminal.writeln('\\r\\n\\x1b[31mDisconnected\\x1b[0m');
        shell.textOutput += '\\nDisconnected\\n';
      };

      shell.ws.onerror = () => {
        shell.connected = false;
        terminal.writeln('\\x1b[31mConnection error\\x1b[0m');
        shell.textOutput += 'Connection error\\n';
      };
    };

    const clearShell = () => {
      if (terminal) terminal.clear();
      shell.textOutput = '';
    };

    const disconnectShell = () => {
      if (shell.ws) {
        shell.ws.close();
        shell.ws = null;
      }
    };

    const toggleTextMode = () => {
      shellTextMode.value = !shellTextMode.value;
    };

    const sendTextCommand = () => {
      const cmd = shell.textInput.trim();
      if (!cmd || !shell.ws || shell.ws.readyState !== WebSocket.OPEN) return;

      shell.textOutput += browseRoot.value + ':~$ ' + cmd + '\\n';
      shell.textInput = '';

      // Send each character then enter
      for (const char of cmd) {
        shell.ws.send(JSON.stringify({ type: "input", data: char }));
      }
      shell.ws.send(JSON.stringify({ type: "input", data: "\\r" }));
    };

    // Utilities
    const formatSize = (bytes) => {
      if (!bytes) return "";
      if (bytes < 1024) return bytes + " B";
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + " KB";
      return (bytes / 1024 / 1024).toFixed(1) + " MB";
    };

    // Lifecycle
    onMounted(() => {
      checkAuth();
      loadBrowse();
    });

    watch(tab, (newTab) => {
      if (newTab === "shell") {
        // Initialize terminal when shell tab is first opened
        setTimeout(() => initTerminal(), 100);
      }
    });

    return {
      authRequired, user, loginEmail, loginPassword, loginError, loading, token,
      tab, workingDir, browseRoot, results, resultCount,
      browse, grep, find, cat, exec, feedback, shell, shellTextMode,
      doLogin, doLogout, loadBrowse, navigateTo, navigateUp, selectFile, handleEntryClick, viewFile, searchHere, onRootChange, resetWorkingDir,
      doGrep, doFind, doCat, doExec, doFeedback,
      connectShell, disconnectShell, clearShell, toggleTextMode, sendTextCommand,
      formatSize
    };
  }
});

app.mount("#app");
  </script>
</body>
</html>`;
}

// ============================================================================
// Request Router
// ============================================================================

function sendJSON(res: http.ServerResponse, status: number, data: APIResponse): void {
  res.writeHead(status, {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  });
  res.end(JSON.stringify(data));
}

async function parseBody(req: http.IncomingMessage): Promise<RequestBody> {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk;
      if (body.length > MAX_BODY_SIZE) {
        reject(new Error('Body too large'));
      }
    });
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch {
        resolve({});
      }
    });
    req.on('error', reject);
  });
}

function extractToken(req: http.IncomingMessage): string | null {
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }
  return null;
}

async function handleRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): Promise<void> {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.writeHead(204, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    });
    res.end();
    return;
  }

  const parsedUrl = url.parse(req.url || '', true);
  const pathname = parsedUrl.pathname || '/';
  const method = req.method || 'GET';

  // Extract and verify token
  const token = extractToken(req);
  const user = token ? verifyToken(token) : null;

  try {
    const body = await parseBody(req);

    // Route to handlers
    if (method === 'GET' && pathname === '/health') {
      return handle_health(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/auth/status') {
      return handle_auth_status(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/auth/login') {
      return handle_auth_login(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/auth/me') {
      return handle_auth_me(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/commands') {
      return handle_commands(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/exec') {
      return handle_exec(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/grep') {
      return handle_grep(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/find') {
      return handle_find(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/cat') {
      return handle_cat(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/browse') {
      return handle_browse(req, res, body, user);
    }

    // Serve HTML interface at root
    if (method === 'GET' && pathname === '/') {
      res.writeHead(200, { 'Content-Type': 'text/html', 'Access-Control-Allow-Origin': '*' });
      res.end(getHTMLInterface());
      return;
    }

    // Not found
    sendJSON(res, 404, { success: false, error: 'Not found' });
  } catch (err) {
    console.error('Request error:', err);
    sendJSON(res, 500, { success: false, error: 'Internal server error' });
  }
}

// ============================================================================
// WebSocket Shell Session
// ============================================================================

interface ShellSession {
  ws: WebSocket;
  user: TokenPayload;
  process: ChildProcessWithoutNullStreams | null;
  currentDir: string;
  rootType: string;  // 'sandbox' | 'project' | 'home'
  rootDir: string;   // Actual root directory path
  inputBuffer: string;
  // Command history support
  history: string[];
  historyIndex: number;
  // Escape sequence buffer for arrow keys
  escapeBuffer: string;
}

function setupWebSocket(server: http.Server | https.Server): void {
  const wss = new WebSocketServer({ server });

  wss.on('connection', (ws: WebSocket, req: http.IncomingMessage) => {
    const parsedUrl = url.parse(req.url || '', true);
    const token = parsedUrl.query.token as string;
    const rootType = (parsedUrl.query.root as string) || 'sandbox';

    let payload: TokenPayload;

    if (AUTH_REQUIRED) {
      // Auth required - must have valid token
      if (!token) {
        ws.send(JSON.stringify({ type: 'error', data: 'Authentication required' }));
        ws.close(1008, 'Authentication required');
        return;
      }

      const verified = verifyToken(token);
      if (!verified) {
        ws.send(JSON.stringify({ type: 'error', data: 'Invalid token' }));
        ws.close(1008, 'Invalid token');
        return;
      }
      payload = verified;

      // Check for required roles
      const requiredRoles = ['shell'];
      const hasRequiredRole = requiredRoles.length === 0 || requiredRoles.some(r => payload.roles.includes(r as Role));
      if (!hasRequiredRole) {
        ws.send(JSON.stringify({ type: 'error', data: 'Shell access requires role: ' + requiredRoles.join(', ') }));
        ws.close(1008, 'Access denied');
        return;
      }
    } else {
      // Auth not required - use guest payload with full access
      payload = {
        sub: 'guest',
        email: 'guest@local',
        roles: ['user', 'admin', 'shell'] as Role[],
        permissions: ['*'],
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(Date.now() / 1000) + 86400
      };
    }

    console.log(`Shell session started for ${payload.email} (root: ${rootType})`);
    handleShellConnection(ws, payload, rootType);
  });
}

function handleShellConnection(ws: WebSocket, user: TokenPayload, rootType: string = 'sandbox'): void {
  const rootDir = getRootDir(rootType);
  const session: ShellSession = {
    ws,
    user,
    process: null,
    currentDir: rootDir,
    rootType,
    rootDir,
    inputBuffer: '',
    history: [],
    historyIndex: -1,
    escapeBuffer: ''
  };

  // Send welcome message
  const welcome = `\r\nConnected to UnifyWeaver Shell\r\nUser: ${user.email} [${user.roles.join(', ')}]\r\nRoot: ${rootType} (${rootDir})\r\nType "help" for commands, "exit" to disconnect\r\n\r\n`;
  ws.send(JSON.stringify({ type: 'output', data: welcome }));
  ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));

  ws.on('message', (data: Buffer | string) => {
    try {
      const msg = JSON.parse(data.toString());
      if (msg.type === 'input') {
        // Debug: log received input
        const chars = [...msg.data].map(c => c.charCodeAt(0));
        console.log(`Shell input: "${msg.data}" chars: [${chars.join(', ')}]`);
        handleShellInput(session, msg.data);
      }
    } catch (err) {
      // Try handling as raw text (for compatibility)
      const rawData = data.toString();
      console.log(`Shell raw input: "${rawData}" (JSON parse failed)`);
      handleShellInput(session, rawData);
    }
  });

  ws.on('close', () => {
    if (session.process) {
      session.process.kill();
      session.process = null;
    }
    console.log(`Shell session closed for ${user.email}`);
  });
}

function handleShellInput(session: ShellSession, input: string): void {
  const { ws } = session;

  // Process each character in the input
  for (const char of input) {
    processShellChar(session, char);
  }
}

function clearInputLine(session: ShellSession): void {
  const { ws, inputBuffer } = session;
  if (inputBuffer.length > 0) {
    // Move cursor back, overwrite with spaces, move back again
    const backspaces = '\b'.repeat(inputBuffer.length);
    const spaces = ' '.repeat(inputBuffer.length);
    ws.send(JSON.stringify({ type: 'output', data: backspaces + spaces + backspaces }));
  }
}

function processShellChar(session: ShellSession, char: string): void {
  const { ws } = session;

  // If we're in the middle of an escape sequence
  if (session.escapeBuffer) {
    session.escapeBuffer += char;

    // Check for complete escape sequences
    if (session.escapeBuffer === '\x1b[A') {
      // Up arrow - previous command in history
      session.escapeBuffer = '';
      if (session.history.length > 0 && session.historyIndex < session.history.length - 1) {
        clearInputLine(session);
        session.historyIndex++;
        session.inputBuffer = session.history[session.history.length - 1 - session.historyIndex] || '';
        ws.send(JSON.stringify({ type: 'output', data: session.inputBuffer }));
      }
    } else if (session.escapeBuffer === '\x1b[B') {
      // Down arrow - next command in history
      session.escapeBuffer = '';
      if (session.historyIndex > 0) {
        clearInputLine(session);
        session.historyIndex--;
        session.inputBuffer = session.history[session.history.length - 1 - session.historyIndex] || '';
        ws.send(JSON.stringify({ type: 'output', data: session.inputBuffer }));
      } else if (session.historyIndex === 0) {
        clearInputLine(session);
        session.historyIndex = -1;
        session.inputBuffer = '';
      }
    } else if (session.escapeBuffer === '\x1b[C') {
      // Right arrow - currently not supporting cursor movement within line
      session.escapeBuffer = '';
    } else if (session.escapeBuffer === '\x1b[D') {
      // Left arrow - currently not supporting cursor movement within line
      session.escapeBuffer = '';
    } else if (session.escapeBuffer.length > 4) {
      // Unknown/too long escape sequence, discard
      session.escapeBuffer = '';
    }
    // Otherwise keep collecting escape sequence characters
    return;
  }

  // Escape character - start of escape sequence
  if (char === '\x1b') {
    session.escapeBuffer = char;
    return;
  }

  // Enter key
  if (char === '\r' || char === '\n') {
    ws.send(JSON.stringify({ type: 'output', data: '\r\n' }));
    const command = session.inputBuffer.trim();
    session.inputBuffer = '';
    session.historyIndex = -1;  // Reset history navigation
    if (command) {
      executeShellCommand(session, command);
    } else {
      ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
    }
  }
  // Backspace
  else if (char === '\x7f' || char === '\b') {
    if (session.inputBuffer.length > 0) {
      session.inputBuffer = session.inputBuffer.slice(0, -1);
      ws.send(JSON.stringify({ type: 'output', data: '\b \b' }));
    }
  }
  // Ctrl+C
  else if (char === '\x03') {
    if (session.process) {
      session.process.kill('SIGINT');
      session.process = null;
    }
    ws.send(JSON.stringify({ type: 'output', data: '^C\r\n' }));
    session.inputBuffer = '';
    session.historyIndex = -1;
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
  }
  // Ctrl+D (EOF)
  else if (char === '\x04') {
    if (session.inputBuffer.length === 0) {
      ws.send(JSON.stringify({ type: 'output', data: 'exit\r\n' }));
      ws.close();
    }
  }
  // Tab (for future tab completion)
  else if (char === '\t') {
    // Currently just insert spaces, could add tab completion later
    session.inputBuffer += '    ';
    ws.send(JSON.stringify({ type: 'output', data: '    ' }));
  }
  // Printable characters
  else if (char >= ' ' && char <= '~') {
    session.inputBuffer += char;
    ws.send(JSON.stringify({ type: 'output', data: char }));
  }
}

function executeShellCommand(session: ShellSession, command: string): void {
  const { ws } = session;

  // Save to command history (avoid consecutive duplicates)
  if (command && session.history[session.history.length - 1] !== command) {
    session.history.push(command);
    // Keep history to reasonable size
    if (session.history.length > 100) {
      session.history.shift();
    }
  }
  session.historyIndex = -1;

  // Built-in: help
  if (command === 'help') {
    const helpText = `\r\nUnifyWeaver Shell - Built-in Commands:\r\n  help    - Show this help\r\n  cd DIR  - Change directory\r\n  pwd     - Print working directory\r\n  exit    - Disconnect\r\n\r\nYou can run any shell command. Output is streamed in real-time.\r\n\r\n`;
    ws.send(JSON.stringify({ type: 'output', data: helpText }));
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
    return;
  }

  // Built-in: exit
  if (command === 'exit' || command === 'quit') {
    ws.send(JSON.stringify({ type: 'output', data: 'Goodbye!\r\n' }));
    ws.close();
    return;
  }

  // Built-in: cd
  if (command.startsWith('cd ') || command === 'cd') {
    const targetDir = command.slice(3).trim() || session.rootDir;
    let newDir: string;

    if (path.isAbsolute(targetDir)) {
      newDir = targetDir;
    } else if (targetDir === '~') {
      newDir = session.rootDir;
    } else if (targetDir.startsWith('~/')) {
      newDir = path.join(session.rootDir, targetDir.slice(2));
    } else {
      newDir = path.resolve(session.currentDir, targetDir);
    }

    // Security: ensure within selected root
    if (!newDir.startsWith(session.rootDir)) {
      ws.send(JSON.stringify({ type: 'output', data: `\x1b[31mcd: Access denied - outside ${session.rootType} root\x1b[0m\r\n` }));
      ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
      return;
    }

    if (fs.existsSync(newDir) && fs.statSync(newDir).isDirectory()) {
      session.currentDir = newDir;
    } else {
      ws.send(JSON.stringify({ type: 'output', data: `\x1b[31mcd: ${targetDir}: No such directory\x1b[0m\r\n` }));
    }
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
    return;
  }

  // Built-in: pwd
  if (command === 'pwd') {
    ws.send(JSON.stringify({ type: 'output', data: session.currentDir + '\r\n' }));
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
    return;
  }

  // Execute shell command
  const proc = spawn('sh', ['-c', command], {
    cwd: session.currentDir,
    env: { ...process.env, HOME: session.rootDir, TERM: 'xterm-256color' }
  });

  session.process = proc;

  proc.stdout.on('data', (data: Buffer) => {
    ws.send(JSON.stringify({ type: 'output', data: data.toString().replace(/\n/g, '\r\n') }));
  });

  proc.stderr.on('data', (data: Buffer) => {
    ws.send(JSON.stringify({ type: 'output', data: `\x1b[31m${data.toString().replace(/\n/g, '\r\n')}\x1b[0m` }));
  });

  proc.on('close', (code: number) => {
    session.process = null;
    if (code !== 0) {
      ws.send(JSON.stringify({ type: 'output', data: `\x1b[33m[exit code: ${code}]\x1b[0m\r\n` }));
    }
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
  });

  proc.on('error', (err: Error) => {
    session.process = null;
    ws.send(JSON.stringify({ type: 'output', data: `\x1b[31mError: ${err.message}\x1b[0m\r\n` }));
    ws.send(JSON.stringify({ type: 'prompt', cwd: session.currentDir }));
  });
}

// ============================================================================
// Server Setup
// ============================================================================

interface SSLOptions {
  cert?: string;
  key?: string;
}

function startServer(port: number, ssl?: SSLOptions): void {
  let server: http.Server | https.Server;
  let protocol: string;

  if (ssl?.cert && ssl?.key) {
    // HTTPS mode
    try {
      const sslOptions = {
        cert: fs.readFileSync(ssl.cert),
        key: fs.readFileSync(ssl.key)
      };
      server = https.createServer(sslOptions, handleRequest);
      protocol = 'https';
    } catch (err) {
      console.error(`Failed to load SSL certificates: ${err}`);
      process.exit(1);
    }
  } else {
    // HTTP mode
    server = http.createServer(handleRequest);
    protocol = 'http';
  }

  setupWebSocket(server);

  server.listen(port, () => {
    const wsProtocol = protocol === 'https' ? 'wss' : 'ws';
    console.log(`Server running at ${protocol}://localhost:${port}`);
    console.log(`SSL/TLS: ${protocol === 'https' ? 'ENABLED' : 'disabled'}`);
    console.log(`Auth: ${AUTH_REQUIRED ? 'ENABLED' : 'disabled'}`);
  });

  server.on('error', (err: NodeJS.ErrnoException) => {
    if (err.code === 'EADDRINUSE') {
      console.error(`Port ${port} is already in use`);
    } else {
      console.error('Server error:', err);
    }
    process.exit(1);
  });
}

// ============================================================================
// CLI Entry
// ============================================================================

function main(): void {
  const args = process.argv.slice(2);
  let port = 3001;
  let certPath: string | undefined;
  let keyPath: string | undefined;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--port':
        port = parseInt(args[++i], 10);
        if (isNaN(port)) {
          console.error('Invalid port number');
          process.exit(1);
        }
        break;
      case '--cert':
        certPath = args[++i];
        break;
      case '--key':
        keyPath = args[++i];
        break;
      case '--help':
      case '-h':
        console.log(`
http_cli - Generated by UnifyWeaver

Usage:
  ts-node server.ts [options]

Options:
  --port <number>   Port to listen on (default: 3001)
  --cert <path>     Path to SSL certificate (enables HTTPS)
  --key <path>      Path to SSL private key (enables HTTPS)
  --help, -h        Show this help

Environment:
  AUTH_REQUIRED     Set to 'true' to require authentication
`);
        process.exit(0);
    }
  }

  // Validate SSL options
  if ((certPath && !keyPath) || (!certPath && keyPath)) {
    console.error('Both --cert and --key are required for HTTPS');
    process.exit(1);
  }

  const ssl = certPath && keyPath ? { cert: certPath, key: keyPath } : undefined;
  startServer(port, ssl);
}

main();
