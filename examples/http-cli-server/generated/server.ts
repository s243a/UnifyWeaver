#!/usr/bin/env ts-node
/**
 * http_cli_server - HTTP/HTTPS Server
 * Generated by UnifyWeaver http_server_generator.pl
 * DO NOT EDIT - regenerate from spec
 */

import * as http from 'http';
import * as url from 'url';
import * as path from 'path';
import * as fs from 'fs';
import * as https from 'https';
import WebSocket, { WebSocketServer } from 'ws';
import {
  login,
  verifyToken,
  getUserFromToken,
  hasRole,
  TokenPayload
} from './auth';

// ============================================================================
// Configuration
// ============================================================================

const DEFAULT_PORT = 3001;
const MAX_BODY_SIZE = 1024 * 1024; // 1MB
const ALLOWED_ORIGINS = ['*'];

// Authentication: set AUTH_REQUIRED=true to require login
const AUTH_REQUIRED = process.env.AUTH_REQUIRED === 'true';

// ============================================================================
// Types
// ============================================================================

interface APIResponse {
  success: boolean;
  data?: unknown;
  error?: string;
}

interface RequestBody {
  [key: string]: unknown;
}

/**
 * GET /health - health endpoint
 */
async function handle_health(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  // TODO: Implement health logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'health' } });
}

/**
 * GET /auth/status - auth_status endpoint
 */
async function handle_auth_status(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  // TODO: Implement auth_status logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'auth_status' } });
}

/**
 * POST /auth/login - auth_login endpoint
 */
async function handle_auth_login(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Public endpoint - no auth required

  // TODO: Implement auth_login logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'auth_login' } });
}

/**
 * GET /auth/me - auth_me endpoint
 */
async function handle_auth_me(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement auth_me logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'auth_me' } });
}

/**
 * GET /commands - commands endpoint
 */
async function handle_commands(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement commands logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'commands' } });
}

/**
 * POST /browse - browse endpoint
 */
async function handle_browse(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement browse logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'browse' } });
}

/**
 * POST /grep - grep endpoint
 */
async function handle_grep(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement grep logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'grep' } });
}

/**
 * POST /find - find endpoint
 */
async function handle_find(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement find logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'find' } });
}

/**
 * POST /cat - cat endpoint
 */
async function handle_cat(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement cat logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'cat' } });
}

/**
 * POST /exec - exec endpoint
 */
async function handle_exec(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement exec logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'exec' } });
}

/**
 * POST /feedback - feedback endpoint
 */
async function handle_feedback(
  req: http.IncomingMessage,
  res: http.ServerResponse,
  body: RequestBody,
  user: TokenPayload | null
): Promise<void> {
  // Requires roles: [user,admin,shell]
  if (AUTH_REQUIRED) {
    if (!user) return sendJSON(res, 401, { success: false, error: 'Authentication required' });
    const hasRequiredRole = ['user', 'admin', 'shell'].some(r => user.roles.includes(r));
    if (!hasRequiredRole) return sendJSON(res, 403, { success: false, error: 'Insufficient permissions' });
  }

  // TODO: Implement feedback logic
  sendJSON(res, 200, { success: true, data: { endpoint: 'feedback' } });
}

// ============================================================================
// Request Router
// ============================================================================

function sendJSON(res: http.ServerResponse, status: number, data: APIResponse): void {
  res.writeHead(status, {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, Authorization'
  });
  res.end(JSON.stringify(data));
}

async function parseBody(req: http.IncomingMessage): Promise<RequestBody> {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => {
      body += chunk;
      if (body.length > MAX_BODY_SIZE) {
        reject(new Error('Body too large'));
      }
    });
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch {
        resolve({});
      }
    });
    req.on('error', reject);
  });
}

function extractToken(req: http.IncomingMessage): string | null {
  const authHeader = req.headers.authorization;
  if (authHeader?.startsWith('Bearer ')) {
    return authHeader.substring(7);
  }
  return null;
}

async function handleRequest(
  req: http.IncomingMessage,
  res: http.ServerResponse
): Promise<void> {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    res.writeHead(204, {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization'
    });
    res.end();
    return;
  }

  const parsedUrl = url.parse(req.url || '', true);
  const pathname = parsedUrl.pathname || '/';
  const method = req.method || 'GET';

  // Extract and verify token
  const token = extractToken(req);
  const user = token ? verifyToken(token) : null;

  try {
    const body = await parseBody(req);

    // Route to handlers
    if (method === 'GET' && pathname === '/health') {
      return handle_health(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/auth/status') {
      return handle_auth_status(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/auth/login') {
      return handle_auth_login(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/auth/me') {
      return handle_auth_me(req, res, body, user);
    }
    if (method === 'GET' && pathname === '/commands') {
      return handle_commands(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/browse') {
      return handle_browse(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/grep') {
      return handle_grep(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/find') {
      return handle_find(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/cat') {
      return handle_cat(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/exec') {
      return handle_exec(req, res, body, user);
    }
    if (method === 'POST' && pathname === '/feedback') {
      return handle_feedback(req, res, body, user);
    }

    // Not found
    sendJSON(res, 404, { success: false, error: 'Not found' });
  } catch (err) {
    console.error('Request error:', err);
    sendJSON(res, 500, { success: false, error: 'Internal server error' });
  }
}

// ============================================================================
// WebSocket Handler
// ============================================================================

function setupWebSocket(server: http.Server | https.Server): void {
  const wss = new WebSocketServer({ server });

  wss.on('connection', (ws: WebSocket, req: http.IncomingMessage) => {
    const parsedUrl = url.parse(req.url || '', true);
    const token = parsedUrl.query.token as string;

    if (!token) {
      ws.send(JSON.stringify({ type: 'error', data: 'Authentication required' }));
      ws.close(1008, 'Authentication required');
      return;
    }

    const payload = verifyToken(token);
    if (!payload) {
      ws.send(JSON.stringify({ type: 'error', data: 'Invalid token' }));
      ws.close(1008, 'Invalid token');
      return;
    }

    // Check for required roles
    const requiredRoles = ['shell'];
    const hasRole = requiredRoles.length === 0 || requiredRoles.some(r => payload.roles.includes(r));
    if (!hasRole) {
      ws.send(JSON.stringify({ type: 'error', data: 'Insufficient permissions' }));
      ws.close(1008, 'Access denied');
      return;
    }

    console.log(`WebSocket connection from ${payload.email}`);
    handleWebSocketConnection(ws, payload);
  });
}

function handleWebSocketConnection(ws: WebSocket, user: TokenPayload): void {
  ws.send(JSON.stringify({ type: 'connected', user: user.email }));

  ws.on('message', (data: Buffer) => {
    try {
      const msg = JSON.parse(data.toString());
      // Handle WebSocket messages
      ws.send(JSON.stringify({ type: 'echo', data: msg }));
    } catch (err) {
      ws.send(JSON.stringify({ type: 'error', data: 'Invalid message format' }));
    }
  });

  ws.on('close', () => {
    console.log(`WebSocket disconnected: ${user.email}`);
  });
}

// ============================================================================
// Server Setup
// ============================================================================

interface SSLOptions {
  cert?: string;
  key?: string;
}

function startServer(port: number, ssl?: SSLOptions): void {
  let server: http.Server | https.Server;
  let protocol: string;

  if (ssl?.cert && ssl?.key) {
    // HTTPS mode
    try {
      const sslOptions = {
        cert: fs.readFileSync(ssl.cert),
        key: fs.readFileSync(ssl.key)
      };
      server = https.createServer(sslOptions, handleRequest);
      protocol = 'https';
    } catch (err) {
      console.error(`Failed to load SSL certificates: ${err}`);
      process.exit(1);
    }
  } else {
    // HTTP mode
    server = http.createServer(handleRequest);
    protocol = 'http';
  }

  setupWebSocket(server);

  server.listen(port, () => {
    const wsProtocol = protocol === 'https' ? 'wss' : 'ws';
    console.log(`Server running at ${protocol}://localhost:${port}`);
    console.log(`SSL/TLS: ${protocol === 'https' ? 'ENABLED' : 'disabled'}`);
    console.log(`Auth: ${AUTH_REQUIRED ? 'ENABLED' : 'disabled'}`);
  });

  server.on('error', (err: NodeJS.ErrnoException) => {
    if (err.code === 'EADDRINUSE') {
      console.error(`Port ${port} is already in use`);
    } else {
      console.error('Server error:', err);
    }
    process.exit(1);
  });
}

// ============================================================================
// CLI Entry
// ============================================================================

function main(): void {
  const args = process.argv.slice(2);
  let port = 3001;
  let certPath: string | undefined;
  let keyPath: string | undefined;

  // Parse arguments
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case '--port':
        port = parseInt(args[++i], 10);
        if (isNaN(port)) {
          console.error('Invalid port number');
          process.exit(1);
        }
        break;
      case '--cert':
        certPath = args[++i];
        break;
      case '--key':
        keyPath = args[++i];
        break;
      case '--help':
      case '-h':
        console.log(`
http_cli_server - Generated by UnifyWeaver

Usage:
  ts-node server.ts [options]

Options:
  --port <number>   Port to listen on (default: 3001)
  --cert <path>     Path to SSL certificate (enables HTTPS)
  --key <path>      Path to SSL private key (enables HTTPS)
  --help, -h        Show this help

Environment:
  AUTH_REQUIRED     Set to 'true' to require authentication
`);
        process.exit(0);
    }
  }

  // Validate SSL options
  if ((certPath && !keyPath) || (!certPath && keyPath)) {
    console.error('Both --cert and --key are required for HTTPS');
    process.exit(1);
  }

  const ssl = certPath && keyPath ? { cert: certPath, key: keyPath } : undefined;
  startServer(port, ssl);
}

main();
