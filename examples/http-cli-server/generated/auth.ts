// Generated by UnifyWeaver auth_generator.pl
// DO NOT EDIT - regenerate from spec

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

// Note: For production, use actual bcrypt package
// npm install bcrypt @types/bcrypt
// import bcrypt from 'bcrypt';

// ============================================================================
// Types
// ============================================================================

export type Role = 'shell' | 'admin' | 'user';

export interface User {
  email: string;
  passwordHash: string;
  roles: Role[];
  permissions: string[];
}

export interface TokenPayload {
  sub: string;
  email: string;
  roles: Role[];
  permissions: string[];
  iat: number;
  exp: number;
}

export interface AuthResult {
  success: boolean;
  token?: string;
  user?: Omit<User, 'passwordHash'>;
  error?: string;
}

// ============================================================================
// Configuration
// ============================================================================

const JWT_SECRET = process.env.JWT_SECRET || 'change-this-in-production';
const TOKEN_EXPIRY = 86400; // seconds
const USERS_FILE = process.env.USERS_FILE || 'users.txt';

// ============================================================================
// Password Hashing (bcrypt-compatible with SHA256 fallback)
// ============================================================================

let bcryptAvailable = false;
let bcrypt: any;
try {
  bcrypt = require('bcrypt');
  bcryptAvailable = true;
} catch {
  console.log('bcrypt not available, using SHA256 fallback');
}

function hashPassword(password: string): string {
  if (bcryptAvailable) {
    return bcrypt.hashSync(password, 12);
  }
  // SHA256 fallback
  const salt = crypto.randomBytes(16).toString('hex');
  const hash = crypto.createHash('sha256').update(password + salt).digest('hex');
  return `sha256:${salt}:${hash}`;
}

function verifyPassword(password: string, storedHash: string): boolean {
  if (bcryptAvailable && storedHash.startsWith('$2')) {
    try {
      return bcrypt.compareSync(password, storedHash);
    } catch {
      return false;
    }
  }
  if (storedHash.startsWith('sha256:')) {
    const [, salt, hash] = storedHash.split(':');
    const testHash = crypto.createHash('sha256').update(password + salt).digest('hex');
    return hash === testHash;
  }
  // Fallback for plain passwords (development only)
  return password === storedHash;
}

// ============================================================================
// JWT Token Functions
// ============================================================================

function base64UrlEncode(data: object): string {
  return Buffer.from(JSON.stringify(data))
    .toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

function base64UrlDecode(str: string): any {
  let s = str.replace(/-/g, '+').replace(/_/g, '/');
  while (s.length % 4) s += '=';
  return JSON.parse(Buffer.from(s, 'base64').toString());
}

function createToken(payload: Omit<TokenPayload, 'iat' | 'exp'>): string {
  const header = { alg: 'HS256', typ: 'JWT' };
  const now = Math.floor(Date.now() / 1000);
  const tokenPayload: TokenPayload = {
    ...payload,
    iat: now,
    exp: now + TOKEN_EXPIRY
  };

  const headerB64 = base64UrlEncode(header);
  const payloadB64 = base64UrlEncode(tokenPayload);
  const signature = crypto
    .createHmac('sha256', JWT_SECRET)
    .update(`${headerB64}.${payloadB64}`)
    .digest('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');

  return `${headerB64}.${payloadB64}.${signature}`;
}

function verifyToken(token: string): TokenPayload | null {
  try {
    const [headerB64, payloadB64, signature] = token.split('.');

    const expectedSig = crypto
      .createHmac('sha256', JWT_SECRET)
      .update(`${headerB64}.${payloadB64}`)
      .digest('base64')
      .replace(/=/g, '')
      .replace(/\+/g, '-')
      .replace(/\//g, '_');

    if (signature !== expectedSig) {
      return null;
    }

    const payload = base64UrlDecode(payloadB64) as TokenPayload;

    if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {
      return null; // Token expired
    }

    return payload;
  } catch {
    return null;
  }
}

function getUserFromToken(token: string): Omit<User, 'passwordHash'> | null {
  const payload = verifyToken(token);
  if (!payload) return null;
  return {
    email: payload.email,
    roles: payload.roles,
    permissions: payload.permissions
  };
}

// ============================================================================
// User Storage (Text File Backend)
// ============================================================================

function ensureUsersFile(): void {
  const dir = path.dirname(USERS_FILE);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  if (!fs.existsSync(USERS_FILE)) {
    fs.writeFileSync(USERS_FILE, '# Users file\n# Format: email:passwordHash:roles:permissions\n');
  }
}

function loadUsers(): Map<string, User> {
  ensureUsersFile();
  const users = new Map<string, User>();
  const content = fs.readFileSync(USERS_FILE, 'utf-8');

  for (const line of content.split('\n')) {
    if (line.startsWith('#') || !line.trim()) continue;
    const parts = line.split(':');
    if (parts.length >= 2) {
      const [email, passwordHash, rolesStr = '', permsStr = ''] = parts;
      users.set(email.toLowerCase(), {
        email,
        passwordHash,
        roles: rolesStr ? rolesStr.split(',').map(r => r.trim()) as Role[] : ['user'],
        permissions: permsStr ? permsStr.split(',').map(p => p.trim()) : ['read']
      });
    }
  }

  return users;
}

function saveUser(email: string, passwordHash: string, roles: Role[], permissions: string[]): void {
  ensureUsersFile();
  const line = `${email}:${passwordHash}:${roles.join(',')}:${permissions.join(',')}\n`;
  fs.appendFileSync(USERS_FILE, line);
}

function userExists(email: string): boolean {
  const users = loadUsers();
  return users.has(email.toLowerCase());
}

function login(email: string, password: string): AuthResult {
  const users = loadUsers();
  const user = users.get(email.toLowerCase());

  if (!user) {
    return { success: false, error: 'User not found' };
  }

  if (!verifyPassword(password, user.passwordHash)) {
    return { success: false, error: 'Invalid password' };
  }

  const token = createToken({
    sub: user.email,
    email: user.email,
    roles: user.roles,
    permissions: user.permissions
  });

  return {
    success: true,
    token,
    user: {
      email: user.email,
      roles: user.roles,
      permissions: user.permissions
    }
  };
}

// ============================================================================
// Role Checking Functions
// ============================================================================

function hasRole(payload: TokenPayload | null, role: Role): boolean {
  if (!payload) return false;
  return payload.roles.includes(role);
}

function canAccessShell(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  return roles.includes('shell');
}

function canExecuteCommands(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  const roles = payload.roles;
  return roles.includes('shell') || roles.includes('admin');
}

function canBrowse(payload: TokenPayload | null): boolean {
  if (!payload) return false;
  return payload.roles.length > 0; // Any authenticated user
}

// ============================================================================
// Default Users
// ============================================================================

const DEFAULT_USERS = [
  { email: 'shell@local', password: 'shell', roles: ['shell', 'admin', 'user'] },
  { email: 'admin@local', password: 'admin', roles: ['admin', 'user'] },
  { email: 'user@local', password: 'user', roles: ['user'] }
];

function ensureDefaultUsers(): void {
  for (const user of DEFAULT_USERS) {
    if (!userExists(user.email)) {
      const hash = hashPassword(user.password);
      saveUser(user.email, hash, user.roles, ['read']);
      console.log(`Created default user: ${user.email}`);
    }
  }
}

// ============================================================================
// Exports
// ============================================================================

export {
  login,
  verifyToken,
  getUserFromToken,
  hasRole,
  canAccessShell,
  canExecuteCommands,
  canBrowse,
  hashPassword,
  verifyPassword,
  createToken,
  ensureDefaultUsers
};