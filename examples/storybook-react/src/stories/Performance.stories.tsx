import type { Meta, StoryObj } from "@storybook/react";
import React, { useState, useMemo, useEffect, useRef } from "react";
import {
  VirtualList,
  LazyLoadGrid,
  ChunkedDataLoader,
  PerformanceMetrics,
  MemoizedList,
} from "../components/Performance";
import { ThemeProvider } from "../components/ThemeToggle";

const meta: Meta = {
  title: "Performance",
  tags: ["autodocs"],
  decorators: [
    (Story) => (
      <ThemeProvider>
        <div style={{ padding: "1rem" }}>
          <Story />
        </div>
      </ThemeProvider>
    ),
  ],
  parameters: {
    docs: {
      description: {
        component: `
Performance optimization components generated by UnifyWeaver for handling large datasets.

**Generated from:** \`generate_virtual_scroll/2\`, \`generate_lazy_loader/2\` in \`performance_generator.pl\`

\`\`\`prolog
% Enable virtual scrolling for large lists
?- declare_performance(data_table, virtual_scroll, [
    item_height(40),
    overscan(3),
    enable_smooth_scroll(true)
  ]).

% Enable lazy loading with intersection observer
?- declare_performance(image_grid, lazy_load, [
    page_size(20),
    threshold(0.1),
    loading_indicator(true)
  ]).

% Enable chunked data processing
?- declare_performance(large_chart, chunked_load, [
    chunk_size(1000),
    parallel_chunks(2),
    cache_strategy(lru)
  ]).
\`\`\`

### Performance Patterns

| Pattern | Use Case | Benefit |
|---------|----------|---------|
| Virtual Scroll | Long lists (1000+ items) | O(1) render time |
| Lazy Loading | Paginated content | Reduced initial load |
| Chunked Loading | Large datasets | Progressive rendering |
| Memoization | Frequent re-renders | Reduced calculations |
        `,
      },
    },
  },
};

export default meta;

export const VirtualScrolling: StoryObj = {
  render: () => {
    const [visibleRange, setVisibleRange] = useState({ start: 0, end: 0 });

    const items = useMemo(
      () =>
        Array.from({ length: 10000 }, (_, i) => ({
          id: `item-${i}`,
          content: `Row ${i + 1} - Lorem ipsum dolor sit amet, consectetur adipiscing elit`,
        })),
      []
    );

    const startTime = useRef(performance.now());
    const [renderTime, setRenderTime] = useState(0);

    useEffect(() => {
      setRenderTime(performance.now() - startTime.current);
    }, []);

    return (
      <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
        <PerformanceMetrics
          itemCount={items.length}
          renderTime={renderTime}
        />

        <div
          style={{
            display: "flex",
            gap: "0.5rem",
            fontSize: "0.875rem",
            color: "var(--color-text-secondary)",
          }}
        >
          <span>
            Visible rows: {visibleRange.start + 1} - {visibleRange.end} of{" "}
            {items.length.toLocaleString()}
          </span>
          <span>|</span>
          <span>
            DOM nodes: {visibleRange.end - visibleRange.start} (not{" "}
            {items.length.toLocaleString()})
          </span>
        </div>

        <VirtualList
          items={items}
          itemHeight={40}
          containerHeight={400}
          overscan={5}
          onVisibleRangeChange={(start, end) => setVisibleRange({ start, end })}
        />

        <p
          style={{
            fontSize: "0.75rem",
            color: "var(--color-text-secondary)",
            margin: 0,
          }}
        >
          üí° Virtual scrolling renders only visible items, enabling smooth
          scrolling through 10,000+ rows with constant memory usage.
        </p>
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story: `
Virtual scrolling renders only the visible items plus a small overscan buffer.
This maintains O(1) render time regardless of list size.

**10,000 items** with only ~15 DOM nodes at any time.
        `,
      },
    },
  },
};

export const SmallListComparison: StoryObj = {
  render: () => {
    const items = useMemo(
      () =>
        Array.from({ length: 100 }, (_, i) => ({
          id: `item-${i}`,
          content: `Item ${i + 1}`,
        })),
      []
    );

    return (
      <div style={{ display: "grid", gridTemplateColumns: "1fr 1fr", gap: "1rem" }}>
        <div>
          <h4 style={{ margin: "0 0 0.5rem 0", color: "var(--color-text-primary)" }}>
            Virtual List (100 items)
          </h4>
          <VirtualList
            items={items}
            itemHeight={36}
            containerHeight={300}
          />
        </div>
        <div>
          <h4 style={{ margin: "0 0 0.5rem 0", color: "var(--color-text-primary)" }}>
            Regular List (100 items)
          </h4>
          <div
            style={{
              height: "300px",
              overflow: "auto",
              border: "1px solid var(--color-border)",
              borderRadius: "var(--border-radius-md)",
              background: "var(--color-surface)",
            }}
          >
            {items.map((item, index) => (
              <div
                key={item.id}
                style={{
                  height: "36px",
                  padding: "0 1rem",
                  display: "flex",
                  alignItems: "center",
                  borderBottom: "1px solid var(--color-border)",
                  background:
                    index % 2 === 0
                      ? "var(--color-surface)"
                      : "var(--color-background)",
                }}
              >
                <span
                  style={{
                    width: "60px",
                    color: "var(--color-text-secondary)",
                    fontSize: "0.75rem",
                  }}
                >
                  #{index + 1}
                </span>
                <span style={{ color: "var(--color-text-primary)" }}>
                  {item.content}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story: "For small lists, virtual scrolling and regular lists behave similarly.",
      },
    },
  },
};

export const InfiniteScrollGrid: StoryObj = {
  render: () => (
    <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
      <p style={{ color: "var(--color-text-secondary)", fontSize: "0.875rem" }}>
        Scroll down to automatically load more items using Intersection Observer.
      </p>
      <div
        style={{
          height: "500px",
          overflow: "auto",
          border: "1px solid var(--color-border)",
          borderRadius: "var(--border-radius-md)",
          padding: "1rem",
        }}
      >
        <LazyLoadGrid
          totalItems={100}
          pageSize={12}
          columns={3}
          renderItem={(index) => (
            <div
              style={{
                aspectRatio: "1",
                background: `hsl(${(index * 25) % 360}, 70%, 60%)`,
                borderRadius: "var(--border-radius-md)",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                color: "white",
                fontWeight: 600,
                fontSize: "1.25rem",
              }}
            >
              {index + 1}
            </div>
          )}
        />
      </div>
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story: `
Lazy loading with Intersection Observer for smooth infinite scroll.

\`\`\`prolog
% Generate lazy-loaded grid
?- declare_lazy_grid(image_gallery, [
    initial_count(12),
    load_more_count(12),
    intersection_threshold(0.1)
  ]).
\`\`\`
        `,
      },
    },
  },
};

export const ChunkedDataProcessing: StoryObj = {
  render: () => (
    <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
      <p style={{ color: "var(--color-text-secondary)", fontSize: "0.875rem" }}>
        Click chunk buttons to load data progressively. Useful for large datasets
        that would block the UI if loaded all at once.
      </p>
      <ChunkedDataLoader
        totalChunks={8}
        chunkSize={100}
        renderChunk={(index, data) => (
          <div
            style={{
              padding: "0.75rem",
              background: "var(--color-surface)",
              borderRadius: "var(--border-radius-sm)",
              border: "1px solid var(--color-border)",
            }}
          >
            <span style={{ fontWeight: 600, color: "var(--color-text-primary)" }}>
              Chunk {index + 1}:
            </span>{" "}
            <span style={{ color: "var(--color-text-secondary)" }}>
              {data.length} items ({data[0]} - {data[data.length - 1]})
            </span>
          </div>
        )}
      />
    </div>
  ),
  parameters: {
    docs: {
      description: {
        story: `
Chunked loading for processing large datasets without blocking the UI.

\`\`\`prolog
% Configure chunked data loading
?- declare_chunked_loader(large_dataset, [
    chunk_size(1000),
    parallel_load(false),
    cache_loaded(true)
  ]).
\`\`\`
        `,
      },
    },
  },
};

export const MemoizationDemo: StoryObj = {
  render: () => {
    const [counter, setCounter] = useState(0);

    const items = useMemo(
      () =>
        Array.from({ length: 20 }, (_, i) => ({
          id: `item-${i}`,
          value: Math.floor(Math.random() * 100),
        })),
      [] // Items never change
    );

    return (
      <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
        <div
          style={{
            display: "flex",
            alignItems: "center",
            gap: "1rem",
            padding: "1rem",
            background: "var(--color-surface)",
            borderRadius: "var(--border-radius-md)",
            border: "1px solid var(--color-border)",
          }}
        >
          <button
            onClick={() => setCounter((c) => c + 1)}
            style={{
              padding: "0.5rem 1rem",
              background: "var(--color-primary)",
              color: "white",
              border: "none",
              borderRadius: "var(--border-radius-sm)",
              cursor: "pointer",
            }}
          >
            Force Re-render ({counter})
          </button>
          <span style={{ color: "var(--color-text-secondary)", fontSize: "0.875rem" }}>
            Click to trigger parent re-render. Memoized items show their render counts.
          </span>
        </div>

        <MemoizedList items={items} highlightThreshold={50} />

        <p
          style={{
            fontSize: "0.75rem",
            color: "var(--color-text-secondary)",
            margin: 0,
          }}
        >
          üí° Notice how memoized items don't re-render when filtering or when
          the parent re-renders with unchanged props.
        </p>
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story: `
React.memo prevents unnecessary re-renders when props haven't changed.

\`\`\`tsx
const MemoizedItem = React.memo(({ id, value }) => {
  // Only re-renders when id or value changes
  return <div>{id}: {value}</div>;
});
\`\`\`
        `,
      },
    },
  },
};

export const PerformanceComparison: StoryObj = {
  render: () => {
    const [itemCount, setItemCount] = useState(1000);
    const [virtualEnabled, setVirtualEnabled] = useState(true);
    const [renderTime, setRenderTime] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    const items = useMemo(
      () =>
        Array.from({ length: itemCount }, (_, i) => ({
          id: `item-${i}`,
          content: `Item ${i + 1}`,
        })),
      [itemCount]
    );

    useEffect(() => {
      const start = performance.now();
      // Force reflow
      if (containerRef.current) {
        containerRef.current.offsetHeight;
      }
      setRenderTime(performance.now() - start);
    }, [items, virtualEnabled]);

    return (
      <div style={{ display: "flex", flexDirection: "column", gap: "1rem" }}>
        <div
          style={{
            display: "flex",
            gap: "1rem",
            alignItems: "center",
            flexWrap: "wrap",
          }}
        >
          <label style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            <span style={{ color: "var(--color-text-secondary)" }}>Items:</span>
            <select
              value={itemCount}
              onChange={(e) => setItemCount(Number(e.target.value))}
              style={{
                padding: "0.5rem",
                border: "1px solid var(--color-border)",
                borderRadius: "var(--border-radius-sm)",
                background: "var(--color-surface)",
                color: "var(--color-text-primary)",
              }}
            >
              <option value={100}>100</option>
              <option value={1000}>1,000</option>
              <option value={5000}>5,000</option>
              <option value={10000}>10,000</option>
            </select>
          </label>

          <label style={{ display: "flex", alignItems: "center", gap: "0.5rem" }}>
            <input
              type="checkbox"
              checked={virtualEnabled}
              onChange={(e) => setVirtualEnabled(e.target.checked)}
            />
            <span style={{ color: "var(--color-text-secondary)" }}>
              Virtual scrolling
            </span>
          </label>
        </div>

        <PerformanceMetrics itemCount={itemCount} renderTime={renderTime} />

        <div ref={containerRef}>
          {virtualEnabled ? (
            <VirtualList
              items={items}
              itemHeight={36}
              containerHeight={400}
            />
          ) : (
            <div
              style={{
                height: "400px",
                overflow: "auto",
                border: "1px solid var(--color-border)",
                borderRadius: "var(--border-radius-md)",
                background: "var(--color-surface)",
              }}
            >
              {items.map((item, index) => (
                <div
                  key={item.id}
                  style={{
                    height: "36px",
                    padding: "0 1rem",
                    display: "flex",
                    alignItems: "center",
                    borderBottom: "1px solid var(--color-border)",
                    background:
                      index % 2 === 0
                        ? "var(--color-surface)"
                        : "var(--color-background)",
                  }}
                >
                  <span
                    style={{
                      width: "60px",
                      color: "var(--color-text-secondary)",
                      fontSize: "0.75rem",
                    }}
                  >
                    #{index + 1}
                  </span>
                  <span style={{ color: "var(--color-text-primary)" }}>
                    {item.content}
                  </span>
                </div>
              ))}
            </div>
          )}
        </div>

        <div
          style={{
            padding: "1rem",
            background:
              renderTime < 16
                ? "#22c55e20"
                : renderTime < 50
                ? "#f59e0b20"
                : "#ef444420",
            borderRadius: "var(--border-radius-md)",
            fontSize: "0.875rem",
          }}
        >
          {renderTime < 16 ? (
            <span style={{ color: "#22c55e" }}>
              ‚úÖ Excellent! Render time under 16ms for 60fps.
            </span>
          ) : renderTime < 50 ? (
            <span style={{ color: "#f59e0b" }}>
              ‚ö†Ô∏è Acceptable but could cause jank on slower devices.
            </span>
          ) : (
            <span style={{ color: "#ef4444" }}>
              ‚ùå Slow! Consider enabling virtual scrolling.
            </span>
          )}
        </div>
      </div>
    );
  },
  parameters: {
    docs: {
      description: {
        story: `
Interactive comparison between virtual and regular scrolling.

Try toggling virtual scrolling off with 10,000 items to see the performance difference.
        `,
      },
    },
  },
};
