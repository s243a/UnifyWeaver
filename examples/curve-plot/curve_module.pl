% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% curve_module.pl - Prolog Curve Function Definitions
%
% Defines mathematical curves for visualization via WASM.
% Uses LLVM target for compilation to WebAssembly.
%
% Pipeline: Prolog -> LLVM IR -> WASM -> TypeScript -> Chart.js

:- encoding(utf8).

:- module(curve_module, [
    curve_points/4,           % +CurveSpec, +XMin, +XMax, -Points
    evaluate_curve/3,         % +CurveSpec, +X, -Y
    generate_curve_wasm/2,    % +CurveSpecs, -LLVMCode
    generate_ts_chart_bindings/2,  % +CurveSpecs, -TSCode
    generate_html/1           % -HTMLCode
]).

:- use_module('../../src/unifyweaver/targets/llvm_target').

%% ============================================
%% CURVE DEFINITIONS
%% ============================================
%%
%% Curves are defined as compound terms:
%%   - linear(M, B)           : y = mx + b
%%   - quadratic(A, B, C)     : y = ax^2 + bx + c
%%   - cubic(A, B, C, D)      : y = ax^3 + bx^2 + cx + d
%%   - sine(Amp, Freq, Phase) : y = Amp * sin(Freq * x + Phase)
%%   - cosine(Amp, Freq, Phase)
%%   - exponential(Base, Scale)
%%   - polynomial(Coeffs)     : y = sum(Ci * x^i)

%% curve_points(+CurveSpec, +XMin, +XMax, -Points)
%  Generate sample points for a curve over [XMin, XMax].
%  Points is a list of [X, Y] pairs.
curve_points(CurveSpec, XMin, XMax, Points) :-
    NumPoints = 100,
    Step is (XMax - XMin) / NumPoints,
    findall([X, Y], (
        between(0, NumPoints, I),
        X is XMin + I * Step,
        evaluate_curve(CurveSpec, X, Y)
    ), Points).

%% evaluate_curve(+CurveSpec, +X, -Y)
%  Evaluate a curve at point X.
evaluate_curve(linear(M, B), X, Y) :-
    Y is M * X + B.

evaluate_curve(quadratic(A, B, C), X, Y) :-
    Y is A * X * X + B * X + C.

evaluate_curve(cubic(A, B, C, D), X, Y) :-
    Y is A * X * X * X + B * X * X + C * X + D.

evaluate_curve(sine(Amp, Freq, Phase), X, Y) :-
    Y is Amp * sin(Freq * X + Phase).

evaluate_curve(cosine(Amp, Freq, Phase), X, Y) :-
    Y is Amp * cos(Freq * X + Phase).

evaluate_curve(exponential(Base, Scale), X, Y) :-
    Y is Scale * exp(Base * X).

evaluate_curve(polynomial(Coeffs), X, Y) :-
    evaluate_polynomial(Coeffs, X, 0, Y).

%% evaluate_polynomial(+Coeffs, +X, +Power, -Y)
evaluate_polynomial([], _, Acc, Acc).
evaluate_polynomial([C|Cs], X, Power, Y) :-
    Term is C * (X ** Power),
    NextPower is Power + 1,
    Acc is Term,
    evaluate_polynomial(Cs, X, NextPower, PartialY),
    Y is Acc + PartialY.

%% ============================================
%% LLVM WASM CODE GENERATION
%% ============================================

%% generate_curve_wasm(+CurveSpecs, -LLVMCode)
%  Generate WASM-compatible LLVM IR for curve evaluation.
%  CurveSpecs: list of curve_def(Name, Type) where Type is:
%    linear, quadratic, cubic, sine, cosine, exponential
generate_curve_wasm(CurveSpecs, Code) :-
    generate_wasm_curve_runtime(RuntimeCode),

    findall(FuncCode, (
        member(curve_def(Name, Type), CurveSpecs),
        generate_curve_function(Name, Type, FuncCode)
    ), FuncCodes),
    atomic_list_concat(FuncCodes, '\n\n', FunctionsSection),

    format(string(Code),
'; Generated by UnifyWeaver - Curve Plotting WASM Module
; Pipeline: Prolog -> LLVM IR -> WASM -> Chart.js

source_filename = "curve_plot.ll"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-unknown"

; External declarations for math functions
declare float @llvm.sin.f32(float)
declare float @llvm.cos.f32(float)
declare float @llvm.exp.f32(float)
declare float @llvm.pow.f32(float, float)

~w

~w
', [RuntimeCode, FunctionsSection]).

%% generate_wasm_curve_runtime(-Code)
generate_wasm_curve_runtime(Code) :-
    format(string(Code),
'; Curve data storage
; Format: [count: i32] [x0, y0, x1, y1, ...] as floats
@point_count = global i32 0
@points = global [2048 x float] zeroinitializer  ; Max 1024 points (2 floats each)

; Memory management
@heap_ptr = global i32 4096  ; Start after data section

define i32 @alloc(i32 %%size) {
entry:
  %%ptr = load i32, i32* @heap_ptr
  %%new_ptr = add i32 %%ptr, %%size
  store i32 %%new_ptr, i32* @heap_ptr
  ret i32 %%ptr
}

; Add a point to the data
define void @addPoint(float %%x, float %%y) {
entry:
  %%count = load i32, i32* @point_count
  %%base = mul i32 %%count, 2

  %%idx_x = add i32 %%base, 0
  %%ptr_x = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_x
  store float %%x, float* %%ptr_x

  %%idx_y = add i32 %%base, 1
  %%ptr_y = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_y
  store float %%y, float* %%ptr_y

  %%new_count = add i32 %%count, 1
  store i32 %%new_count, i32* @point_count
  ret void
}

; Get point count
define i32 @getPointCount() {
entry:
  %%count = load i32, i32* @point_count
  ret i32 %%count
}

; Get X value at index
define float @getPointX(i32 %%idx) {
entry:
  %%base = mul i32 %%idx, 2
  %%ptr = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%base
  %%val = load float, float* %%ptr
  ret float %%val
}

; Get Y value at index
define float @getPointY(i32 %%idx) {
entry:
  %%base = mul i32 %%idx, 2
  %%idx_y = add i32 %%base, 1
  %%ptr = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_y
  %%val = load float, float* %%ptr
  ret float %%val
}

; Clear all points
define void @clearPoints() {
entry:
  store i32 0, i32* @point_count
  ret void
}
', []).

%% generate_curve_function(+Name, +Type, -Code)
generate_curve_function(Name, linear, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Linear curve: y = mx + b
; @~w_m and @~w_b are parameters set from JS
@~w_m = global float 1.0
@~w_b = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%m = load float, float* @~w_m
  %%b = load float, float* @~w_b
  %%mx = fmul float %%m, %%x
  %%y = fadd float %%mx, %%b
  ret float %%y
}

define void @set_~w_params(float %%m, float %%b) {
entry:
  store float %%m, float* @~w_m
  store float %%b, float* @~w_b
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, quadratic, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Quadratic curve: y = ax^2 + bx + c
@~w_a = global float 1.0
@~w_b = global float 0.0
@~w_c = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%a = load float, float* @~w_a
  %%b = load float, float* @~w_b
  %%c = load float, float* @~w_c
  %%x2 = fmul float %%x, %%x
  %%ax2 = fmul float %%a, %%x2
  %%bx = fmul float %%b, %%x
  %%ax2_bx = fadd float %%ax2, %%bx
  %%y = fadd float %%ax2_bx, %%c
  ret float %%y
}

define void @set_~w_params(float %%a, float %%b, float %%c) {
entry:
  store float %%a, float* @~w_a
  store float %%b, float* @~w_b
  store float %%c, float* @~w_c
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, sine, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Sine curve: y = amp * sin(freq * x + phase)
@~w_amp = global float 1.0
@~w_freq = global float 1.0
@~w_phase = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%amp = load float, float* @~w_amp
  %%freq = load float, float* @~w_freq
  %%phase = load float, float* @~w_phase
  %%fx = fmul float %%freq, %%x
  %%fxp = fadd float %%fx, %%phase
  %%sin_val = call float @llvm.sin.f32(float %%fxp)
  %%y = fmul float %%amp, %%sin_val
  ret float %%y
}

define void @set_~w_params(float %%amp, float %%freq, float %%phase) {
entry:
  store float %%amp, float* @~w_amp
  store float %%freq, float* @~w_freq
  store float %%phase, float* @~w_phase
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, cosine, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Cosine curve: y = amp * cos(freq * x + phase)
@~w_amp = global float 1.0
@~w_freq = global float 1.0
@~w_phase = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%amp = load float, float* @~w_amp
  %%freq = load float, float* @~w_freq
  %%phase = load float, float* @~w_phase
  %%fx = fmul float %%freq, %%x
  %%fxp = fadd float %%fx, %%phase
  %%cos_val = call float @llvm.cos.f32(float %%fxp)
  %%y = fmul float %%amp, %%cos_val
  ret float %%y
}

define void @set_~w_params(float %%amp, float %%freq, float %%phase) {
entry:
  store float %%amp, float* @~w_amp
  store float %%freq, float* @~w_freq
  store float %%phase, float* @~w_phase
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, exponential, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Exponential curve: y = scale * exp(base * x)
@~w_base = global float 1.0
@~w_scale = global float 1.0

define float @eval_~w(float %%x) {
entry:
  %%base = load float, float* @~w_base
  %%scale = load float, float* @~w_scale
  %%bx = fmul float %%base, %%x
  %%exp_val = call float @llvm.exp.f32(float %%bx)
  %%y = fmul float %%scale, %%exp_val
  ret float %%y
}

define void @set_~w_params(float %%base, float %%scale) {
entry:
  store float %%base, float* @~w_base
  store float %%scale, float* @~w_scale
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

%% ============================================
%% TYPESCRIPT BINDINGS GENERATION
%% ============================================

%% generate_ts_chart_bindings(+CurveSpecs, -TSCode)
%  Generate TypeScript class for curve evaluation and Chart.js integration.
generate_ts_chart_bindings(CurveSpecs, TSCode) :-
    findall(TSMethod, (
        member(curve_def(Name, Type), CurveSpecs),
        generate_ts_curve_method(Name, Type, TSMethod)
    ), TSMethods),
    atomic_list_concat(TSMethods, '\n\n', MethodsSection),

    format(string(TSCode),
'// Generated by UnifyWeaver - Curve Plotting TypeScript Bindings
// Pipeline: Prolog -> LLVM IR -> WASM -> TypeScript -> Chart.js

interface CurveWasmExports extends WebAssembly.Exports {
  memory: WebAssembly.Memory;
  alloc(size: number): number;
  addPoint(x: number, y: number): void;
  getPointCount(): number;
  getPointX(idx: number): number;
  getPointY(idx: number): number;
  clearPoints(): void;
}

export interface CurveData {
  labels: number[];
  datasets: {
    label: string;
    data: number[];
    borderColor: string;
    fill: boolean;
  }[];
}

export class CurveWasm {
  private exports: CurveWasmExports;
  private memory: WebAssembly.Memory;

  private constructor(instance: WebAssembly.Instance) {
    this.exports = instance.exports as CurveWasmExports;
    this.memory = this.exports.memory;
  }

  static async load(wasmPath: string): Promise<CurveWasm> {
    const response = await fetch(wasmPath);
    const bytes = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(bytes);
    return new CurveWasm(instance);
  }

  // Core point operations
  addPoint(x: number, y: number): void {
    this.exports.addPoint(x, y);
  }

  getPointCount(): number {
    return this.exports.getPointCount();
  }

  getPoints(): [number, number][] {
    const count = this.getPointCount();
    const points: [number, number][] = [];
    for (let i = 0; i < count; i++) {
      points.push([this.exports.getPointX(i), this.exports.getPointY(i)]);
    }
    return points;
  }

  clearPoints(): void {
    this.exports.clearPoints();
  }

  // Generate Chart.js compatible data
  toChartData(label: string, color: string = ''#00d4ff''): CurveData {
    const points = this.getPoints();
    return {
      labels: points.map(p => p[0]),
      datasets: [{
        label,
        data: points.map(p => p[1]),
        borderColor: color,
        fill: false
      }]
    };
  }

~w
}
', [MethodsSection]).

%% generate_ts_curve_method(+Name, +Type, -TSMethod)
generate_ts_curve_method(Name, linear, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = mx + b
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(m: number, b: number): void {
    (this.exports as any).set_~w_params(m, b);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, quadratic, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = ax^2 + bx + c
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(a: number, b: number, c: number): void {
    (this.exports as any).set_~w_params(a, b, c);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, sine, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = amp * sin(freq * x + phase)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(amp: number, freq: number, phase: number): void {
    (this.exports as any).set_~w_params(amp, freq, phase);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, cosine, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = amp * cos(freq * x + phase)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(amp: number, freq: number, phase: number): void {
    (this.exports as any).set_~w_params(amp, freq, phase);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, exponential, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = scale * exp(base * x)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(base: number, scale: number): void {
    (this.exports as any).set_~w_params(base, scale);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

%% ============================================
%% MAIN: GENERATE ALL FILES
%% ============================================

generate_all :-
    format('Generating curve plotting files...~n~n'),

    % Define curves to generate
    CurveSpecs = [
        curve_def(line, linear),
        curve_def(parabola, quadratic),
        curve_def(wave, sine),
        curve_def(cos_wave, cosine),
        curve_def(growth, exponential)
    ],

    % Generate LLVM IR
    generate_curve_wasm(CurveSpecs, LLVMCode),
    open('curve_plot.ll', write, S1),
    write(S1, LLVMCode),
    close(S1),
    format('  Created: curve_plot.ll~n'),

    % Generate TypeScript bindings
    generate_ts_chart_bindings(CurveSpecs, TSCode),
    open('curve_wasm.ts', write, S2),
    write(S2, TSCode),
    close(S2),
    format('  Created: curve_wasm.ts~n'),

    % Generate HTML
    generate_html(HTMLCode),
    open('index.html', write, S3),
    write(S3, HTMLCode),
    close(S3),
    format('  Created: index.html~n'),

    format('~nDone! Build WASM with:~n'),
    format('  llc -march=wasm32 -filetype=obj curve_plot.ll -o curve_plot.o~n'),
    format('  wasm-ld --no-entry --export-all curve_plot.o -o curve_plot.wasm~n'),
    format('~nOr just open index.html (uses JS fallback if WASM not available).~n').

%% ============================================
%% HTML GENERATION
%% ============================================

%% generate_html(-Code)
%  Generate the complete HTML file with Chart.js curve plotting
generate_html(Code) :-
    generate_html_css(CSS),
    generate_html_body(Body),
    generate_html_javascript(JS),
    format(string(Code),
"<!DOCTYPE html>
<html lang=\"en\">
<head>
  <meta charset=\"UTF-8\">
  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
  <title>WASM Curve Plotting - UnifyWeaver</title>
  <!-- Generated by UnifyWeaver curve_module.pl -->
  <style>
~w
  </style>
</head>
<body>
~w
  <script src=\"https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js\"></script>
  <script type=\"module\">
~w
  </script>
</body>
</html>
", [CSS, Body, JS]).

%% generate_html_css(-CSS)
generate_html_css(CSS) :-
    CSS = "    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #e0e0e0;
      min-height: 100vh;
    }
    header {
      padding: 1.5rem 2rem;
      background: rgba(255,255,255,0.05);
      border-bottom: 1px solid rgba(255,255,255,0.1);
    }
    h1 {
      font-size: 1.5rem;
      font-weight: 600;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .subtitle { color: #888; font-size: 0.9rem; margin-top: 0.25rem; }
    main {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: calc(100vh - 80px);
    }
    .sidebar {
      padding: 1.5rem;
      background: rgba(0,0,0,0.2);
      border-right: 1px solid rgba(255,255,255,0.1);
      overflow-y: auto;
    }
    .sidebar h2 {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #888;
      margin-bottom: 1rem;
    }
    .controls { display: flex; flex-direction: column; gap: 0.75rem; margin-bottom: 1.5rem; }
    .input-group { display: flex; flex-direction: column; gap: 0.25rem; }
    .input-group label { font-size: 0.8rem; color: #aaa; }
    .input-row { display: flex; gap: 0.5rem; }
    input, select {
      flex: 1;
      padding: 0.5rem 0.75rem;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      color: #fff;
      font-size: 0.9rem;
    }
    input::placeholder { color: #666; }
    button {
      padding: 0.5rem 1rem;
      background: linear-gradient(135deg, #00d4ff, #7c3aed);
      border: none;
      border-radius: 6px;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s, opacity 0.2s;
    }
    button:hover { opacity: 0.9; transform: translateY(-1px); }
    button:active { transform: translateY(0); }
    button.secondary { background: rgba(255,255,255,0.1); }
    .curve-list { margin-top: 1rem; }
    .curve-item {
      padding: 0.75rem;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .curve-item .name { font-weight: 600; color: #00d4ff; }
    .curve-item .equation { font-family: 'SF Mono', Monaco, monospace; font-size: 0.85rem; color: #aaa; }
    .curve-item button { padding: 0.25rem 0.5rem; font-size: 0.75rem; background: rgba(255,100,100,0.3); }
    #chart-container {
      padding: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #chart-container canvas {
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
      max-width: 100%;
      max-height: 100%;
    }
    .status {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      padding: 0.5rem 1rem;
      background: rgba(0,0,0,0.7);
      border-radius: 6px;
      font-size: 0.85rem;
    }
    .status.loading { color: #ffd700; }
    .status.ready { color: #00ff00; }
    .status.error { color: #ff4444; }
    .params-section { border-top: 1px solid rgba(255,255,255,0.1); padding-top: 1rem; margin-top: 1rem; }".

%% generate_html_body(-Body)
generate_html_body(Body) :-
    Body = "  <header>
    <h1>WASM Curve Plotting</h1>
    <div class=\"subtitle\">UnifyWeaver - Prolog -> LLVM -> WASM -> Chart.js</div>
  </header>
  <main>
    <div class=\"sidebar\">
      <h2>Curve Type</h2>
      <div class=\"controls\">
        <div class=\"input-group\">
          <select id=\"curveType\" onchange=\"updateParams()\">
            <option value=\"linear\">Linear (y = mx + b)</option>
            <option value=\"quadratic\">Quadratic (y = ax^2 + bx + c)</option>
            <option value=\"sine\" selected>Sine (y = A*sin(fx + p))</option>
            <option value=\"cosine\">Cosine (y = A*cos(fx + p))</option>
            <option value=\"exponential\">Exponential (y = s*e^(bx))</option>
          </select>
        </div>
      </div>
      <div class=\"params-section\" id=\"paramsSection\"></div>
      <h2>Range</h2>
      <div class=\"controls\">
        <div class=\"input-row\">
          <div class=\"input-group\">
            <label>X Min</label>
            <input type=\"number\" id=\"xMin\" value=\"-10\" step=\"1\">
          </div>
          <div class=\"input-group\">
            <label>X Max</label>
            <input type=\"number\" id=\"xMax\" value=\"10\" step=\"1\">
          </div>
        </div>
        <div class=\"input-group\">
          <label>Points</label>
          <input type=\"number\" id=\"numPoints\" value=\"200\" min=\"10\" max=\"1000\" step=\"10\">
        </div>
      </div>
      <div class=\"controls\">
        <button onclick=\"plotCurve()\">Plot Curve</button>
        <button class=\"secondary\" onclick=\"clearChart()\">Clear</button>
        <button class=\"secondary\" onclick=\"loadPreset()\">Load Preset</button>
      </div>
      <div class=\"curve-list\">
        <h2>Active Curves</h2>
        <div id=\"curves\"></div>
      </div>
    </div>
    <div id=\"chart-container\">
      <canvas id=\"chart\"></canvas>
    </div>
  </main>
  <div id=\"status\" class=\"status loading\">Loading...</div>".

%% generate_html_javascript(-JS)
generate_html_javascript(JS) :-
    JS = "    // CurveWasm - Generated by UnifyWeaver (JS fallback if WASM unavailable)
    class CurveWasm {
      constructor() {
        this.points = [];
        this.params = {
          linear: { m: 1, b: 0 },
          quadratic: { a: 0.1, b: 0, c: 0 },
          sine: { amp: 1, freq: 1, phase: 0 },
          cosine: { amp: 1, freq: 1, phase: 0 },
          exponential: { base: 0.1, scale: 1 }
        };
      }

      static async load(wasmPath) {
        try {
          const response = await fetch(wasmPath);
          if (response.ok) {
            const bytes = await response.arrayBuffer();
            const imports = { env: { sinf: Math.sin, cosf: Math.cos, expf: Math.exp } };
            const { instance } = await WebAssembly.instantiate(bytes, imports);
            const wasm = new CurveWasm();
            wasm.wasmInstance = instance;
            wasm.useWasm = true;
            return wasm;
          }
        } catch (e) {
          console.log('WASM not available, using JS fallback:', e.message);
        }
        return new CurveWasm();
      }

      setParams(type, params) { this.params[type] = { ...this.params[type], ...params }; }

      eval(type, x) {
        const p = this.params[type];
        switch (type) {
          case 'linear': return p.m * x + p.b;
          case 'quadratic': return p.a * x * x + p.b * x + p.c;
          case 'sine': return p.amp * Math.sin(p.freq * x + p.phase);
          case 'cosine': return p.amp * Math.cos(p.freq * x + p.phase);
          case 'exponential': return p.scale * Math.exp(p.base * x);
          default: return 0;
        }
      }

      generate(type, xMin, xMax, numPoints) {
        this.points = [];
        const step = (xMax - xMin) / numPoints;
        for (let i = 0; i <= numPoints; i++) {
          const x = xMin + i * step;
          this.points.push([x, this.eval(type, x)]);
        }
        return this.points;
      }

      getPoints() { return this.points; }
      clearPoints() { this.points = []; }
    }

    let chart, curveWasm, curveCounter = 0;
    const curveColors = ['#00d4ff', '#7c3aed', '#ff6b6b', '#4ecdc4', '#ffd93d'];
    const paramConfigs = {
      linear: [{ id: 'm', label: 'Slope (m)', default: 1, step: 0.1 }, { id: 'b', label: 'Intercept (b)', default: 0, step: 0.5 }],
      quadratic: [{ id: 'a', label: 'a (x^2)', default: 0.1, step: 0.05 }, { id: 'b', label: 'b (x)', default: 0, step: 0.1 }, { id: 'c', label: 'c', default: 0, step: 0.5 }],
      sine: [{ id: 'amp', label: 'Amplitude', default: 1, step: 0.1 }, { id: 'freq', label: 'Frequency', default: 1, step: 0.1 }, { id: 'phase', label: 'Phase', default: 0, step: 0.1 }],
      cosine: [{ id: 'amp', label: 'Amplitude', default: 1, step: 0.1 }, { id: 'freq', label: 'Frequency', default: 1, step: 0.1 }, { id: 'phase', label: 'Phase', default: 0, step: 0.1 }],
      exponential: [{ id: 'base', label: 'Base rate', default: 0.1, step: 0.05 }, { id: 'scale', label: 'Scale', default: 1, step: 0.1 }]
    };

    async function init() {
      try {
        curveWasm = await CurveWasm.load('curve_plot.wasm');
        chart = new Chart(document.getElementById('chart'), {
          type: 'line',
          data: { labels: [], datasets: [] },
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: {
              x: { type: 'linear', position: 'center', grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#888' } },
              y: { type: 'linear', position: 'center', grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#888' } }
            },
            plugins: { legend: { labels: { color: '#e0e0e0' } } }
          }
        });
        updateParams();
        document.getElementById('status').textContent = 'Ready';
        document.getElementById('status').className = 'status ready';
      } catch (err) {
        document.getElementById('status').textContent = 'Error: ' + err.message;
        document.getElementById('status').className = 'status error';
      }
    }

    window.updateParams = function() {
      const type = document.getElementById('curveType').value;
      const config = paramConfigs[type];
      document.getElementById('paramsSection').innerHTML = '<h2>Parameters</h2><div class=\"controls\">' +
        config.map(p => `<div class=\"input-group\"><label>${p.label}</label><input type=\"number\" id=\"param_${p.id}\" value=\"${p.default}\" step=\"${p.step}\"></div>`).join('') + '</div>';
    };

    function getCurrentParams() {
      const type = document.getElementById('curveType').value;
      const params = {};
      paramConfigs[type].forEach(p => { params[p.id] = parseFloat(document.getElementById(`param_${p.id}`).value); });
      return params;
    }

    function formatEquation(type, params) {
      switch (type) {
        case 'linear': return `y = ${params.m}x + ${params.b}`;
        case 'quadratic': return `y = ${params.a}x^2 + ${params.b}x + ${params.c}`;
        case 'sine': return `y = ${params.amp}*sin(${params.freq}x + ${params.phase})`;
        case 'cosine': return `y = ${params.amp}*cos(${params.freq}x + ${params.phase})`;
        case 'exponential': return `y = ${params.scale}*e^(${params.base}x)`;
        default: return '';
      }
    }

    window.plotCurve = function() {
      const type = document.getElementById('curveType').value;
      const xMin = parseFloat(document.getElementById('xMin').value);
      const xMax = parseFloat(document.getElementById('xMax').value);
      const numPoints = parseInt(document.getElementById('numPoints').value);
      const params = getCurrentParams();
      curveWasm.setParams(type, params);
      const points = curveWasm.generate(type, xMin, xMax, numPoints);
      const color = curveColors[curveCounter % curveColors.length];
      const label = `${type} #${curveCounter + 1}`;
      chart.data.datasets.push({
        label, data: points.map(p => ({ x: p[0], y: p[1] })),
        borderColor: color, backgroundColor: color, fill: false, pointRadius: 0, borderWidth: 2
      });
      chart.update();
      const curveId = curveCounter;
      document.getElementById('curves').innerHTML += `<div class=\"curve-item\" id=\"curve-${curveId}\"><div><div class=\"name\" style=\"color: ${color}\">${label}</div><div class=\"equation\">${formatEquation(type, params)}</div></div><button onclick=\"removeCurve(${curveId})\">X</button></div>`;
      curveCounter++;
    };

    window.removeCurve = function(id) {
      const idx = chart.data.datasets.findIndex(d => d.label.endsWith(`#${id + 1}`));
      if (idx >= 0) { chart.data.datasets.splice(idx, 1); chart.update(); }
      document.getElementById(`curve-${id}`)?.remove();
    };

    window.clearChart = function() {
      chart.data.datasets = [];
      chart.update();
      document.getElementById('curves').innerHTML = '';
      curveCounter = 0;
    };

    window.loadPreset = function() {
      clearChart();
      curveWasm.setParams('sine', { amp: 1, freq: 1, phase: 0 });
      let pts = curveWasm.generate('sine', -10, 10, 200);
      chart.data.datasets.push({ label: 'sin(x)', data: pts.map(p => ({ x: p[0], y: p[1] })), borderColor: '#00d4ff', fill: false, pointRadius: 0, borderWidth: 2 });
      curveWasm.setParams('cosine', { amp: 1, freq: 1, phase: 0 });
      pts = curveWasm.generate('cosine', -10, 10, 200);
      chart.data.datasets.push({ label: 'cos(x)', data: pts.map(p => ({ x: p[0], y: p[1] })), borderColor: '#7c3aed', fill: false, pointRadius: 0, borderWidth: 2 });
      curveWasm.setParams('quadratic', { a: 0.05, b: 0, c: -2 });
      pts = curveWasm.generate('quadratic', -10, 10, 200);
      chart.data.datasets.push({ label: '0.05x^2 - 2', data: pts.map(p => ({ x: p[0], y: p[1] })), borderColor: '#ff6b6b', fill: false, pointRadius: 0, borderWidth: 2 });
      chart.update();
      document.getElementById('curves').innerHTML = '<div class=\"curve-item\"><div><div class=\"name\" style=\"color: #00d4ff\">sin(x)</div><div class=\"equation\">y = sin(x)</div></div></div><div class=\"curve-item\"><div><div class=\"name\" style=\"color: #7c3aed\">cos(x)</div><div class=\"equation\">y = cos(x)</div></div></div><div class=\"curve-item\"><div><div class=\"name\" style=\"color: #ff6b6b\">parabola</div><div class=\"equation\">y = 0.05x^2 - 2</div></div></div>';
    };

    init();".

% Run with: swipl -g "consult('curve_module.pl'), curve_module:generate_all" -t halt
