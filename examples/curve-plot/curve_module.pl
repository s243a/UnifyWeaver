% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% curve_module.pl - Prolog Curve Function Definitions
%
% Defines mathematical curves for visualization via WASM.
% Uses LLVM target for compilation to WebAssembly.
%
% Pipeline: Prolog -> LLVM IR -> WASM -> TypeScript -> Chart.js

:- encoding(utf8).

:- module(curve_module, [
    curve_points/4,           % +CurveSpec, +XMin, +XMax, -Points
    evaluate_curve/3,         % +CurveSpec, +X, -Y
    generate_curve_wasm/2,    % +CurveSpecs, -LLVMCode
    generate_ts_chart_bindings/2  % +CurveSpecs, -TSCode
]).

:- use_module('../../src/unifyweaver/targets/llvm_target').

%% ============================================
%% CURVE DEFINITIONS
%% ============================================
%%
%% Curves are defined as compound terms:
%%   - linear(M, B)           : y = mx + b
%%   - quadratic(A, B, C)     : y = ax^2 + bx + c
%%   - cubic(A, B, C, D)      : y = ax^3 + bx^2 + cx + d
%%   - sine(Amp, Freq, Phase) : y = Amp * sin(Freq * x + Phase)
%%   - cosine(Amp, Freq, Phase)
%%   - exponential(Base, Scale)
%%   - polynomial(Coeffs)     : y = sum(Ci * x^i)

%% curve_points(+CurveSpec, +XMin, +XMax, -Points)
%  Generate sample points for a curve over [XMin, XMax].
%  Points is a list of [X, Y] pairs.
curve_points(CurveSpec, XMin, XMax, Points) :-
    NumPoints = 100,
    Step is (XMax - XMin) / NumPoints,
    findall([X, Y], (
        between(0, NumPoints, I),
        X is XMin + I * Step,
        evaluate_curve(CurveSpec, X, Y)
    ), Points).

%% evaluate_curve(+CurveSpec, +X, -Y)
%  Evaluate a curve at point X.
evaluate_curve(linear(M, B), X, Y) :-
    Y is M * X + B.

evaluate_curve(quadratic(A, B, C), X, Y) :-
    Y is A * X * X + B * X + C.

evaluate_curve(cubic(A, B, C, D), X, Y) :-
    Y is A * X * X * X + B * X * X + C * X + D.

evaluate_curve(sine(Amp, Freq, Phase), X, Y) :-
    Y is Amp * sin(Freq * X + Phase).

evaluate_curve(cosine(Amp, Freq, Phase), X, Y) :-
    Y is Amp * cos(Freq * X + Phase).

evaluate_curve(exponential(Base, Scale), X, Y) :-
    Y is Scale * exp(Base * X).

evaluate_curve(polynomial(Coeffs), X, Y) :-
    evaluate_polynomial(Coeffs, X, 0, Y).

%% evaluate_polynomial(+Coeffs, +X, +Power, -Y)
evaluate_polynomial([], _, Acc, Acc).
evaluate_polynomial([C|Cs], X, Power, Y) :-
    Term is C * (X ** Power),
    NextPower is Power + 1,
    Acc is Term,
    evaluate_polynomial(Cs, X, NextPower, PartialY),
    Y is Acc + PartialY.

%% ============================================
%% LLVM WASM CODE GENERATION
%% ============================================

%% generate_curve_wasm(+CurveSpecs, -LLVMCode)
%  Generate WASM-compatible LLVM IR for curve evaluation.
%  CurveSpecs: list of curve_def(Name, Type) where Type is:
%    linear, quadratic, cubic, sine, cosine, exponential
generate_curve_wasm(CurveSpecs, Code) :-
    generate_wasm_curve_runtime(RuntimeCode),

    findall(FuncCode, (
        member(curve_def(Name, Type), CurveSpecs),
        generate_curve_function(Name, Type, FuncCode)
    ), FuncCodes),
    atomic_list_concat(FuncCodes, '\n\n', FunctionsSection),

    format(string(Code),
'; Generated by UnifyWeaver - Curve Plotting WASM Module
; Pipeline: Prolog -> LLVM IR -> WASM -> Chart.js

source_filename = "curve_plot.ll"
target datalayout = "e-m:e-p:32:32-i64:64-n32:64-S128"
target triple = "wasm32-unknown-unknown"

; External declarations for math functions
declare float @llvm.sin.f32(float)
declare float @llvm.cos.f32(float)
declare float @llvm.exp.f32(float)
declare float @llvm.pow.f32(float, float)

~w

~w
', [RuntimeCode, FunctionsSection]).

%% generate_wasm_curve_runtime(-Code)
generate_wasm_curve_runtime(Code) :-
    format(string(Code),
'; Curve data storage
; Format: [count: i32] [x0, y0, x1, y1, ...] as floats
@point_count = global i32 0
@points = global [2048 x float] zeroinitializer  ; Max 1024 points (2 floats each)

; Memory management
@heap_ptr = global i32 4096  ; Start after data section

define i32 @alloc(i32 %%size) {
entry:
  %%ptr = load i32, i32* @heap_ptr
  %%new_ptr = add i32 %%ptr, %%size
  store i32 %%new_ptr, i32* @heap_ptr
  ret i32 %%ptr
}

; Add a point to the data
define void @addPoint(float %%x, float %%y) {
entry:
  %%count = load i32, i32* @point_count
  %%base = mul i32 %%count, 2

  %%idx_x = add i32 %%base, 0
  %%ptr_x = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_x
  store float %%x, float* %%ptr_x

  %%idx_y = add i32 %%base, 1
  %%ptr_y = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_y
  store float %%y, float* %%ptr_y

  %%new_count = add i32 %%count, 1
  store i32 %%new_count, i32* @point_count
  ret void
}

; Get point count
define i32 @getPointCount() {
entry:
  %%count = load i32, i32* @point_count
  ret i32 %%count
}

; Get X value at index
define float @getPointX(i32 %%idx) {
entry:
  %%base = mul i32 %%idx, 2
  %%ptr = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%base
  %%val = load float, float* %%ptr
  ret float %%val
}

; Get Y value at index
define float @getPointY(i32 %%idx) {
entry:
  %%base = mul i32 %%idx, 2
  %%idx_y = add i32 %%base, 1
  %%ptr = getelementptr [2048 x float], [2048 x float]* @points, i32 0, i32 %%idx_y
  %%val = load float, float* %%ptr
  ret float %%val
}

; Clear all points
define void @clearPoints() {
entry:
  store i32 0, i32* @point_count
  ret void
}
', []).

%% generate_curve_function(+Name, +Type, -Code)
generate_curve_function(Name, linear, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Linear curve: y = mx + b
; @~w_m and @~w_b are parameters set from JS
@~w_m = global float 1.0
@~w_b = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%m = load float, float* @~w_m
  %%b = load float, float* @~w_b
  %%mx = fmul float %%m, %%x
  %%y = fadd float %%mx, %%b
  ret float %%y
}

define void @set_~w_params(float %%m, float %%b) {
entry:
  store float %%m, float* @~w_m
  store float %%b, float* @~w_b
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, quadratic, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Quadratic curve: y = ax^2 + bx + c
@~w_a = global float 1.0
@~w_b = global float 0.0
@~w_c = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%a = load float, float* @~w_a
  %%b = load float, float* @~w_b
  %%c = load float, float* @~w_c
  %%x2 = fmul float %%x, %%x
  %%ax2 = fmul float %%a, %%x2
  %%bx = fmul float %%b, %%x
  %%ax2_bx = fadd float %%ax2, %%bx
  %%y = fadd float %%ax2_bx, %%c
  ret float %%y
}

define void @set_~w_params(float %%a, float %%b, float %%c) {
entry:
  store float %%a, float* @~w_a
  store float %%b, float* @~w_b
  store float %%c, float* @~w_c
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, sine, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Sine curve: y = amp * sin(freq * x + phase)
@~w_amp = global float 1.0
@~w_freq = global float 1.0
@~w_phase = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%amp = load float, float* @~w_amp
  %%freq = load float, float* @~w_freq
  %%phase = load float, float* @~w_phase
  %%fx = fmul float %%freq, %%x
  %%fxp = fadd float %%fx, %%phase
  %%sin_val = call float @llvm.sin.f32(float %%fxp)
  %%y = fmul float %%amp, %%sin_val
  ret float %%y
}

define void @set_~w_params(float %%amp, float %%freq, float %%phase) {
entry:
  store float %%amp, float* @~w_amp
  store float %%freq, float* @~w_freq
  store float %%phase, float* @~w_phase
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, cosine, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Cosine curve: y = amp * cos(freq * x + phase)
@~w_amp = global float 1.0
@~w_freq = global float 1.0
@~w_phase = global float 0.0

define float @eval_~w(float %%x) {
entry:
  %%amp = load float, float* @~w_amp
  %%freq = load float, float* @~w_freq
  %%phase = load float, float* @~w_phase
  %%fx = fmul float %%freq, %%x
  %%fxp = fadd float %%fx, %%phase
  %%cos_val = call float @llvm.cos.f32(float %%fxp)
  %%y = fmul float %%amp, %%cos_val
  ret float %%y
}

define void @set_~w_params(float %%amp, float %%freq, float %%phase) {
entry:
  store float %%amp, float* @~w_amp
  store float %%freq, float* @~w_freq
  store float %%phase, float* @~w_phase
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_curve_function(Name, exponential, Code) :-
    atom_string(Name, NameStr),
    format(string(Code),
'; Exponential curve: y = scale * exp(base * x)
@~w_base = global float 1.0
@~w_scale = global float 1.0

define float @eval_~w(float %%x) {
entry:
  %%base = load float, float* @~w_base
  %%scale = load float, float* @~w_scale
  %%bx = fmul float %%base, %%x
  %%exp_val = call float @llvm.exp.f32(float %%bx)
  %%y = fmul float %%scale, %%exp_val
  ret float %%y
}

define void @set_~w_params(float %%base, float %%scale) {
entry:
  store float %%base, float* @~w_base
  store float %%scale, float* @~w_scale
  ret void
}
', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

%% ============================================
%% TYPESCRIPT BINDINGS GENERATION
%% ============================================

%% generate_ts_chart_bindings(+CurveSpecs, -TSCode)
%  Generate TypeScript class for curve evaluation and Chart.js integration.
generate_ts_chart_bindings(CurveSpecs, TSCode) :-
    findall(TSMethod, (
        member(curve_def(Name, Type), CurveSpecs),
        generate_ts_curve_method(Name, Type, TSMethod)
    ), TSMethods),
    atomic_list_concat(TSMethods, '\n\n', MethodsSection),

    format(string(TSCode),
'// Generated by UnifyWeaver - Curve Plotting TypeScript Bindings
// Pipeline: Prolog -> LLVM IR -> WASM -> TypeScript -> Chart.js

interface CurveWasmExports extends WebAssembly.Exports {
  memory: WebAssembly.Memory;
  alloc(size: number): number;
  addPoint(x: number, y: number): void;
  getPointCount(): number;
  getPointX(idx: number): number;
  getPointY(idx: number): number;
  clearPoints(): void;
}

export interface CurveData {
  labels: number[];
  datasets: {
    label: string;
    data: number[];
    borderColor: string;
    fill: boolean;
  }[];
}

export class CurveWasm {
  private exports: CurveWasmExports;
  private memory: WebAssembly.Memory;

  private constructor(instance: WebAssembly.Instance) {
    this.exports = instance.exports as CurveWasmExports;
    this.memory = this.exports.memory;
  }

  static async load(wasmPath: string): Promise<CurveWasm> {
    const response = await fetch(wasmPath);
    const bytes = await response.arrayBuffer();
    const { instance } = await WebAssembly.instantiate(bytes);
    return new CurveWasm(instance);
  }

  // Core point operations
  addPoint(x: number, y: number): void {
    this.exports.addPoint(x, y);
  }

  getPointCount(): number {
    return this.exports.getPointCount();
  }

  getPoints(): [number, number][] {
    const count = this.getPointCount();
    const points: [number, number][] = [];
    for (let i = 0; i < count; i++) {
      points.push([this.exports.getPointX(i), this.exports.getPointY(i)]);
    }
    return points;
  }

  clearPoints(): void {
    this.exports.clearPoints();
  }

  // Generate Chart.js compatible data
  toChartData(label: string, color: string = ''#00d4ff''): CurveData {
    const points = this.getPoints();
    return {
      labels: points.map(p => p[0]),
      datasets: [{
        label,
        data: points.map(p => p[1]),
        borderColor: color,
        fill: false
      }]
    };
  }

~w
}
', [MethodsSection]).

%% generate_ts_curve_method(+Name, +Type, -TSMethod)
generate_ts_curve_method(Name, linear, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = mx + b
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(m: number, b: number): void {
    (this.exports as any).set_~w_params(m, b);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, quadratic, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = ax^2 + bx + c
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(a: number, b: number, c: number): void {
    (this.exports as any).set_~w_params(a, b, c);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, sine, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = amp * sin(freq * x + phase)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(amp: number, freq: number, phase: number): void {
    (this.exports as any).set_~w_params(amp, freq, phase);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, cosine, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = amp * cos(freq * x + phase)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(amp: number, freq: number, phase: number): void {
    (this.exports as any).set_~w_params(amp, freq, phase);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

generate_ts_curve_method(Name, exponential, TSMethod) :-
    atom_string(Name, NameStr),
    format(string(TSMethod),
'  // ~w: y = scale * exp(base * x)
  eval_~w(x: number): number {
    return (this.exports as any).eval_~w(x);
  }

  set_~w_params(base: number, scale: number): void {
    (this.exports as any).set_~w_params(base, scale);
  }

  generate_~w(xMin: number, xMax: number, numPoints: number = 100): void {
    this.clearPoints();
    const step = (xMax - xMin) / numPoints;
    for (let i = 0; i <= numPoints; i++) {
      const x = xMin + i * step;
      const y = this.eval_~w(x);
      this.addPoint(x, y);
    }
  }', [NameStr, NameStr, NameStr, NameStr, NameStr, NameStr, NameStr]).

%% ============================================
%% MAIN: GENERATE ALL FILES
%% ============================================

generate_all :-
    format('Generating curve plotting files...~n~n'),

    % Define curves to generate
    CurveSpecs = [
        curve_def(line, linear),
        curve_def(parabola, quadratic),
        curve_def(wave, sine),
        curve_def(cos_wave, cosine),
        curve_def(growth, exponential)
    ],

    % Generate LLVM IR
    generate_curve_wasm(CurveSpecs, LLVMCode),
    open('curve_plot.ll', write, S1),
    write(S1, LLVMCode),
    close(S1),
    format('  Created: curve_plot.ll~n'),

    % Generate TypeScript bindings
    generate_ts_chart_bindings(CurveSpecs, TSCode),
    open('curve_wasm.ts', write, S2),
    write(S2, TSCode),
    close(S2),
    format('  Created: curve_wasm.ts~n'),

    format('~nDone! Build with:~n'),
    format('  llc -march=wasm32 -filetype=obj curve_plot.ll -o curve_plot.o~n'),
    format('  wasm-ld --no-entry --export-all curve_plot.o -o curve_plot.wasm~n').

:- initialization(generate_all, main).
