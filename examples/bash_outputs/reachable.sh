#!/bin/bash
# Generated by UnifyWeaver test suite
# License: MIT OR Apache-2.0
# 
# This is an example output. When you use UnifyWeaver on your own code,
# your output is yours to license as you choose.
#
# reachable - transitive closure of related

# Check for base stream function
related_get_stream() {
    if declare -f related_stream >/dev/null 2>&1; then
        related_stream
    elif declare -f related >/dev/null 2>&1; then
        related
    else
        echo "Error: related not found" >&2
        return 1
    fi
}

# Main function
reachable() {
    local start="$1"
    local target="$2"
    
    if [[ -z "$target" ]]; then
        reachable_all "$start"
    else
        reachable_check "$start" "$target"
    fi
}

# Find all reachable using BFS
reachable_all() {
    local start="$1"
    declare -A visited
    local queue_file="/tmp/reachable_queue_$"
    local next_queue="/tmp/reachable_next_$"
    
    trap "rm -f $queue_file $next_queue" EXIT PIPE
    
    echo "$start" > "$queue_file"
    visited["$start"]=1
    
    while [[ -s "$queue_file" ]]; do
        > "$next_queue"
        
        while IFS= read -r current; do
            # Use process substitution to keep while loop in current shell
            while IFS=":" read -r from to; do
                if [[ "$from" == "$current" && -z "${visited[$to]}" ]]; then
                    visited["$to"]=1
                    echo "$to" >> "$next_queue"
                    echo "$start:$to"
                fi
            done < <(related_get_stream | grep "^$current:")
        done < "$queue_file"
        
        mv "$next_queue" "$queue_file"
    done
    
    rm -f "$queue_file" "$next_queue"
}

# Check specific relationship
reachable_check() {
    local start="$1"
    local target="$2"
    reachable_all "$start" | grep -q "^$start:$target$" && echo "$start:$target"
}

# Stream function
reachable_stream() {
    reachable_all "$1"
}