% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% matrix_module.pl - Pyodide Matrix Operations Example
%
% Demonstrates UnifyWeaver generating Python code for Pyodide
% that exposes NumPy matrix operations to TypeScript in the browser.
%
% Usage:
%   swipl -g "matrix_module:generate_all" -t halt matrix_module.pl
%
% This generates:
%   - matrix_lib.py: Python module with NumPy matrix operations
%   - matrix_wasm.ts: TypeScript bindings for the Python library

:- module(matrix_module, [
    generate_all/0,
    generate_python_module/1,
    generate_typescript_bindings/1,
    generate_html/1
]).

:- use_module('../../src/unifyweaver/targets/python_pyodide_target').

%% generate_all/0
%  Generate all files for the Pyodide matrix example
generate_all :-
    format('Generating Pyodide matrix library...~n'),

    generate_python_module(PythonCode),
    open('matrix_lib.py', write, PyStream),
    write(PyStream, PythonCode),
    close(PyStream),
    format('  Created matrix_lib.py~n'),

    generate_typescript_bindings(TSCode),
    open('matrix_wasm.ts', write, TSStream),
    write(TSStream, TSCode),
    close(TSStream),
    format('  Created matrix_wasm.ts~n'),

    generate_html(HTMLCode),
    open('index.html', write, HTMLStream),
    write(HTMLStream, HTMLCode),
    close(HTMLStream),
    format('  Created index.html~n'),

    format('Done! Open index.html in a browser to test.~n').

%% generate_python_module(-Code)
%  Generate Python module with NumPy matrix operations
generate_python_module(Code) :-
    format(string(Code),
"# matrix_lib.py - NumPy Matrix Operations for Pyodide
# Generated by UnifyWeaver
# Runs in browser via WebAssembly - no server required

import numpy as np
from numpy.linalg import inv, eig, svd, det, norm, solve
import json

# ============================================================================
# MATRIX OPERATIONS
# ============================================================================

def matrix_inverse(matrix_data):
    \"\"\"
    Compute the inverse of a matrix.

    Args:
        matrix_data: 2D list representing the matrix

    Returns:
        Inverted matrix as nested list
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    try:
        A_inv = inv(A)
        return A_inv.tolist()
    except np.linalg.LinAlgError:
        return {'error': 'Matrix is singular and cannot be inverted'}

def matrix_eigenvalues(matrix_data):
    \"\"\"
    Compute eigenvalues and eigenvectors of a matrix.

    Args:
        matrix_data: 2D list representing a square matrix

    Returns:
        Dictionary with 'eigenvalues' and 'eigenvectors'
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)

    # Convert complex to real if possible, otherwise return as dict
    if np.isrealobj(eigenvalues):
        eig_vals = eigenvalues.tolist()
    else:
        eig_vals = [{'real': v.real, 'imag': v.imag} for v in eigenvalues]

    return {
        'eigenvalues': eig_vals,
        'eigenvectors': eigenvectors.tolist()
    }

def matrix_svd(matrix_data):
    \"\"\"
    Compute Singular Value Decomposition: A = U @ S @ Vh

    Args:
        matrix_data: 2D list representing the matrix

    Returns:
        Dictionary with 'U', 'S' (singular values), 'Vh'
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    U, S, Vh = svd(A)
    return {
        'U': U.tolist(),
        'S': S.tolist(),
        'Vh': Vh.tolist()
    }

def matrix_determinant(matrix_data):
    \"\"\"Compute the determinant of a square matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return float(det(A))

def matrix_norm(matrix_data, ord=None):
    \"\"\"Compute the norm of a matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return float(norm(A, ord=ord))

def solve_linear_system(A_data, b_data):
    \"\"\"
    Solve the linear system Ax = b.

    Args:
        A_data: Coefficient matrix
        b_data: Right-hand side vector

    Returns:
        Solution vector x
    \"\"\"
    A = np.array(A_data, dtype=np.float64)
    b = np.array(b_data, dtype=np.float64)
    x = solve(A, b)
    return x.tolist()

def matrix_multiply(A_data, B_data):
    \"\"\"Matrix multiplication A @ B.\"\"\"
    A = np.array(A_data, dtype=np.float64)
    B = np.array(B_data, dtype=np.float64)
    return (A @ B).tolist()

def matrix_transpose(matrix_data):
    \"\"\"Transpose a matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return A.T.tolist()

# ============================================================================
# VISUALIZATION HELPERS
# ============================================================================

def generate_transform_points(matrix_data, num_points=100):
    \"\"\"
    Generate points showing how a 2x2 matrix transforms the unit circle.

    Returns points before and after transformation for visualization.
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)

    # Generate unit circle points
    theta = np.linspace(0, 2 * np.pi, num_points)
    circle_x = np.cos(theta)
    circle_y = np.sin(theta)
    circle = np.vstack([circle_x, circle_y])  # 2 x num_points

    # Transform the circle
    transformed = A @ circle

    return {
        'original': {
            'x': circle_x.tolist(),
            'y': circle_y.tolist()
        },
        'transformed': {
            'x': transformed[0].tolist(),
            'y': transformed[1].tolist()
        }
    }

def generate_eigenvector_lines(matrix_data, scale=2.0):
    \"\"\"
    Generate line data for eigenvectors visualization.
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)

    lines = []
    for i in range(len(eigenvalues)):
        ev = eigenvectors[:, i].real  # Take real part
        lines.append({
            'eigenvalue': float(eigenvalues[i].real),
            'start': {'x': -scale * ev[0], 'y': -scale * ev[1]},
            'end': {'x': scale * ev[0], 'y': scale * ev[1]}
        })

    return lines

def linear_regression(x_data, y_data):
    \"\"\"
    Perform linear regression using least squares.

    Returns slope, intercept, and fitted line points.
    \"\"\"
    x = np.array(x_data, dtype=np.float64)
    y = np.array(y_data, dtype=np.float64)

    # Design matrix for y = mx + b
    A = np.vstack([x, np.ones(len(x))]).T

    # Least squares solution
    result = np.linalg.lstsq(A, y, rcond=None)
    m, b = result[0]

    # Generate fitted line
    x_fit = np.linspace(x.min(), x.max(), 100)
    y_fit = m * x_fit + b

    return {
        'slope': float(m),
        'intercept': float(b),
        'r_squared': float(1 - np.sum((y - (m*x + b))**2) / np.sum((y - y.mean())**2)),
        'fit_line': {
            'x': x_fit.tolist(),
            'y': y_fit.tolist()
        }
    }

# ============================================================================
# EXPORT REGISTRY
# ============================================================================

EXPORTS = {
    'inverse': matrix_inverse,
    'eigenvalues': matrix_eigenvalues,
    'svd': matrix_svd,
    'determinant': matrix_determinant,
    'norm': matrix_norm,
    'solve': solve_linear_system,
    'multiply': matrix_multiply,
    'transpose': matrix_transpose,
    'transform_points': generate_transform_points,
    'eigenvector_lines': generate_eigenvector_lines,
    'linear_regression': linear_regression
}

def call_function(name, *args):
    \"\"\"Call exported function by name (for JS interop).\"\"\"
    if name in EXPORTS:
        return EXPORTS[name](*args)
    raise ValueError(f'Unknown function: {name}')
", []).

%% generate_typescript_bindings(-Code)
%  Generate TypeScript bindings for the Python library
generate_typescript_bindings(Code) :-
    format(string(Code),
"// matrix_wasm.ts - TypeScript bindings for Pyodide matrix library
// Generated by UnifyWeaver

// Type definitions
interface Complex {
    real: number;
    imag: number;
}

interface EigenResult {
    eigenvalues: (number | Complex)[];
    eigenvectors: number[][];
}

interface SVDResult {
    U: number[][];
    S: number[];
    Vh: number[][];
}

interface TransformPoints {
    original: { x: number[]; y: number[] };
    transformed: { x: number[]; y: number[] };
}

interface EigenvectorLine {
    eigenvalue: number;
    start: { x: number; y: number };
    end: { x: number; y: number };
}

interface RegressionResult {
    slope: number;
    intercept: number;
    r_squared: number;
    fit_line: { x: number[]; y: number[] };
}

// Pyodide Matrix Library Wrapper
class MatrixLib {
    private pyodide: any;
    private ready: boolean = false;
    private pythonCode: string = '';

    async init(): Promise<void> {
        if (this.ready) return;

        console.log('Loading Pyodide...');
        // @ts-ignore - loadPyodide is loaded from CDN
        this.pyodide = await loadPyodide();

        console.log('Loading NumPy...');
        await this.pyodide.loadPackage('numpy');

        // Load our Python module
        console.log('Loading matrix library...');
        const response = await fetch('matrix_lib.py');
        this.pythonCode = await response.text();
        await this.pyodide.runPythonAsync(this.pythonCode);

        this.ready = true;
        console.log('Matrix library ready!');
    }

    private async callPython(funcName: string, ...args: any[]): Promise<any> {
        if (!this.ready) await this.init();

        const argsJson = JSON.stringify(args);
        const code = `
import json
args = json.loads('${argsJson.replace(/'/g, \"\\\\'\").replace(/\\\\/g, '\\\\\\\\')}')
result = call_function('${funcName}', *args)
json.dumps(result if not hasattr(result, 'tolist') else result.tolist())
        `;
        const resultJson = await this.pyodide.runPythonAsync(code);
        return JSON.parse(resultJson);
    }

    // Matrix Operations
    async inverse(matrix: number[][]): Promise<number[][] | { error: string }> {
        return this.callPython('inverse', matrix);
    }

    async eigenvalues(matrix: number[][]): Promise<EigenResult> {
        return this.callPython('eigenvalues', matrix);
    }

    async svd(matrix: number[][]): Promise<SVDResult> {
        return this.callPython('svd', matrix);
    }

    async determinant(matrix: number[][]): Promise<number> {
        return this.callPython('determinant', matrix);
    }

    async norm(matrix: number[][]): Promise<number> {
        return this.callPython('norm', matrix);
    }

    async solve(A: number[][], b: number[]): Promise<number[]> {
        return this.callPython('solve', A, b);
    }

    async multiply(A: number[][], B: number[][]): Promise<number[][]> {
        return this.callPython('multiply', A, B);
    }

    async transpose(matrix: number[][]): Promise<number[][]> {
        return this.callPython('transpose', matrix);
    }

    // Visualization helpers
    async transformPoints(matrix: number[][], numPoints?: number): Promise<TransformPoints> {
        return this.callPython('transform_points', matrix, numPoints || 100);
    }

    async eigenvectorLines(matrix: number[][], scale?: number): Promise<EigenvectorLine[]> {
        return this.callPython('eigenvector_lines', matrix, scale || 2.0);
    }

    async linearRegression(x: number[], y: number[]): Promise<RegressionResult> {
        return this.callPython('linear_regression', x, y);
    }
}

// Global instance
const matrixLib = new MatrixLib();
", []).

%% generate_html(-Code)
%  Generate the complete HTML file with embedded CSS, JavaScript, and Pyodide integration
generate_html(Code) :-
    generate_html_css(CSS),
    generate_html_body(Body),
    generate_html_javascript(JS),
    format(string(Code),
"<!DOCTYPE html>
<html lang=\"en\">
<head>
    <meta charset=\"UTF-8\">
    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">
    <title>Pyodide Matrix Visualization - UnifyWeaver</title>
    <!-- Generated by UnifyWeaver matrix_module.pl -->
    <script src=\"https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js\"></script>
    <script src=\"https://cdn.jsdelivr.net/npm/chart.js\"></script>
    <style>
~w
    </style>
</head>
<body>
~w
    <script>
~w
    </script>
</body>
</html>
", [CSS, Body, JS]).

%% generate_html_css(-CSS)
generate_html_css(CSS) :-
    CSS = "        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
        }
        h1 { color: #00d4ff; text-align: center; margin-bottom: 10px; }
        .subtitle { text-align: center; color: #888; margin-bottom: 30px; }
        .status {
            text-align: center; color: #00d4ff; font-style: italic;
            padding: 10px; background: rgba(0, 212, 255, 0.1);
            border-radius: 8px; margin-bottom: 20px;
        }
        .status.error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
        .container { display: grid; grid-template-columns: 350px 1fr; gap: 20px; }
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px; padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel h2 {
            color: #00d4ff; margin-top: 0; font-size: 1.2em;
            border-bottom: 1px solid rgba(0, 212, 255, 0.3); padding-bottom: 10px;
        }
        .matrix-input { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px; }
        .matrix-input input {
            background: #0f0f23; border: 1px solid #00d4ff; color: #fff;
            padding: 12px; border-radius: 6px; font-size: 16px; text-align: center; width: 100%;
        }
        .matrix-input input:focus { outline: none; border-color: #00ff88; box-shadow: 0 0 10px rgba(0, 255, 136, 0.3); }
        .matrix-label { grid-column: 1 / -1; color: #888; font-size: 0.9em; margin-bottom: 5px; }
        button {
            background: linear-gradient(135deg, #00d4ff 0%, #00a8cc 100%);
            color: #000; border: none; padding: 12px 24px; border-radius: 6px;
            cursor: pointer; font-weight: bold; font-size: 14px; width: 100%;
            margin-bottom: 10px; transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0, 212, 255, 0.4); }
        button:disabled { background: #444; cursor: wait; transform: none; box-shadow: none; }
        .preset-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        .preset-buttons button { font-size: 12px; padding: 8px 12px; }
        .charts-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .chart-wrapper { background: #0f0f23; border-radius: 8px; padding: 15px; position: relative; }
        .chart-wrapper h3 { color: #00d4ff; margin: 0 0 10px 0; font-size: 0.95em; }
        canvas { width: 100% !important; height: 300px !important; }
        .results {
            background: #0f0f23; border-radius: 8px; padding: 15px; margin-top: 15px;
            font-family: 'Monaco', 'Menlo', monospace; font-size: 13px; max-height: 200px; overflow-y: auto;
        }
        .results pre { margin: 0; white-space: pre-wrap; word-wrap: break-word; }
        .result-label { color: #00ff88; font-weight: bold; }
        .result-value { color: #fff; }
        .info-box {
            background: rgba(0, 212, 255, 0.1); border-left: 3px solid #00d4ff;
            padding: 10px 15px; margin: 15px 0; font-size: 0.9em; border-radius: 0 6px 6px 0;
        }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            .charts-container { grid-template-columns: 1fr; }
        }".

%% generate_html_body(-Body)
generate_html_body(Body) :-
    Body = "    <h1>Pyodide Matrix Visualization</h1>
    <p class=\"subtitle\">NumPy running in your browser via WebAssembly - No server required</p>
    <div class=\"status\" id=\"status\">Loading Pyodide and NumPy...</div>
    <div class=\"container\">
        <div class=\"panel\">
            <h2>2x2 Matrix Input</h2>
            <div class=\"matrix-label\">Matrix A = [a, b; c, d]</div>
            <div class=\"matrix-input\">
                <input type=\"number\" id=\"m00\" value=\"2\" step=\"0.1\">
                <input type=\"number\" id=\"m01\" value=\"1\" step=\"0.1\">
                <input type=\"number\" id=\"m10\" value=\"1\" step=\"0.1\">
                <input type=\"number\" id=\"m11\" value=\"3\" step=\"0.1\">
            </div>
            <div class=\"preset-buttons\">
                <button onclick=\"setPreset('rotation')\">Rotation 45 deg</button>
                <button onclick=\"setPreset('scale')\">Scale 2x</button>
                <button onclick=\"setPreset('shear')\">Shear</button>
                <button onclick=\"setPreset('reflection')\">Reflection</button>
                <button onclick=\"setPreset('singular')\">Singular</button>
                <button onclick=\"setPreset('identity')\">Identity</button>
            </div>
            <button onclick=\"computeAll()\" id=\"computeBtn\" disabled>Compute and Visualize</button>
            <div class=\"info-box\">
                <strong>How it works:</strong><br>
                JavaScript calls Python/NumPy running in Pyodide (WebAssembly).
                All computation happens in your browser - secure and private.
            </div>
            <h2>Results</h2>
            <div class=\"results\" id=\"results\">
                <pre>Click Compute and Visualize to see results...</pre>
            </div>
        </div>
        <div class=\"panel\">
            <h2>Visualizations</h2>
            <div class=\"charts-container\">
                <div class=\"chart-wrapper\"><h3>Matrix Transformation</h3><canvas id=\"transformChart\"></canvas></div>
                <div class=\"chart-wrapper\"><h3>Eigenvectors</h3><canvas id=\"eigenChart\"></canvas></div>
                <div class=\"chart-wrapper\"><h3>Singular Values (SVD)</h3><canvas id=\"svdChart\"></canvas></div>
                <div class=\"chart-wrapper\"><h3>Linear Regression Demo</h3><canvas id=\"regressionChart\"></canvas></div>
            </div>
        </div>
    </div>".

%% generate_html_javascript(-JS)
generate_html_javascript(JS) :-
    generate_python_code_for_html(PythonCode),
    format(string(JS),
"        let pyodide = null;
        let matrixLibReady = false;
        const PYTHON_CODE = `~w`;

        async function initPyodide() {
            const status = document.getElementById('status');
            const btn = document.getElementById('computeBtn');
            try {
                status.textContent = 'Loading Pyodide runtime...';
                pyodide = await loadPyodide();
                status.textContent = 'Loading NumPy (this may take a moment)...';
                await pyodide.loadPackage('numpy');
                status.textContent = 'Initializing matrix library...';
                await pyodide.runPythonAsync(PYTHON_CODE);
                matrixLibReady = true;
                status.textContent = 'Ready! NumPy is running in your browser via WebAssembly.';
                status.classList.remove('error');
                btn.disabled = false;
                computeAll();
            } catch (error) {
                status.textContent = 'Error: ' + error.message;
                status.classList.add('error');
                console.error(error);
            }
        }

        async function callPython(code) {
            const result = await pyodide.runPythonAsync(code);
            return JSON.parse(result);
        }

        function getMatrix() {
            return [
                [parseFloat(document.getElementById('m00').value), parseFloat(document.getElementById('m01').value)],
                [parseFloat(document.getElementById('m10').value), parseFloat(document.getElementById('m11').value)]
            ];
        }

        function setPreset(name) {
            const presets = {
                rotation: [[0.707, -0.707], [0.707, 0.707]],
                scale: [[2, 0], [0, 2]],
                shear: [[1, 1], [0, 1]],
                reflection: [[-1, 0], [0, 1]],
                singular: [[1, 2], [2, 4]],
                identity: [[1, 0], [0, 1]]
            };
            const m = presets[name];
            document.getElementById('m00').value = m[0][0];
            document.getElementById('m01').value = m[0][1];
            document.getElementById('m10').value = m[1][0];
            document.getElementById('m11').value = m[1][1];
            if (matrixLibReady) computeAll();
        }

        async function computeAll() {
            if (!matrixLibReady) return;
            const matrix = getMatrix();
            const matrixJson = JSON.stringify(matrix);
            const results = document.getElementById('results');
            try {
                const [inverse, eigen, svdResult, det, transform, eigenLines] = await Promise.all([
                    callPython(`import json; json.dumps(matrix_inverse(${matrixJson})`),
                    callPython(`import json; json.dumps(matrix_eigenvalues(${matrixJson})`),
                    callPython(`import json; json.dumps(matrix_svd(${matrixJson})`),
                    callPython(`import json; json.dumps(matrix_determinant(${matrixJson})`),
                    callPython(`import json; json.dumps(generate_transform_points(${matrixJson})`),
                    callPython(`import json; json.dumps(generate_eigenvector_lines(${matrixJson})`)
                ]);
                let html = '';
                html += `<span class=\\\"result-label\\\">Determinant:</span> <span class=\\\"result-value\\\">${det.toFixed(4)}</span>\\n\\n`;
                if (inverse.error) {
                    html += `<span class=\\\"result-label\\\">Inverse:</span> <span class=\\\"result-value\\\">${inverse.error}</span>\\n\\n`;
                } else {
                    html += `<span class=\\\"result-label\\\">Inverse:</span>\\n`;
                    html += `  [${inverse[0].map(v => v.toFixed(4)).join(', ')}]\\n`;
                    html += `  [${inverse[1].map(v => v.toFixed(4)).join(', ')}]\\n\\n`;
                }
                html += `<span class=\\\"result-label\\\">Eigenvalues:</span> `;
                const evs = eigen.eigenvalues.map(v => typeof v === 'object' ? `${v.real.toFixed(3)}+${v.imag.toFixed(3)}i` : v.toFixed(4));
                html += `${evs.join(', ')}\\n\\n`;
                html += `<span class=\\\"result-label\\\">Singular Values:</span> ${svdResult.S.map(v => v.toFixed(4)).join(', ')}`;
                results.innerHTML = `<pre>${html}</pre>`;
                updateTransformChart(transform);
                updateEigenChart(matrix, eigenLines);
                updateSVDChart(svdResult);
                await updateRegressionChart();
            } catch (error) {
                results.innerHTML = `<pre style=\\\"color: #ff6b6b;\\\">Error: ${error.message}</pre>`;
                console.error(error);
            }
        }

        let transformChart, eigenChart, svdChart, regressionChart;

        function initCharts() {
            const defaultOptions = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: { legend: { labels: { color: '#888' } } },
                scales: {
                    x: { grid: { color: '#333' }, ticks: { color: '#888' } },
                    y: { grid: { color: '#333' }, ticks: { color: '#888' } }
                }
            };
            transformChart = new Chart(document.getElementById('transformChart'), {
                type: 'scatter', data: { datasets: [] },
                options: { ...defaultOptions, scales: { x: { ...defaultOptions.scales.x, min: -3, max: 3 }, y: { ...defaultOptions.scales.y, min: -3, max: 3 } } }
            });
            eigenChart = new Chart(document.getElementById('eigenChart'), {
                type: 'scatter', data: { datasets: [] },
                options: { ...defaultOptions, scales: { x: { ...defaultOptions.scales.x, min: -3, max: 3 }, y: { ...defaultOptions.scales.y, min: -3, max: 3 } } }
            });
            svdChart = new Chart(document.getElementById('svdChart'), {
                type: 'bar', data: { labels: ['s1', 's2'], datasets: [] },
                options: { ...defaultOptions, scales: { x: { ...defaultOptions.scales.x }, y: { ...defaultOptions.scales.y, beginAtZero: true } } }
            });
            regressionChart = new Chart(document.getElementById('regressionChart'), {
                type: 'scatter', data: { datasets: [] }, options: defaultOptions
            });
        }

        function updateTransformChart(data) {
            const originalPoints = data.original.x.map((x, i) => ({ x, y: data.original.y[i] }));
            const transformedPoints = data.transformed.x.map((x, i) => ({ x, y: data.transformed.y[i] }));
            transformChart.data.datasets = [
                { label: 'Unit Circle', data: originalPoints, borderColor: '#00d4ff', backgroundColor: 'rgba(0, 212, 255, 0.1)', showLine: true, pointRadius: 0 },
                { label: 'Transformed', data: transformedPoints, borderColor: '#00ff88', backgroundColor: 'rgba(0, 255, 136, 0.1)', showLine: true, pointRadius: 0 }
            ];
            transformChart.update();
        }

        function updateEigenChart(matrix, lines) {
            const datasets = [];
            const theta = Array.from({ length: 100 }, (_, i) => (i / 100) * 2 * Math.PI);
            const ellipsePoints = theta.map(t => {
                const x = Math.cos(t), y = Math.sin(t);
                return { x: matrix[0][0] * x + matrix[0][1] * y, y: matrix[1][0] * x + matrix[1][1] * y };
            });
            datasets.push({ label: 'Transformed Circle', data: ellipsePoints, borderColor: 'rgba(0, 212, 255, 0.5)', showLine: true, pointRadius: 0 });
            lines.forEach((line, i) => {
                datasets.push({
                    label: `lambda = ${line.eigenvalue.toFixed(2)}`,
                    data: [{ x: line.start.x, y: line.start.y }, { x: line.end.x, y: line.end.y }],
                    borderColor: i === 0 ? '#ff6b6b' : '#ffd93d', borderWidth: 3, showLine: true, pointRadius: 5
                });
            });
            eigenChart.data.datasets = datasets;
            eigenChart.update();
        }

        function updateSVDChart(svd) {
            svdChart.data.datasets = [{ label: 'Singular Values', data: svd.S, backgroundColor: ['#00d4ff', '#00ff88'] }];
            svdChart.update();
        }

        async function updateRegressionChart() {
            const x = Array.from({ length: 20 }, (_, i) => i * 0.5);
            const y = x.map(xi => 2 * xi + 1 + (Math.random() - 0.5) * 2);
            const xJson = JSON.stringify(x), yJson = JSON.stringify(y);
            const result = await callPython(`import json; json.dumps(linear_regression(${xJson}, ${yJson}))`);
            const dataPoints = x.map((xi, i) => ({ x: xi, y: y[i] }));
            const fitPoints = result.fit_line.x.map((xi, i) => ({ x: xi, y: result.fit_line.y[i] }));
            regressionChart.data.datasets = [
                { label: 'Data Points', data: dataPoints, backgroundColor: '#00d4ff', pointRadius: 5 },
                { label: `Fit: y = ${result.slope.toFixed(2)}x + ${result.intercept.toFixed(2)} (R2 = ${result.r_squared.toFixed(3)})`, data: fitPoints, borderColor: '#00ff88', showLine: true, pointRadius: 0 }
            ];
            regressionChart.update();
        }

        document.addEventListener('DOMContentLoaded', () => {
            initCharts();
            initPyodide();
            ['m00', 'm01', 'm10', 'm11'].forEach(id => {
                document.getElementById(id).addEventListener('change', () => { if (matrixLibReady) computeAll(); });
            });
        });", [PythonCode]).

%% generate_python_code_for_html(-Code)
%  Simplified Python code for embedding in HTML
generate_python_code_for_html(Code) :-
    Code = "import numpy as np
from numpy.linalg import inv, eig, svd, det
import json

def matrix_inverse(matrix_data):
    A = np.array(matrix_data, dtype=np.float64)
    try:
        return inv(A).tolist()
    except np.linalg.LinAlgError:
        return {'error': 'Matrix is singular'}

def matrix_eigenvalues(matrix_data):
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)
    if np.iscomplexobj(eigenvalues):
        eig_vals = [{'real': float(v.real), 'imag': float(v.imag)} for v in eigenvalues]
    else:
        eig_vals = [float(v) for v in eigenvalues]
    if np.iscomplexobj(eigenvectors):
        eig_vecs = [[{'real': float(v.real), 'imag': float(v.imag)} for v in row] for row in eigenvectors.tolist()]
    else:
        eig_vecs = [[float(v) for v in row] for row in eigenvectors.tolist()]
    return {'eigenvalues': eig_vals, 'eigenvectors': eig_vecs}

def matrix_svd(matrix_data):
    A = np.array(matrix_data, dtype=np.float64)
    U, S, Vh = svd(A)
    return {'U': U.tolist(), 'S': S.tolist(), 'Vh': Vh.tolist()}

def matrix_determinant(matrix_data):
    return float(det(np.array(matrix_data, dtype=np.float64)))

def generate_transform_points(matrix_data, num_points=100):
    A = np.array(matrix_data, dtype=np.float64)
    theta = np.linspace(0, 2 * np.pi, num_points)
    circle = np.vstack([np.cos(theta), np.sin(theta)])
    transformed = A @ circle
    return {'original': {'x': np.cos(theta).tolist(), 'y': np.sin(theta).tolist()}, 'transformed': {'x': transformed[0].tolist(), 'y': transformed[1].tolist()}}

def generate_eigenvector_lines(matrix_data, scale=2.0):
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)
    lines = []
    for i in range(len(eigenvalues)):
        ev = eigenvectors[:, i].real
        lines.append({'eigenvalue': float(eigenvalues[i].real), 'start': {'x': float(-scale * ev[0]), 'y': float(-scale * ev[1])}, 'end': {'x': float(scale * ev[0]), 'y': float(scale * ev[1])}})
    return lines

def linear_regression(x_data, y_data):
    x, y = np.array(x_data, dtype=np.float64), np.array(y_data, dtype=np.float64)
    A = np.vstack([x, np.ones(len(x))]).T
    m, b = np.linalg.lstsq(A, y, rcond=None)[0]
    x_fit = np.linspace(x.min(), x.max(), 100)
    r_sq = 1 - np.sum((y - (m*x + b))**2) / np.sum((y - y.mean())**2)
    return {'slope': float(m), 'intercept': float(b), 'r_squared': float(r_sq), 'fit_line': {'x': x_fit.tolist(), 'y': (m * x_fit + b).tolist()}}".
