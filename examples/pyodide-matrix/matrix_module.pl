% SPDX-License-Identifier: MIT OR Apache-2.0
% Copyright (c) 2025 John William Creighton (s243a)
%
% matrix_module.pl - Pyodide Matrix Operations Example
%
% Demonstrates UnifyWeaver generating Python code for Pyodide
% that exposes NumPy matrix operations to TypeScript in the browser.
%
% Usage:
%   swipl -g "matrix_module:generate_all" -t halt matrix_module.pl
%
% This generates:
%   - matrix_lib.py: Python module with NumPy matrix operations
%   - matrix_wasm.ts: TypeScript bindings for the Python library

:- module(matrix_module, [
    generate_all/0,
    generate_python_module/1,
    generate_typescript_bindings/1
]).

:- use_module('../../src/unifyweaver/targets/python_pyodide_target').

%% generate_all/0
%  Generate all files for the Pyodide matrix example
generate_all :-
    format('Generating Pyodide matrix library...~n'),

    generate_python_module(PythonCode),
    open('matrix_lib.py', write, PyStream),
    write(PyStream, PythonCode),
    close(PyStream),
    format('  Created matrix_lib.py~n'),

    generate_typescript_bindings(TSCode),
    open('matrix_wasm.ts', write, TSStream),
    write(TSStream, TSCode),
    close(TSStream),
    format('  Created matrix_wasm.ts~n'),

    format('Done! Open index.html in a browser to test.~n').

%% generate_python_module(-Code)
%  Generate Python module with NumPy matrix operations
generate_python_module(Code) :-
    format(string(Code),
"# matrix_lib.py - NumPy Matrix Operations for Pyodide
# Generated by UnifyWeaver
# Runs in browser via WebAssembly - no server required

import numpy as np
from numpy.linalg import inv, eig, svd, det, norm, solve
import json

# ============================================================================
# MATRIX OPERATIONS
# ============================================================================

def matrix_inverse(matrix_data):
    \"\"\"
    Compute the inverse of a matrix.

    Args:
        matrix_data: 2D list representing the matrix

    Returns:
        Inverted matrix as nested list
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    try:
        A_inv = inv(A)
        return A_inv.tolist()
    except np.linalg.LinAlgError:
        return {'error': 'Matrix is singular and cannot be inverted'}

def matrix_eigenvalues(matrix_data):
    \"\"\"
    Compute eigenvalues and eigenvectors of a matrix.

    Args:
        matrix_data: 2D list representing a square matrix

    Returns:
        Dictionary with 'eigenvalues' and 'eigenvectors'
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)

    # Convert complex to real if possible, otherwise return as dict
    if np.isrealobj(eigenvalues):
        eig_vals = eigenvalues.tolist()
    else:
        eig_vals = [{'real': v.real, 'imag': v.imag} for v in eigenvalues]

    return {
        'eigenvalues': eig_vals,
        'eigenvectors': eigenvectors.tolist()
    }

def matrix_svd(matrix_data):
    \"\"\"
    Compute Singular Value Decomposition: A = U @ S @ Vh

    Args:
        matrix_data: 2D list representing the matrix

    Returns:
        Dictionary with 'U', 'S' (singular values), 'Vh'
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    U, S, Vh = svd(A)
    return {
        'U': U.tolist(),
        'S': S.tolist(),
        'Vh': Vh.tolist()
    }

def matrix_determinant(matrix_data):
    \"\"\"Compute the determinant of a square matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return float(det(A))

def matrix_norm(matrix_data, ord=None):
    \"\"\"Compute the norm of a matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return float(norm(A, ord=ord))

def solve_linear_system(A_data, b_data):
    \"\"\"
    Solve the linear system Ax = b.

    Args:
        A_data: Coefficient matrix
        b_data: Right-hand side vector

    Returns:
        Solution vector x
    \"\"\"
    A = np.array(A_data, dtype=np.float64)
    b = np.array(b_data, dtype=np.float64)
    x = solve(A, b)
    return x.tolist()

def matrix_multiply(A_data, B_data):
    \"\"\"Matrix multiplication A @ B.\"\"\"
    A = np.array(A_data, dtype=np.float64)
    B = np.array(B_data, dtype=np.float64)
    return (A @ B).tolist()

def matrix_transpose(matrix_data):
    \"\"\"Transpose a matrix.\"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    return A.T.tolist()

# ============================================================================
# VISUALIZATION HELPERS
# ============================================================================

def generate_transform_points(matrix_data, num_points=100):
    \"\"\"
    Generate points showing how a 2x2 matrix transforms the unit circle.

    Returns points before and after transformation for visualization.
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)

    # Generate unit circle points
    theta = np.linspace(0, 2 * np.pi, num_points)
    circle_x = np.cos(theta)
    circle_y = np.sin(theta)
    circle = np.vstack([circle_x, circle_y])  # 2 x num_points

    # Transform the circle
    transformed = A @ circle

    return {
        'original': {
            'x': circle_x.tolist(),
            'y': circle_y.tolist()
        },
        'transformed': {
            'x': transformed[0].tolist(),
            'y': transformed[1].tolist()
        }
    }

def generate_eigenvector_lines(matrix_data, scale=2.0):
    \"\"\"
    Generate line data for eigenvectors visualization.
    \"\"\"
    A = np.array(matrix_data, dtype=np.float64)
    eigenvalues, eigenvectors = eig(A)

    lines = []
    for i in range(len(eigenvalues)):
        ev = eigenvectors[:, i].real  # Take real part
        lines.append({
            'eigenvalue': float(eigenvalues[i].real),
            'start': {'x': -scale * ev[0], 'y': -scale * ev[1]},
            'end': {'x': scale * ev[0], 'y': scale * ev[1]}
        })

    return lines

def linear_regression(x_data, y_data):
    \"\"\"
    Perform linear regression using least squares.

    Returns slope, intercept, and fitted line points.
    \"\"\"
    x = np.array(x_data, dtype=np.float64)
    y = np.array(y_data, dtype=np.float64)

    # Design matrix for y = mx + b
    A = np.vstack([x, np.ones(len(x))]).T

    # Least squares solution
    result = np.linalg.lstsq(A, y, rcond=None)
    m, b = result[0]

    # Generate fitted line
    x_fit = np.linspace(x.min(), x.max(), 100)
    y_fit = m * x_fit + b

    return {
        'slope': float(m),
        'intercept': float(b),
        'r_squared': float(1 - np.sum((y - (m*x + b))**2) / np.sum((y - y.mean())**2)),
        'fit_line': {
            'x': x_fit.tolist(),
            'y': y_fit.tolist()
        }
    }

# ============================================================================
# EXPORT REGISTRY
# ============================================================================

EXPORTS = {
    'inverse': matrix_inverse,
    'eigenvalues': matrix_eigenvalues,
    'svd': matrix_svd,
    'determinant': matrix_determinant,
    'norm': matrix_norm,
    'solve': solve_linear_system,
    'multiply': matrix_multiply,
    'transpose': matrix_transpose,
    'transform_points': generate_transform_points,
    'eigenvector_lines': generate_eigenvector_lines,
    'linear_regression': linear_regression
}

def call_function(name, *args):
    \"\"\"Call exported function by name (for JS interop).\"\"\"
    if name in EXPORTS:
        return EXPORTS[name](*args)
    raise ValueError(f'Unknown function: {name}')
", []).

%% generate_typescript_bindings(-Code)
%  Generate TypeScript bindings for the Python library
generate_typescript_bindings(Code) :-
    format(string(Code),
"// matrix_wasm.ts - TypeScript bindings for Pyodide matrix library
// Generated by UnifyWeaver

// Type definitions
interface Complex {
    real: number;
    imag: number;
}

interface EigenResult {
    eigenvalues: (number | Complex)[];
    eigenvectors: number[][];
}

interface SVDResult {
    U: number[][];
    S: number[];
    Vh: number[][];
}

interface TransformPoints {
    original: { x: number[]; y: number[] };
    transformed: { x: number[]; y: number[] };
}

interface EigenvectorLine {
    eigenvalue: number;
    start: { x: number; y: number };
    end: { x: number; y: number };
}

interface RegressionResult {
    slope: number;
    intercept: number;
    r_squared: number;
    fit_line: { x: number[]; y: number[] };
}

// Pyodide Matrix Library Wrapper
class MatrixLib {
    private pyodide: any;
    private ready: boolean = false;
    private pythonCode: string = '';

    async init(): Promise<void> {
        if (this.ready) return;

        console.log('Loading Pyodide...');
        // @ts-ignore - loadPyodide is loaded from CDN
        this.pyodide = await loadPyodide();

        console.log('Loading NumPy...');
        await this.pyodide.loadPackage('numpy');

        // Load our Python module
        console.log('Loading matrix library...');
        const response = await fetch('matrix_lib.py');
        this.pythonCode = await response.text();
        await this.pyodide.runPythonAsync(this.pythonCode);

        this.ready = true;
        console.log('Matrix library ready!');
    }

    private async callPython(funcName: string, ...args: any[]): Promise<any> {
        if (!this.ready) await this.init();

        const argsJson = JSON.stringify(args);
        const code = `
import json
args = json.loads('${argsJson.replace(/'/g, \"\\\\'\").replace(/\\\\/g, '\\\\\\\\')}')
result = call_function('${funcName}', *args)
json.dumps(result if not hasattr(result, 'tolist') else result.tolist())
        `;
        const resultJson = await this.pyodide.runPythonAsync(code);
        return JSON.parse(resultJson);
    }

    // Matrix Operations
    async inverse(matrix: number[][]): Promise<number[][] | { error: string }> {
        return this.callPython('inverse', matrix);
    }

    async eigenvalues(matrix: number[][]): Promise<EigenResult> {
        return this.callPython('eigenvalues', matrix);
    }

    async svd(matrix: number[][]): Promise<SVDResult> {
        return this.callPython('svd', matrix);
    }

    async determinant(matrix: number[][]): Promise<number> {
        return this.callPython('determinant', matrix);
    }

    async norm(matrix: number[][]): Promise<number> {
        return this.callPython('norm', matrix);
    }

    async solve(A: number[][], b: number[]): Promise<number[]> {
        return this.callPython('solve', A, b);
    }

    async multiply(A: number[][], B: number[][]): Promise<number[][]> {
        return this.callPython('multiply', A, B);
    }

    async transpose(matrix: number[][]): Promise<number[][]> {
        return this.callPython('transpose', matrix);
    }

    // Visualization helpers
    async transformPoints(matrix: number[][], numPoints?: number): Promise<TransformPoints> {
        return this.callPython('transform_points', matrix, numPoints || 100);
    }

    async eigenvectorLines(matrix: number[][], scale?: number): Promise<EigenvectorLine[]> {
        return this.callPython('eigenvector_lines', matrix, scale || 2.0);
    }

    async linearRegression(x: number[], y: number[]): Promise<RegressionResult> {
        return this.callPython('linear_regression', x, y);
    }
}

// Global instance
const matrixLib = new MatrixLib();
", []).
